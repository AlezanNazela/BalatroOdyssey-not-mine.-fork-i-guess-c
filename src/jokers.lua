
-- ============================================
-- SINGULARITY - Common (Jokers 1-16)
-- ============================================

-- 1. Solitary
SMODS.Joker({
    key = 'j_singularity_solitary',
    config = { extra = { mult = 12 } },
    rarity = 1,  -- Common
    atlas = 'j_singularity_solitary',  -- Custom sprite
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            -- Count active jokers
            local joker_count = 0
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] then
                    joker_count = joker_count + 1
                end
            end
            
            -- If only one joker exists
            if joker_count == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 2. Isolated
SMODS.Joker({
    key = 'j_singularity_isolated',
    atlas = 'j_singularity_isolated',
    config = { extra = { chips = 8 } },
    rarity = 1,
    pos = { x = 0, y = 0 }, -- Common
    
    
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local empty_slots = G.jokers.config.card_limit - #G.jokers.cards
            if empty_slots > 0 then
                local bonus = empty_slots * card.ability.extra.chips
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { bonus } },
                    chip_mod = bonus,
                    colour = G.C.CHIPS
                }
            end
        end
        return nil
    end
})

-- 3. Hermit
SMODS.Joker({
    key = 'j_singularity_hermit',
    atlas = 'j_singularity_hermit',
    config = { extra = { mult = 0, mult_gain = 2, bought_this_round = false } },
    rarity = 1,  -- Common
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        -- Aplica o Mult acumulado
        if context.joker_main then
            if card.ability.extra.mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
        
        -- No final da rodada, aumenta Mult se não comprou nada
        if context.end_of_round and not context.repetition and not context.other_card then
            if not card.ability.extra.bought_this_round then
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
            -- Reset tracker para próxima rodada
            card.ability.extra.bought_this_round = false
        end
        
        -- Rastreia compras na loja
        if context.buying_card then
            card.ability.extra.bought_this_round = true
        end
        
        return nil
    end
})

-- 4. Purist
SMODS.Joker({
    key = 'j_singularity_purist',
    atlas = 'j_singularity_purist',
    config = { extra = { mult = 15 } },
    rarity = 1,  -- Common
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local deck_size = #G.playing_cards
            if deck_size == 52 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 5. Minimalist
SMODS.Joker({
    key = 'j_singularity_minimalist',
    atlas = 'j_singularity_minimalist',
    config = { extra = { mult_per_missing = 4 } },
    rarity = 1,
    pos = { x = 0, y = 0 }, -- Common
    
    
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_per_missing } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local deck_size = #G.playing_cards
            local missing = math.max(0, 52 - deck_size)
            if missing > 0 then
                local bonus = missing * card.ability.extra.mult_per_missing
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { bonus } },
                    mult_mod = bonus,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 6. Unique
SMODS.Joker({
    key = 'j_singularity_unique',
    atlas = 'j_singularity_unique',
    config = { extra = { mult = 10 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local duplicates = 0
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] and G.jokers.cards[i] ~= card and G.jokers.cards[i].ability.name == card.ability.name then
                    duplicates = duplicates + 1
                end
            end
            
            if duplicates == 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 7. Singular
SMODS.Joker({
    key = 'j_singularity_singular',
    atlas = 'j_singularity_singular',
    config = { extra = { bought_rarities = {} } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        return { vars = {} }
    end,
    
    calculate = function(self, card, context)
        if context.buying_card and context.card and context.card.ability.set == 'Joker' then
            local rarity = context.card.config.center.rarity
            if rarity and not card.ability.extra.bought_rarities[rarity] then
                card.ability.extra.bought_rarities[rarity] = true
                ease_dollars(context.card.cost)
                return {
                    message = localize('k_val_up'),
                    colour = G.C.MONEY
                }
            end
        end
        return nil
    end
})

-- 8. Monopolist
SMODS.Joker({
    key = 'j_singularity_monopolist',
    atlas = 'j_singularity_monopolist',
    config = { extra = { xmult = 1.5, min_expensive = 3, cost_threshold = 8 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult .. '', extra.min_expensive, extra.cost_threshold } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local expensive_count = 0
            
            -- Conta quantos Jokers têm custo de compra de $8 ou mais
            for i = 1, #G.jokers.cards do
                local joker = G.jokers.cards[i]
                if joker and joker.cost >= card.ability.extra.cost_threshold then
                    expensive_count = expensive_count + 1
                end
            end
            
            -- Ativa se tiver pelo menos 3 Jokers caros
            if expensive_count >= card.ability.extra.min_expensive then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 9. Exclusivo
SMODS.Joker({
    key = 'j_singularity_exclusive',
    atlas = 'j_singularity_exclusive',
    config = { extra = { xmult = 1.5, limit = 3 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult .. '' } }

    
    end,
    
    can_use = function(self, card)
        -- Impede compra se já tem 3 ou mais jokers
        if G.jokers and #G.jokers.cards >= 3 then
            return false
        end
        return true
    end,
    
    add_to_deck = function(self, card, from_debuff)
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit - 2
        end
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit + 2
        end
    end,
    
    calculate = function(self, card, context)
        -- Aplica X1.5 Mult em TODOS os jokers
        if context.other_joker then
            -- Multiplica o resultado de outro joker por 1.5
            if context.other_joker ~= card then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 10. Solitário Cósmico
SMODS.Joker({
    key = 'j_singularity_cosmic_solitary',
    atlas = 'j_singularity_cosmic_solitary',
    config = { extra = { xmult = 2 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult .. '' } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if #G.jokers.cards == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 11. Asceta
SMODS.Joker({
    key = 'j_singularity_ascetic',
    atlas = 'j_singularity_ascetic',
    config = { extra = { mult = 10, money = 2, bought_something = false } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.buying_card then
            card.ability.extra.bought_something = true
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            if not card.ability.extra.bought_something then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
            card.ability.extra.bought_something = false
        end
        
        if context.joker_main and not card.ability.extra.bought_something then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        return nil
    end
})

-- 12. One Man Army
SMODS.Joker({
    key = 'j_singularity_one_man_army',
    atlas = 'j_singularity_one_man_army',
    config = { extra = { xmult = 2 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult .. '' } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and #G.jokers.cards == 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
        return nil
    end
})

-- 13. Isolamento Total
SMODS.Joker({
    key = 'j_singularity_total_isolation',
    atlas = 'j_singularity_total_isolation',
    config = { extra = { xmult = 3 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult .. '' } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 14. Sozinho no Espaço
SMODS.Joker({
    key = 'j_singularity_alone_in_space',
    atlas = 'j_singularity_alone_in_space',
    config = { extra = { money = 2 } },
    rarity = 1,        pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            -- Calcula APENAS slots vazios de joker, NÃO cartas na mão
            local empty_slots = G.jokers.config.card_limit - #G.jokers.cards
            if empty_slots > 0 then
                local earnings = empty_slots * card.ability.extra.money
                ease_dollars(earnings)
                return {
                    message = localize('$') .. earnings,
                    colour = G.C.MONEY
                }
            end
        end
        return nil
    end
})

-- 15. Ermitão Estelar
SMODS.Joker({
    key = 'j_singularity_stellar_hermit',
    atlas = 'j_singularity_stellar_hermit',
    config = { extra = { chips = 50, used_consumable = false } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.using_consumeable then
            card.ability.extra.used_consumable = true
        end
        
        if context.joker_main and not card.ability.extra.used_consumable then
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                chip_mod = card.ability.extra.chips,
                colour = G.C.CHIPS
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.used_consumable = false
        end
        return nil
    end
})

-- 16. Solidão Cósmica
SMODS.Joker({
    key = 'j_singularity_cosmic_solitude',
    atlas = 'j_singularity_cosmic_solitude',
    config = { extra = { xmult = 1, xmult_gain = 0.2, bought_joker = false } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult .. '', extra.xmult_gain .. '' } }

    
    end,
    
    calculate = function(self, card, context)
        if context.buying_card and context.card.ability.set == 'Joker' then
            card.ability.extra.bought_joker = true
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            -- Só ativa no final do Boss Blind de cada Ante
            if G.GAME.blind and G.GAME.blind.boss then
                if not card.ability.extra.bought_joker then
                    card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_gain
                    card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_upgrade_ex'), colour = G.C.MULT })
                end
                card.ability.extra.bought_joker = false -- Reset para o próximo Ante
            end
        end
        
        if context.joker_main and card.ability.extra.xmult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
        return nil
    end
})


-- ============================================
-- SINGULARITY - Uncommon (Jokers 17-30)
-- ============================================

-- 17. Singularidade Crescente
SMODS.Joker({
    key = 'j_singularity_growing_singularity',
    atlas = 'j_singularity_growing_singularity',
    config = { extra = { xmult = 1, xmult_gain = 0.2 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult, extra.xmult_gain .. '' } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if #G.jokers.cards == 1 then
                card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_gain
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_upgrade_ex'), colour = G.C.MULT })
            end
        end
        
        if context.joker_main and card.ability.extra.xmult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
        return nil
    end
})

-- 18. Isolador Dimensional
SMODS.Joker({
    key = 'j_singularity_dimensional_isolator',
    atlas = 'j_singularity_dimensional_isolator',
    config = { extra = { mult = 50, xmult = 2 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            -- Encontra posição deste Joker
            local my_index = nil
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then
                    my_index = i
                    break
                end
            end
            
            if my_index then
                local has_left = my_index > 1
                local has_right = my_index < #G.jokers.cards
                
                -- Só ativa se NÃO tiver adjacentes EM AMBOS os lados
                -- (pode ter 1 lado vazio, mas não pode ter os 2 lados ocupados)
                if not (has_left and has_right) then
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                        mult_mod = card.ability.extra.mult,
                        Xmult_mod = card.ability.extra.xmult,
                        colour = G.C.MULT
                    }
                end
            end
        end
        return nil
    end
})

-- 19. Única Esperança
SMODS.Joker({
    key = 'j_singularity_only_hope',
    atlas = 'j_singularity_only_hope',
    config = { extra = { xmult = 5 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G and G.GAME and G.GAME.current_round and 
               G.GAME.current_round.hands_left == 1 and 
               G.jokers and G.jokers.cards and #G.jokers.cards == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 20. Monólito
SMODS.Joker({
    key = 'j_singularity_monolith',
    atlas = 'j_singularity_monolith',
    config = { extra = { xmult = 2.5, takes_slots = 2 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end,
    
    add_to_deck = function(self, card, from_debuff)
        -- Reduz limite de slots quando adicionado
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit - 1
        end
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        -- Restaura slot quando removido
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit + 1
        end
    end
})

-- 21. Solidificação
SMODS.Joker({
    key = 'j_singularity_solidification',
    atlas = 'j_singularity_solidification',
    config = { extra = { xmult = 2.5, rounds_required = 5, current_rounds = 0, last_pos = nil } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.current_rounds, extra.rounds_required, extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        -- Verifica posição no início de cada rodada
        if context.end_of_round and not context.repetition and not context.other_card then
            -- Encontra posição atual
            local current_pos = nil
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then
                    current_pos = i
                    break
                end
            end
            
            if current_pos and card.ability.extra.last_pos == current_pos then
                card.ability.extra.current_rounds = card.ability.extra.current_rounds + 1
            else
                card.ability.extra.current_rounds = 0
                card.ability.extra.last_pos = current_pos
            end
            
            if card.ability.extra.current_rounds >= card.ability.extra.rounds_required then
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = 'Solidificado!', colour = G.C.MULT })
            end
        end
        
        if context.joker_main and card.ability.extra.current_rounds >= card.ability.extra.rounds_required then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 22. Universo Paralelo
SMODS.Joker({
    key = 'j_singularity_parallel_universe',
    atlas = 'j_singularity_parallel_universe',
    config = { extra = { mult = 20 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        
        -- No fim da rodada, se houver apenas 1, cria cópia
        if context.end_of_round and not context.repetition and not context.other_card then
            local count = 0
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i].ability.name == card.ability.name then
                    count = count + 1
                end
            end
            
            if count == 1 and #G.jokers.cards < G.jokers.config.card_limit then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local copy = copy_card(card, nil)
                        copy:add_to_deck()
                        G.jokers:emplace(copy)
                        return true
                    end
                }))
                return {
                    message = 'Espelhado!',
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 23. Ponto Zero
SMODS.Joker({
    key = 'j_singularity_point_zero',
    atlas = 'j_singularity_point_zero',
    config = { extra = { xmult = 3 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.dollars == 0 and #G.jokers.cards == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 24. Singularidade Negra
SMODS.Joker({
    key = 'j_singularity_black_singularity',
    atlas = 'j_singularity_black_singularity',
    config = { extra = { mult = 0, gain = 5 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.selling_card and context.card.ability.set == 'Joker' and context.card ~= card then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT,
                card = card
            }
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 25. Estrela Solitária
SMODS.Joker({
    key = 'j_singularity_lonely_star',
    atlas = 'j_singularity_lonely_star',
    config = { extra = { xmult = 1, gain = 0.2 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult, extra.gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card and #G.jokers.cards == 1 then
            card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
        
        if context.joker_main and card.ability.extra.xmult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 26. Individualismo
SMODS.Joker({
    key = 'j_singularity_individualism',
    atlas = 'j_singularity_individualism',
    config = { extra = { mult = 50 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 27. Vazio Primordial
SMODS.Joker({
    key = 'j_singularity_primordial_void',
    atlas = 'j_singularity_primordial_void',
    config = { extra = { xmult = 1, base_xmult = 5 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        if G.jokers and not from_debuff then
            local destroyed = false
            for i = #G.jokers.cards, 1, -1 do
                if G.jokers.cards[i] ~= card then
                    G.jokers.cards[i]:start_dissolve()
                    destroyed = true
                end
            end
            if destroyed then
                card.ability.extra.xmult = card.ability.extra.base_xmult
            end
        end
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and card.ability.extra.xmult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 28. Isolamento Quântico
SMODS.Joker({
    key = 'j_singularity_quantum_isolation',
    atlas = 'j_singularity_quantum_isolation',
    config = { extra = { mult = 20, chance = 4 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.chance } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            if #G.jokers.cards == 1 and pseudorandom('quantum_isolation') < G.GAME.probabilities.normal / card.ability.extra.chance then
                if #G.jokers.cards < G.jokers.config.card_limit then
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            local copy = copy_card(card, nil)
                            copy:add_to_deck()
                            G.jokers:emplace(copy)
                            return true
                        end
                    }))
                    return {
                        message = 'Duplicado!',
                        colour = G.C.MULT
                    }
                end
            end
        end
    end
})

-- 29. Monopólio Cósmico
SMODS.Joker({
    key = 'j_singularity_cosmic_monopoly',
    atlas = 'j_singularity_cosmic_monopoly',
    config = { extra = { xmult = 3 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local same_rarity = true
            local first_rarity = nil
            for i = 1, #G.jokers.cards do
                local r = G.jokers.cards[i].config.center.rarity
                if not first_rarity then
                    first_rarity = r
                elseif first_rarity ~= r then
                    same_rarity = false
                    break
                end
            end
            
            if same_rarity and #G.jokers.cards > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 30. Singularidade Reversa
SMODS.Joker({
    key = 'j_singularity_reverse_singularity',
    atlas = 'j_singularity_reverse_singularity',
    config = { extra = { xmult_reduction = 0.8 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local joker_count = G.jokers and #G.jokers.cards or 0
        local total_xmult = ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_reduction ^ joker_count
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_reduction, joker_count, total_xmult } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local joker_count = #G.jokers.cards
            local total_xmult = card.ability.extra.xmult_reduction ^ joker_count
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { total_xmult } },
                Xmult_mod = total_xmult,
                colour = G.C.MULT
            }
        end
    end
})



-- ============================================
-- SINGULARITY - Rare (Jokers 31-38)
-- ============================================

-- 31. Buraco Negro
SMODS.Joker({
    key = 'j_singularity_black_hole',
    atlas = 'j_singularity_black_hole',
    config = { extra = { mult = 0, gain = 10, last_ante = 0 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card and G.GAME.blind.boss then
            local targets = {}
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] ~= card and not G.jokers.cards[i].ability.eternal then
                    table.insert(targets, G.jokers.cards[i])
                end
            end
            
            if #targets > 0 then
                local target = pseudorandom_element(targets, pseudoseed('black_hole'))
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
                target:start_dissolve()
                return {
                    message = 'Absorvido!',
                    colour = G.C.MULT
                }
            end
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 32. Singularidade Absoluta
SMODS.Joker({
    key = 'j_singularity_absolute_singularity',
    atlas = 'j_singularity_absolute_singularity',
    config = { extra = { xmult = 10 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local legendary_count = 0
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i].config.center.rarity == 4 then
                    legendary_count = legendary_count + 1
                end
            end
            
            if legendary_count == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 33. Ponto de Não Retorno
SMODS.Joker({
    key = 'j_singularity_point_of_no_return',
    atlas = 'j_singularity_point_of_no_return',
    config = { extra = { xmult = 1, gain_per_destroyed = 5 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 15,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult, extra.gain_per_destroyed } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        if G.jokers and not from_debuff then
            local count = 0
            for i = #G.jokers.cards, 1, -1 do
                if G.jokers.cards[i] ~= card then
                    G.jokers.cards[i]:start_dissolve()
                    count = count + 1
                end
            end
            card.ability.extra.xmult = 1 + (count * card.ability.extra.gain_per_destroyed)
        end
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and card.ability.extra.xmult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 34. Colapso Estelar
SMODS.Joker({
    key = 'j_singularity_stellar_collapse',
    atlas = 'j_singularity_stellar_collapse',
    config = { extra = { } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        return { vars = { } }
    end,
    
    calculate = function(self, card, context)
        if context.selling_card and context.card.ability.set == 'Joker' and context.card ~= card then
            if #G.consumeables.cards < G.consumeables.config.card_limit then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, nil, 'collapse')
                        _card:add_to_deck()
                        G.consumeables:emplace(_card)
                        return true
                    end
                }))
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = 'Spectral!', colour = G.C.SECONDARY_SET.Spectral })
            end
        end
    end
})

-- 35. Singularidade Temporal
SMODS.Joker({
    key = 'j_singularity_temporal_singularity',
    atlas = 'j_singularity_temporal_singularity',
    config = { extra = { repetitions = 2 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 14,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.repetitions } }

    
    end,
    
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play and #G.jokers.cards == 1 then
            return {
                message = localize('k_again_ex'),
                repetitions = card.ability.extra.repetitions,
                card = card
            }
        end
    end
})

-- 36. Vácuo Perfeito
SMODS.Joker({
    key = 'j_singularity_perfect_vacuum',
    atlas = 'j_singularity_perfect_vacuum',
    config = { extra = { chips = 100 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play and #G.jokers.cards == 1 then
            return {
                chips = card.ability.extra.chips,
                card = card
            }
        end
    end
})

-- 37. Singularidade Inversa
SMODS.Joker({
    key = 'j_singularity_inverse_singularity',
    atlas = 'j_singularity_inverse_singularity',
    config = { extra = { xmult = 3 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.chips < G.GAME.blind.chips then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 38. Ponto Ômega
SMODS.Joker({
    key = 'j_singularity_omega_point',
    atlas = 'j_singularity_omega_point',
    config = { extra = { xmult_base = 1, gain = 0.5 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 14,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local current_xmult = 1 + (G.GAME.hands_played * ( (card and card.ability and card.ability.extra) or self.config.extra ).gain)
        return { vars = { current_xmult } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and #G.jokers.cards == 1 then
            local current_xmult = 1 + (G.GAME.hands_played * card.ability.extra.gain)
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { current_xmult } },
                Xmult_mod = current_xmult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- SINGULARITY - Legendary (Jokers 39-40)
-- ============================================

-- 39. Singularidade Primordial
SMODS.Joker({
    key = 'j_singularity_primordial',
    atlas = 'j_singularity_primordial',
    config = { extra = { xmult = 25 } },
    rarity = 4,
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if #G.jokers.cards == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 40. Big Bang Reverso
SMODS.Joker({
    key = 'j_singularity_reverse_big_bang',
    atlas = 'j_singularity_reverse_big_bang',
    config = { extra = { xmult = 10 } },
    rarity = 4,
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})



-- ============================================
-- QUANTUM - Common (Jokers 41-56)
-- ============================================

-- 41. Superposição
SMODS.Joker({
    key = 'j_quantum_superposition',
    config = { extra = { mult = 10, chips = 40 } },
    atlas = 'j_quantum_superposition',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('superposition') < 0.5 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- 42. Flutuação Quântica
SMODS.Joker({
    key = 'j_quantum_quantum_fluctuation',
    atlas = 'j_quantum_quantum_fluctuation',
    config = { extra = { mult = 15, min = 5, max = 25 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.min, extra.max } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.mult = math.floor(pseudorandom('fluctuation') * (card.ability.extra.max - card.ability.extra.min + 1) + card.ability.extra.min)
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_val_up'), colour = G.C.MULT })
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 43. Incerteza
SMODS.Joker({
    key = 'j_quantum_uncertainty',
    atlas = 'j_quantum_uncertainty',
    config = { extra = { mult = 50, money = 5, odds = 4 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('uncertainty') < G.GAME.probabilities.normal / card.ability.extra.odds then
                local outcome = math.floor(pseudorandom('uncertainty_outcome') * 3) + 1
                if outcome == 1 then
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                        mult_mod = card.ability.extra.mult,
                        colour = G.C.MULT
                    }
                elseif outcome == 2 then
                    ease_dollars(card.ability.extra.money)
                    return {
                        message = localize('$') .. card.ability.extra.money,
                        colour = G.C.MONEY
                    }
                else
                    G.GAME.current_round.free_rerolls = (G.GAME.current_round.free_rerolls or 0) + 1
                    return {
                        message = localize('k_plus_reroll'),
                        colour = G.C.GREEN
                    }
                end
            end
        end
    end
})

-- 44. Dualidade
SMODS.Joker({
    key = 'j_quantum_duality',
    atlas = 'j_quantum_duality',
    config = { extra = { mult = 15, chips = 50 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                chip_mod = card.ability.extra.chips,
                colour = G.C.MULT
            }
        end
    end
})

-- 45. Emaranhamento
SMODS.Joker({
    key = 'j_quantum_entanglement',
    atlas = 'j_quantum_entanglement',
    config = { extra = { mult = 15 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local bonus = 0
            -- Check joker to the right
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card and G.jokers.cards[i+1] then
                    local right_joker = G.jokers.cards[i+1]
                    if right_joker.ability.extra and type(right_joker.ability.extra) == 'table' then
                        -- Average all numeric values in extra
                        local sum, count = 0, 0
                        for _, v in pairs(right_joker.ability.extra) do
                            if type(v) == 'number' then
                                sum = sum + v
                                count = count + 1
                            end
                        end
                        if count > 0 then bonus = math.floor(sum / count) end
                    elseif type(right_joker.ability.extra) == 'number' then
                        bonus = right_joker.ability.extra
                    end
                end
            end
            
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult + bonus } },
                mult_mod = card.ability.extra.mult + bonus,
                colour = G.C.MULT
            }
        end
    end
})

-- 46. Salto Quântico
SMODS.Joker({
    key = 'j_quantum_quantum_leap',
    atlas = 'j_quantum_quantum_leap',
    config = { extra = { mult = 15, odyssey_debuff_adj = true } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 47. Probabilidade
SMODS.Joker({
    key = 'j_quantum_probability',
    atlas = 'j_quantum_probability',
    config = { extra = { mult_per_common = 5 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.jokers then
            for _, v in ipairs(G.jokers.cards) do
                if v.config.center.rarity == 1 then count = count + 1 end
            end
        end
        return { vars = { count * card.ability.extra.mult_per_common } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for _, v in ipairs(G.jokers.cards) do
                if v.config.center.rarity == 1 then count = count + 1 end
            end
            local tot = count * card.ability.extra.mult_per_common
            if tot > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { tot } },
                    mult_mod = tot,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 48. Gato de Schrödinger
SMODS.Joker({
    key = 'j_quantum_schrodinger',
    atlas = 'j_quantum_schrodinger',
    config = { extra = { mult = 25, chips = 100, money = 5, odds = 4 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.chips, extra.money, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            ease_dollars(card.ability.extra.money)
            return {
                message = 'Superposto!',
                mult_mod = card.ability.extra.mult,
                chip_mod = card.ability.extra.chips,
                colour = G.C.MULT
            }
        end
        
        if context.after and not context.blueprint and not context.repetition then
            if pseudorandom('schrodinger') < G.GAME.probabilities.normal / card.ability.extra.odds then
                if not card.ability.eternal then 
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            card:start_dissolve()
                            return true
                        end
                    }))
                end
                return {
                    message = 'Colapsou!',
                    colour = G.C.FILTER
                }
            end
        end
    end
})

-- 49. Colapso de Onda
SMODS.Joker({
    key = 'j_quantum_wave_collapse',
    atlas = 'j_quantum_wave_collapse',
    config = { extra = { mult = 20, chips = 100, money = 5, mode = 1 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.chips, extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.mode = (card.ability.extra.mode % 3) + 1
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_val_up'), colour = G.C.FILTER })
        end
        
        if context.joker_main then
            if card.ability.extra.mode == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            elseif card.ability.extra.mode == 2 then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            else
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 50. Tunelamento
SMODS.Joker({
    key = 'j_quantum_tunneling',
    atlas = 'j_quantum_tunneling',
    config = { extra = { mult = 15, odds = 20 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint and not context.repetition then
            if pseudorandom('tunneling') < G.GAME.probabilities.normal / card.ability.extra.odds then
                ease_discard(1)
                return {
                    message = localize('k_plus_discard'),
                    colour = G.C.BLUE
                }
            end
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 51. Estado Quântico
SMODS.Joker({
    key = 'j_quantum_quantum_state',
    atlas = 'j_quantum_quantum_state',
    config = { extra = { mult = 15, x_mult = 1.5, mode = 1 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.x_mult, extra.mode } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            card.ability.extra.mode = (card.ability.extra.mode % 2) + 1
            if card.ability.extra.mode == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 52. Observador
SMODS.Joker({
    key = 'j_quantum_observer',
    atlas = 'j_quantum_observer',
    config = { extra = { x_mult = 2, active = true } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.active = true
        end
        
        if context.joker_main and card.ability.extra.active then
            card.ability.extra.active = false
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 53. Antimatéria
SMODS.Joker({
    key = 'j_quantum_antimatter',
    atlas = 'j_quantum_antimatter',
    config = { extra = { mult = 0, gain = 10 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint and not context.repetition then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 54. Entrelaçado
SMODS.Joker({
    key = 'j_quantum_entangled',
    atlas = 'j_quantum_entangled',
    config = { extra = { x_mult = 2.5 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for _, v in ipairs(G.jokers.cards) do
                if v.config.center.key == card.config.center.key then count = count + 1 end
            end
            
            if count >= 2 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 55. Spin Quântico
SMODS.Joker({
    key = 'j_quantum_quantum_spin',
    atlas = 'j_quantum_quantum_spin',
    config = { extra = { mult = 30, odds = 3 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('spin') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 56. Partícula Virtual
SMODS.Joker({
    key = 'j_quantum_virtual_particle',
    atlas = 'j_quantum_virtual_particle',
    config = { extra = { x_mult = 3, rounds = 3 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = false,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.rounds, extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.rounds = card.ability.extra.rounds - 1
            if card.ability.extra.rounds <= 0 then
                if not card.ability.eternal then card:start_dissolve() end
            else
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = card.ability.extra.rounds .. '', colour = G.C.FILTER })
            end
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- QUANTUM - Uncommon (Jokers 57-70)
-- ============================================

-- 57. Campo Quântico
SMODS.Joker({
    key = 'j_quantum_quantum_field',
    atlas = 'j_quantum_quantum_field',
    config = { extra = { mult_bonus = 20 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_bonus } }

    
    end,
    
    calculate = function(self, card, context)
        if context.other_joker and context.other_joker ~= card then
            -- Verifica se é adjacente
            local my_index = nil
            local other_index = nil
            
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then my_index = i end
                if G.jokers.cards[i] == context.other_joker then other_index = i end
            end
            
            if my_index and other_index and math.abs(my_index - other_index) == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult_bonus } },
                    mult_mod = card.ability.extra.mult_bonus,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 58. Decaimento
SMODS.Joker({
    key = 'j_quantum_decay',
    atlas = 'j_quantum_decay',
    config = { extra = { x_mult = 4, decay = 0.2 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.decay } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.x_mult = math.max(1, card.ability.extra.x_mult - card.ability.extra.decay)
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }, colour = G.C.MULT })
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 59. Fissão
SMODS.Joker({
    key = 'j_quantum_fission',
    atlas = 'j_quantum_fission',
    config = { extra = { mult = 30 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 60. Fusão
SMODS.Joker({
    key = 'j_quantum_fusion',
    atlas = 'j_quantum_fusion',
    config = { extra = { x_mult = 1, x_mult_gain = 1.5 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.x_mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local absorbed = false
            for i = #G.jokers.cards, 1, -1 do
                local other = G.jokers.cards[i]
                if other and other ~= card and other.config.center.key == card.config.center.key and not other.ability.eternal then
                    other:start_dissolve()
                    card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
                    absorbed = true
                end
            end
            if absorbed then
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_upgrade_ex'), colour = G.C.MULT })
            end
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 62. Déjà Vu
SMODS.Joker({
    key = 'j_quantum_deja_vu',
    atlas = 'j_quantum_deja_vu',
    config = { extra = { x_mult = 2.5 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.last_hand_played == context.scoring_name then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 63. Loop Infinito
SMODS.Joker({
    key = 'j_quantum_infinite_loop',
    atlas = 'j_quantum_infinite_loop',
    config = { extra = { mult = 30, count = 0, trigger = 3 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.played, extra.trigger } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint and not context.repetition then
            card.ability.extra.played = (card.ability.extra.played % card.ability.extra.trigger) + 1
        end
        
        -- Se estiver no gatilho, repete todas as cartas
        if context.repetition and context.cardarea == G.play then
            if card.ability.extra.played == card.ability.extra.trigger then
                return {
                    message = 'Loop!',
                    repetitions = 1,
                    card = card
                }
            end
        end
        
        if context.joker_main then
            if card.ability.extra.played == card.ability.extra.trigger then
                return {
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 64. Rewind
SMODS.Joker({
    key = 'j_quantum_rewind',
    atlas = 'j_quantum_rewind',
    config = { extra = { } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        return { vars = { } }
    end,
    
    calculate = function(self, card, context)
        -- Reativa cartas jogadas na mão
        if context.repetition and context.cardarea == G.play then
            return {
                message = 'Rewind!',
                repetitions = 1,
                card = card
            }
        end
    end
})

-- 65. Aceleração Temporal
SMODS.Joker({
    key = 'j_quantum_time_acceleration',
    atlas = 'j_quantum_time_acceleration',
    config = { extra = { x_mult = 1, x_mult_gain = 0.1 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.x_mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint and not context.repetition then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 66. Âncora Temporal
SMODS.Joker({
    key = 'j_quantum_time_anchor',
    atlas = 'j_quantum_time_anchor',
    config = { extra = { x_mult = 3, fixed_money = 15 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 15,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.fixed_money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local diff = card.ability.extra.fixed_money - G.GAME.dollars
            ease_dollars(diff)
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 67. Chrono Trigger
SMODS.Joker({
    key = 'j_quantum_chrono_trigger',
    atlas = 'j_quantum_chrono_trigger',
    config = { extra = { mult = 100, played = 0, trigger = 5 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.played, extra.trigger, extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint and not context.repetition then
            card.ability.extra.played = card.ability.extra.played + 1
        end
        
        if context.joker_main then
            if card.ability.extra.played >= card.ability.extra.trigger then
                card.ability.extra.played = 0
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 68. Entropia
SMODS.Joker({
    key = 'j_quantum_entropy',
    atlas = 'j_quantum_entropy',
    config = { extra = { mult = 25, x_mult = 1.5, chips = 50 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.x_mult, extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local effect = math.floor(pseudorandom('entropy') * 3) + 1
            if effect == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            elseif effect == 2 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- 69. Viajante do Tempo
SMODS.Joker({
    key = 'j_quantum_time_traveler',
    atlas = 'j_quantum_time_traveler',
    config = { extra = { mult = 40 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 70. Teleportador
SMODS.Joker({
    key = 'j_quantum_slow_motion',
    atlas = 'j_quantum_slow_motion',
    config = { extra = { x_mult = 2, discards = 1 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.discards } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards
        ease_discard(card.ability.extra.discards)
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards
        ease_discard(-card.ability.extra.discards)
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- ============================================
-- QUANTUM - Rare (Jokers 71-78)
-- ============================================

-- 71. Portal Dimensional
SMODS.Joker({
    key = 'j_quantum_dimensional_portal',
    atlas = 'j_quantum_dimensional_portal',
    config = { extra = { mult = 40, odds = 10 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local normal_prob = G.GAME and G.GAME.probabilities and G.GAME.probabilities.normal or 1
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult, '' .. normal_prob, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } }
    end,
    
    calculate = function(self, card, context)
        -- Chance to change suit after playing hand
        if context.after and not context.blueprint then
            if pseudorandom('portal_dimensional') < G.GAME.probabilities.normal / card.ability.extra.odds then
                -- Pick a random card from hand (remaining cards)
                if G.hand and G.hand.cards and #G.hand.cards > 0 then
                    local target_card = pseudorandom_element(G.hand.cards, pseudoseed('portal_card'))
                    
                    local suits = {'Hearts', 'Diamonds', 'Clubs', 'Spades'}
                    local current_suit = target_card.base.suit
                    local new_suit = pseudorandom_element(suits, pseudoseed('portal_suit'))
                    
                    -- Ensure suit changed
                    while new_suit == current_suit and #suits > 1 do
                        new_suit = pseudorandom_element(suits, pseudoseed('portal_suit'))
                    end
                    
                    target_card:set_base(G.P_CARDS[new_suit..'_'..target_card.base.value])
                    
                    card_eval_status_text(card, 'extra', nil, nil, nil, {
                        message = 'Portal!',
                        colour = G.C.PURPLE
                    })
                end
            end
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 72. Espelho
SMODS.Joker({
    key = 'j_quantum_mirror',
    atlas = 'j_quantum_mirror',
    config = { extra = { mult = 50, is_reflection = false } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        if not from_debuff and not card.ability.extra.is_reflection and not G.CONTROLLER.loading and #G.jokers.cards < G.jokers.config.card_limit then
            local copy = create_card('Joker', G.jokers, nil, nil, nil, nil, 'j_quantum_mirror')
            copy.ability.extra.mult = math.floor(card.ability.extra.mult / 2)
            copy.ability.extra.is_reflection = true
            copy:add_to_deck()
            G.jokers:emplace(copy)
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = 'Refletido!', colour = G.C.MULT })
        end
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 73. Yin Yang
SMODS.Joker({
    key = 'j_quantum_yin_yang',
    atlas = 'j_quantum_yin_yang',
    config = { extra = { mult = 80, chips = 150, is_mult = true } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.is_mult and 'Mult' or 'Fichas', extra.mult, extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.is_mult = not card.ability.extra.is_mult
            card_eval_status_text(card, 'extra', nil, nil, nil, { 
                message = card.ability.extra.is_mult and 'Mult!' or 'Fichas!', 
                colour = card.ability.extra.is_mult and G.C.MULT or G.C.CHIPS 
            })
        end
        
        if context.joker_main then
            if card.ability.extra.is_mult then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- 74. Dimensão Paralela
SMODS.Joker({
    key = 'j_quantum_parallel_dimension',
    atlas = 'j_quantum_parallel_dimension',
    config = { extra = { x_mult = 2.5 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        -- Condition: Hand must have exactly 2 or 4 cards (Parallel)
        if context.joker_main then
            if context.scoring_hand and (#context.scoring_hand == 2 or #context.scoring_hand == 4) then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 75. Dobra Espacial
SMODS.Joker({
    key = 'j_quantum_spatial_fold',
    atlas = 'j_quantum_spatial_fold',
    config = { extra = { mult = 50 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        -- Libera +1 slot (adjacentes compartilham espaço)
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit + 1
        end
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        -- Remove o slot extra
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit - 1
        end
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 76. Wormhole
SMODS.Joker({
    key = 'j_quantum_wormhole',
    atlas = 'j_quantum_wormhole',
    config = { extra = { x_mult = 2.5, chance = 4 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local normal_prob = G.GAME and G.GAME.probabilities and G.GAME.probabilities.normal or 1
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult, '' .. normal_prob, ( (card and card.ability and card.ability.extra) or self.config.extra ).chance } }
    end,
    
    calculate = function(self, card, context)
        -- Behavior: X2.5 Mult and chance to re-trigger hand cards
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.repetition and context.cardarea == G.play then
            if pseudorandom('wormhole') < G.GAME.probabilities.normal / card.ability.extra.chance then
                return {
                    message = 'Tunnel!',
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- 77. Tesseract
SMODS.Joker({
    key = 'j_quantum_tesseract',
    atlas = 'j_quantum_tesseract',
    config = { extra = { mult_per = 20 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_per } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            local unique_suits = 0
            
            if context.scoring_hand then
                for _, v in ipairs(context.scoring_hand) do
                    if not suits[v.base.suit] then
                        suits[v.base.suit] = true
                        unique_suits = unique_suits + 1
                    end
                end
            end
            
            local mult = unique_suits * card.ability.extra.mult_per
            
            if mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                    mult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 78. Klein Bottle
SMODS.Joker({
    key = 'j_quantum_klein_bottle',
    atlas = 'j_quantum_klein_bottle',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        -- Marca que a inversão está ativa
        if not G.GAME.odyssey_klein_bottle_active then
            G.GAME.odyssey_klein_bottle_active = (G.GAME.odyssey_klein_bottle_active or 0) + 1
            -- Inverte a ordem dos Jokers visualmente e logicamente
            if G.jokers and G.jokers.cards then
                local reversed = {}
                for i = #G.jokers.cards, 1, -1 do
                    table.insert(reversed, G.jokers.cards[i])
                end
                G.jokers.cards = reversed
                -- Atualiza visualmente as posições
                for i = 1, #G.jokers.cards do
                    G.jokers.cards[i].T.x = G.jokers.T.x + (i-1)*G.CARD_W*1.1
                end
            end
        end
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        -- Remove a inversão quando vendido/removido
        if G.GAME.odyssey_klein_bottle_active then
            G.GAME.odyssey_klein_bottle_active = (G.GAME.odyssey_klein_bottle_active or 0) - 1
            -- Desinverte a ordem dos Jokers (inverte novamente)
            if G.jokers and G.jokers.cards then
                local reversed = {}
                for i = #G.jokers.cards, 1, -1 do
                    table.insert(reversed, G.jokers.cards[i])
                end
                G.jokers.cards = reversed
                for i = 1, #G.jokers.cards do
                    G.jokers.cards[i].T.x = G.jokers.T.x + (i-1)*G.CARD_W*1.1
                end
            end
        end
    end,
    
    calculate = function(self, card, context)
        -- Condition: X3 Mult if this Joker is at either end of the Joker lineup
        if context.joker_main then
            local is_at_end = (G.jokers and G.jokers.cards and (G.jokers.cards[1] == card or G.jokers.cards[#G.jokers.cards] == card))
            if is_at_end then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- ============================================
-- QUANTUM - Legendary (Jokers 79-80)
-- ============================================

-- 79. Planos Superiores
SMODS.Joker({
    key = 'j_quantum_higher_planes',
    atlas = 'j_quantum_higher_planes',
    config = { extra = { x_mult = 3, odds = 2 } },
    rarity = 4,
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local normal_prob = G.GAME and G.GAME.probabilities and G.GAME.probabilities.normal or 1
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult, '' .. normal_prob, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('higher_planes') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            else
                -- The other state: +100 Mult
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { 100 } },
                    mult_mod = 100,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 80. Hiperespaço
SMODS.Joker({
    key = 'j_quantum_hyperspace',
    atlas = 'j_quantum_hyperspace',
    config = { extra = { x_mult = 10 } },
    rarity = 4,
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- TEMPORAL - Common (Jokers 81-96)
-- ============================================

-- 81. Bifurcação
SMODS.Joker({
    key = 'j_temporal_bifurcation',
    config = { extra = { x_mult = 1.5 } },
    atlas = 'j_temporal_bifurcation',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 82. Sobreposição
SMODS.Joker({
    key = 'j_temporal_overlap',
    config = { extra = { mult = 20 } },
    atlas = 'j_temporal_overlap',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 83. Camadas
SMODS.Joker({
    key = 'j_temporal_layers',
    config = { extra = { x_mult = 1.5 } },
    atlas = 'j_temporal_layers',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 84. Planolândia
SMODS.Joker({
    key = 'j_temporal_flatland',
    config = { extra = { mult_per = 4 } },
    atlas = 'j_temporal_flatland',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local hand_cards = 0
        if G.hand and G.hand.cards then
            hand_cards = #G.hand.cards
        end
        return { vars = { hand_cards * card.ability.extra.mult_per, card.ability.extra.mult_per } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local hand_cards = 0
            if G.hand and G.hand.cards then
                hand_cards = #G.hand.cards
            end
            
            local mult = hand_cards * card.ability.extra.mult_per
            
            if mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                    mult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 85. Vazio Entre Mundos
SMODS.Joker({
    key = 'j_temporal_void_between_worlds',
    config = { extra = { mult_per = 10 } },
    atlas = 'j_temporal_void_between_worlds',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        if G and G.jokers and G.jokers.config and G.jokers.cards then
            local empty_slots = G.jokers.config.card_limit - #G.jokers.cards
            return { vars = { empty_slots * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per, ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per } }
        end
        return { vars = { 0, card.ability.extra.mult_per } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G and G.jokers and G.jokers.config and G.jokers.cards then
                local empty_slots = G.jokers.config.card_limit - #G.jokers.cards
                local total_mult = empty_slots * card.ability.extra.mult_per
                if total_mult > 0 then
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { total_mult } },
                        mult_mod = total_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    end
})

-- 86. Dimensão Extra
SMODS.Joker({
    key = 'j_temporal_extra_dimension',
    config = { extra = { mult = 10 } },
    atlas = 'j_temporal_extra_dimension',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit + 1
        end
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit - 1
        end
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 87. Multiverso
SMODS.Joker({
    key = 'j_temporal_multiverse',
    config = { extra = { x_mult = 1.5 } },
    atlas = 'j_temporal_multiverse',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 88. Fenda
SMODS.Joker({
    key = 'j_temporal_rift',
    config = { extra = { mult = 50 } },
    atlas = 'j_rift',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        return nil
    end
})

-- 89. Board Circular
SMODS.Joker({
    key = 'j_temporal_circular_board',
    config = { extra = { x_mult = 1.5 } },
    atlas = 'j_temporal_circular_board',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 90. Reino das Sombras
SMODS.Joker({
    key = 'j_temporal_shadow_realm',
    config = { extra = { mult_per = 5, shadow_cards = 0 } },
    atlas = 'j_temporal_shadow_realm',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.shadow_cards, extra.mult_per } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            card.ability.extra.shadow_cards = card.ability.extra.shadow_cards + 1
        end
        
        if context.joker_main and card.ability.extra.shadow_cards > 0 then
            local total_mult = card.ability.extra.shadow_cards * card.ability.extra.mult_per
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { total_mult } },
                mult_mod = total_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 91. Nexus Dimensional
SMODS.Joker({
    key = 'j_temporal_dimensional_nexus',
    config = { extra = { x_mult = 2 } },
    atlas = 'j_temporal_dimensional_nexus',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 92. Dimensão de Bolso
SMODS.Joker({
    key = 'j_temporal_pocket_dimension',
    config = { extra = { mult_per = 10, stored_cards = 0 } },
    atlas = 'j_temporal_pocket_dimension',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.stored_cards * extra.mult_per, extra.mult_per } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            card.ability.extra.stored_cards = card.ability.extra.stored_cards + 1
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = 'Guardado!', colour = G.C.PURPLE })
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.stored_cards = 0
        end
        
        if context.joker_main then
            local total_mult = card.ability.extra.stored_cards * card.ability.extra.mult_per
            if total_mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { total_mult } },
                    mult_mod = total_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 93. Mudança de Fase
SMODS.Joker({
    key = 'j_temporal_phase_shift',
    config = { extra = { x_mult = 2, active = true } },
    atlas = 'j_temporal_phase_shift',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.active and localize('k_active_ex') or localize('k_inactive_ex') } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and card.ability.extra.active then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.after and not context.blueprint then
            card.ability.extra.active = not card.ability.extra.active
            local status = card.ability.extra.active and 'Sólido!' or 'Fantasma!'
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = status, colour = G.C.FILTER })
        end
    end
})

-- 94. Espaço Negativo
SMODS.Joker({
    key = 'j_temporal_negative_space',
    config = { extra = { mult = 15 } },
    atlas = 'j_temporal_negative_space',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 95. Plano Astral
SMODS.Joker({
    key = 'j_temporal_astral_plane',
    config = { extra = { x_mult = 2 } },
    atlas = 'j_temporal_astral_plane',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 96. Convergência
SMODS.Joker({
    key = 'j_temporal_convergence',
    config = { extra = { x_mult = 2.5 } },
    atlas = 'j_temporal_convergence',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- ============================================
-- TEMPORAL - Uncommon (Jokers 97-110)
-- ============================================

-- 97. Limbo
SMODS.Joker({
    key = 'j_temporal_limbo',
    config = { extra = { x_mult = 3, odds = 2 } },
    rarity = 2,
    atlas = 'j_temporal_limbo',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, (G.GAME.probabilities.normal or 1), extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('limbo') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = 'Limbo...',
                    colour = G.C.UI.TEXT_INACTIVE
                }
            end
        end
    end
})

-- 98. Subspace
SMODS.Joker({
    key = 'j_temporal_subspace',
    config = { extra = { mult = 40 } },
    rarity = 2,
    atlas = 'j_temporal_subspace',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 99. Realidade Fraturada
SMODS.Joker({
    key = 'j_temporal_fractured_reality',
    config = { extra = { min_x_mult = 1, max_x_mult = 5 } },
    rarity = 2,
    atlas = 'j_temporal_fractured_reality',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.min_x_mult, extra.max_x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local range = card.ability.extra.max_x_mult - card.ability.extra.min_x_mult
            local x_mult = (pseudorandom('realidade_fraturada') * range) + card.ability.extra.min_x_mult
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { x_mult } },
                Xmult_mod = x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 100. Omniverso
SMODS.Joker({
    key = 'j_temporal_omniverse',
    config = { extra = { x_mult_per = 0.1 } },
    rarity = 2,
    atlas = 'j_temporal_omniverse',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.GAME and G.GAME.hands then
            for k, v in pairs(G.GAME.hands) do
                if v.played > 0 then count = count + 1 end
            end
        end
        local current_x_mult = 1 + (count * card.ability.extra.x_mult_per)
        return { vars = { current_x_mult, card.ability.extra.x_mult_per, count } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.GAME and G.GAME.hands then
                for k, v in pairs(G.GAME.hands) do
                    if v.played > 0 then count = count + 1 end
                end
            end
            local total_x_mult = 1 + (count * card.ability.extra.x_mult_per)
            if total_x_mult > 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { total_x_mult } },
                    Xmult_mod = total_x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 101. Relógio Cósmico
SMODS.Joker({
    key = 'j_temporal_cosmic_clock',
    config = { extra = { rounds = 0, req_rounds = 3, x_mult = 1, x_mult_gain = 0.5 } },
    rarity = 2,
    atlas = 'j_temporal_cosmic_clock',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.rounds, extra.x_mult, extra.req_rounds, extra.x_mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.rounds = card.ability.extra.rounds + 1
            if card.ability.extra.rounds >= card.ability.extra.req_rounds then
                card.ability.extra.rounds = 0
                card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 102. Eco Temporal
SMODS.Joker({
    key = 'j_temporal_time_echo',
    config = { extra = { mult_per = 3 } },
    rarity = 2,
    atlas = 'j_temporal_time_echo',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_per } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local unused_discards = G.GAME.current_round.discards_left or 0
            if unused_discards > 0 then
                local bonus = unused_discards * card.ability.extra.mult_per
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { bonus } },
                    mult_mod = bonus,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 103. Viajante Temporal 2
SMODS.Joker({
    key = 'j_temporal_traveler_2',
    config = { extra = { first_hand_mult = 0, first_hand_chips = 0, hands_played = 0 } },
    rarity = 2,
    atlas = 'j_temporal_traveler_2',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        return { vars = {} }
    end,
    
    calculate = function(self, card, context)
        -- Incrementa contador
        if context.before and not context.blueprint then
            card.ability.extra.hands_played = (card.ability.extra.hands_played or 0) + 1
        end
        
        -- Primeira mão: captura valores atuais (Base + Cartas)
        if context.joker_main and card.ability.extra.hands_played == 1 then
            card.ability.extra.first_hand_mult = (G.mult or 1)
            card.ability.extra.first_hand_chips = (G.hand_chips or 0)
        end
        
        -- Última mão: repete o bônus
        if context.joker_main and G.GAME.current_round.hands_left == 0 then
            local bonus_mult = card.ability.extra.first_hand_mult
            local bonus_chips = card.ability.extra.first_hand_chips
            
            if bonus_mult > 0 or bonus_chips > 0 then
                return {
                    message = 'Eco!',
                    mult_mod = bonus_mult > 0 and bonus_mult or nil,
                    chip_mod = bonus_chips > 0 and bonus_chips or nil,
                    colour = G.C.PURPLE
                }
            end
        end
        
        -- Reset no fim da rodada
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.hands_played = 0
            card.ability.extra.first_hand_mult = 0
            card.ability.extra.first_hand_chips = 0
        end
    end
})

-- 104. Paradoxo
SMODS.Joker({
    key = 'j_temporal_paradox',
    config = { extra = { odds = 4 } },
    rarity = 2,
    atlas = 'j_temporal_paradox',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { G.GAME.probabilities.normal or 1, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            if pseudorandom('viajante_temporal') < G.GAME.probabilities.normal / card.ability.extra.odds then
                if pseudorandom('viajante_temporal_2') < 0.5 then
                    ease_hands_played(1)
                    card_eval_status_text(card, 'extra', nil, nil, nil, { message = '+1 Mão!', colour = G.C.BLUE })
                else
                    ease_discard(1)
                    card_eval_status_text(card, 'extra', nil, nil, nil, { message = '+1 Descarte!', colour = G.C.RED })
                end
            end
        end
    end
})

-- 105. Linha Temporal Alternativa
SMODS.Joker({
    key = 'j_temporal_alternate_timeline',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_temporal_alternate_timeline',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            if G.GAME.current_round.hands_left > 1 then
                ease_hands_played(-1)
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = '-1 Mão', colour = G.C.RED })
            end
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 106. Estase
SMODS.Joker({
    key = 'j_temporal_stasis',
    config = { extra = { odds = 10, bonus_next_round = false } },
    rarity = 2,
    atlas = 'j_temporal_stasis',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { G.GAME.probabilities.normal or 1, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.blind and G.GAME.blind.chips_left and G.GAME.blind.chips_left <= 0 then
                if pseudorandom('stasis') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    card.ability.extra.bonus_next_round = true
                    card_eval_status_text(card, 'extra', nil, nil, nil, { message = 'Estase!', colour = G.C.PURPLE })
                end
            end
        end
        
        if context.setting_blind and not context.blueprint then
            if card.ability.extra.bonus_next_round then
                card.ability.extra.bonus_next_round = false
                ease_hands_played(1)
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = '+1 Mão!', colour = G.C.BLUE })
            end
        end
    end
})

-- 107. Momento Congelado
SMODS.Joker({
    key = 'j_temporal_frozen_moment',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_temporal_frozen_moment',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_hand then
            local ranks = {}
            for i = 1, #context.scoring_hand do
                local rank = context.scoring_hand[i].base.value
                ranks[rank] = (ranks[rank] or 0) + 1
            end
            
            for rank, count in pairs(ranks) do
                if count >= 2 then
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                        mult_mod = card.ability.extra.mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    end
})

-- 108. Futuro Incerto
SMODS.Joker({
    key = 'j_temporal_uncertain_future',
    config = { extra = { stored_mult = 0, stored_chips = 0, hands_played = 0, x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_temporal_uncertain_future',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.hands_played = (card.ability.extra.hands_played or 0) + 1
        end
        
        -- Primeira mão: armazena os valores
        if context.joker_main and card.ability.extra.hands_played == 1 then
            card.ability.extra.stored_mult = (G.mult or 1)
            card.ability.extra.stored_chips = (G.hand_chips or 0)
        end
        
        -- Última mão: aplica XMult e bônus guardado
        if context.joker_main and G.GAME.current_round.hands_left == 0 then
            return {
                message = 'Futuro!',
                mult_mod = card.ability.extra.stored_mult > 0 and card.ability.extra.stored_mult or nil,
                chip_mod = card.ability.extra.stored_chips > 0 and card.ability.extra.stored_chips or nil,
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.PURPLE
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.hands_played = 0
            card.ability.extra.stored_mult = 0
            card.ability.extra.stored_chips = 0
        end
    end
})

-- 109. Cronômetro
SMODS.Joker({
    key = 'j_temporal_chronometer',
    config = { extra = { mult = 0, mult_gain = 2 } },
    rarity = 2,
    atlas = 'j_temporal_chronometer',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT,
                card = card
            }
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 110. Dilatação Temporal
SMODS.Joker({
    key = 'j_temporal_time_dilation',
    config = { extra = { x_mult = 1.5, last_hand = '', is_same = false } },
    rarity = 2,
    atlas = 'j_temporal_time_dilation',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and context.scoring_name then
            local current_hand = context.scoring_name
            card.ability.extra.is_same = (current_hand == card.ability.extra.last_hand)
            card.ability.extra.last_hand = current_hand
        end
        
        if context.joker_main and card.ability.extra.is_same then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- ============================================
-- TEMPORAL - Rare (Jokers 111-118)
-- ============================================

-- 111. Horizonte de Eventos Temporal
SMODS.Joker({
    key = 'j_temporal_event_horizon',
    config = { extra = { min = 5, max = 50 } },
    rarity = 3,
    atlas = 'j_temporal_event_horizon',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.min, extra.max } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local mult = pseudorandom('horizonte') * (card.ability.extra.max - card.ability.extra.min) + card.ability.extra.min
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                mult_mod = mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 112. Rewind Temporal
SMODS.Joker({
    key = 'j_temporal_rewind',
    config = { extra = { mult_per = 10 } },
    rarity = 3,
    atlas = 'j_temporal_rewind',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_per } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local hands_played = G.GAME.current_round.hands_played or 0
            local bonus = hands_played * card.ability.extra.mult_per
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { bonus } },
                mult_mod = bonus,
                colour = G.C.MULT
            }
        end
    end
})

-- 113. Repetição Temporal
SMODS.Joker({
    key = 'j_temporal_repetition',
    config = { extra = { dollars = 3, interval = 5, hands_count = 0 } },
    rarity = 3,
    atlas = 'j_temporal_repetition',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.dollars, extra.interval } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.hands_count = (card.ability.extra.hands_count or 0) + 1
            if card.ability.extra.hands_count >= card.ability.extra.interval then
                card.ability.extra.hands_count = 0
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = '$' .. card.ability.extra.dollars,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 114. Déjà Vu Infinito
SMODS.Joker({
    key = 'j_temporal_infinite_deja_vu',
    config = { extra = { chips = 25 } },
    rarity = 3,
    atlas = 'j_temporal_infinite_deja_vu',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local discards = G.GAME.current_round.discards_left or 0
            local bonus = discards * card.ability.extra.chips
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { bonus } },
                chip_mod = bonus,
                colour = G.C.CHIPS
            }
        end
    end
})

-- 115. Futuro Promissor
SMODS.Joker({
    key = 'j_temporal_promising_future',
    config = { extra = { x_mult = 3, mult = 25, odds = 5 } },
    rarity = 3,
    atlas = 'j_temporal_promising_future',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.odds, extra.x_mult, extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('promising_future') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 116. Presente Eterno
SMODS.Joker({
    key = 'j_temporal_eternal_present',
    config = { extra = { x_mult = 1.5 } },
    rarity = 3,
    atlas = 'j_temporal_eternal_present',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local initial_discards = G.GAME.round_resets.discards or 0
            local current_discards = G.GAME.current_round.discards_left or 0
            if initial_discards == current_discards then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 117. Passado Perdido
SMODS.Joker({
    key = 'j_temporal_forgotten_past',
    config = { extra = { odds = 5 } },
    rarity = 3,
    atlas = 'j_temporal_forgotten_past',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { G.GAME.probabilities.normal or 1, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and context.game_over and not context.repetition and not context.other_card then
            if pseudorandom('forgotten_past') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize('k_saved_ex'),
                    saved = true,
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

-- 118. Crescimento Temporal
SMODS.Joker({
    key = 'j_temporal_growth',
    config = { extra = { mult = 0, mult_gain = 1 } },
    rarity = 3,
    atlas = 'j_temporal_growth',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT,
                card = card
            }
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- TEMPORAL - Legendary (Jokers 119-120)
-- ============================================

-- 119. Mão Dupla
SMODS.Joker({
    key = 'j_temporal_double_hand',
    config = { extra = { first_hand = true, triggered = false } },
    rarity = 4,
    atlas = 'j_temporal_double_hand',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        return { vars = {} }
    end,
    
    calculate = function(self, card, context)
        -- Reset flag at start of blind
        if context.setting_blind and not context.blueprint then
            card.ability.extra.first_hand = true
            card.ability.extra.triggered = false
        end
        
        -- Before playing hand: check if it's first hand
        if context.before and not context.blueprint and card.ability.extra.first_hand and not card.ability.extra.triggered then
            card.ability.extra.triggered = true
            card_eval_status_text(card, 'extra', nil, nil, nil, { 
                message = localize('k_again_ex'), 
                colour = G.C.PURPLE 
            })
        end
        
        -- During play: retrigger all played cards if first hand
        if context.repetition and context.cardarea == G.play then
            if card.ability.extra.first_hand and card.ability.extra.triggered then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = context.other_card
                }
            end
        end
        
        -- After hand: disable first_hand flag
        if context.after and not context.blueprint and card.ability.extra.first_hand then
            card.ability.extra.first_hand = false
        end
    end
})

-- 120. Loop Eterno
SMODS.Joker({
    key = 'j_temporal_eternal_loop',
    config = { extra = { x_mult = 3, count = 0, last_hand = '' } },
    rarity = 4,
    atlas = 'j_temporal_eternal_loop',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.played, extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and context.scoring_name then
            local hand_type = context.scoring_name
            if hand_type == card.ability.extra.last_hand then
                card.ability.extra.played = card.ability.extra.played + 1
            else
                card.ability.extra.played = 1
                card.ability.extra.last_hand = hand_type
            end
        end
        
        if context.joker_main and card.ability.extra.played >= 3 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- DIMENSIONS - Common (Jokers 121-136)
-- ============================================

-- 121. Legado
SMODS.Joker({
    key = 'j_dimensions_legacy',
    config = { extra = { mult_per_joker = 5, jokers_sold = 0 } },
    rarity = 1,
    atlas = 'j_dimensions_legacy',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.jokers_sold * extra.mult_per_joker } }

    
    end,
    
    calculate = function(self, card, context)
        if context.selling_card and not context.blueprint then
            card.ability.extra.jokers_sold = card.ability.extra.jokers_sold + 1
        end
        
        if context.joker_main then
            local mult = card.ability.extra.jokers_sold * card.ability.extra.mult_per_joker
            if mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                    mult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 122. Crescimento Infinito
SMODS.Joker({
    key = 'j_dimensions_infinite_growth',
    config = { extra = { x_mult = 1, x_mult_gain = 0.05 } },
    rarity = 1,
    atlas = 'j_dimensions_infinite_growth',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.x_mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.blind and G.GAME.blind.chips_left and G.GAME.blind.chips_left <= 0 then
                card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 123. Acumulação
SMODS.Joker({
    key = 'j_dimensions_accumulation',
    config = { extra = { mult = 0, cards_played = 0 } },
    rarity = 1,
    atlas = 'j_dimensions_accumulation',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play and not context.blueprint then
            card.ability.extra.cards_played = (card.ability.extra.cards_played or 0) + 1
            if card.ability.extra.cards_played >= 2 then
                card.ability.extra.cards_played = 0
                card.ability.extra.mult = card.ability.extra.mult + 1
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 124. Última Hora
SMODS.Joker({
    key = 'j_dimensions_last_hour',
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    atlas = 'j_dimensions_last_hour',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_left == 0 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 125. Scaling Linear
SMODS.Joker({
    key = 'j_dimensions_linear_scaling',
    config = { extra = { x_mult_per_ante = 0.2 } },
    rarity = 1,
    atlas = 'j_dimensions_linear_scaling',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)
        local antes = G.GAME.round_resets.ante or 1
        local x_mult = 1 + (antes * ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_per_ante)
        return { vars = { x_mult } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local antes = G.GAME.round_resets.ante or 1
            local x_mult = 1 + (antes * card.ability.extra.x_mult_per_ante)
            
            if x_mult > 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { x_mult } },
                    Xmult_mod = x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 126. Momentum
SMODS.Joker({
    key = 'j_dimensions_momentum',
    config = { extra = { mult_gain = 3 } },
    rarity = 1,
    atlas = 'j_dimensions_momentum',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            card.ability.extra.temp_mult = (card.ability.extra.temp_mult or 0) + card.ability.extra.mult_gain
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.temp_mult } },
                mult = card.ability.extra.temp_mult,
                colour = G.C.MULT
            }
        end
        
        if context.after and not context.blueprint then
            card.ability.extra.temp_mult = 0
        end
    end
})

-- 127. Sacrifício
SMODS.Joker({
    key = 'j_dimensions_sacrifice',
    config = { extra = { x_mult = 1, x_mult_gain = 1.5, odds = 10 } },
    rarity = 1,
    atlas = 'j_dimensions_sacrifice',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { G.GAME.probabilities.normal or 1, extra.odds, extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play and not context.blueprint then
            if pseudorandom('sacrifice') < G.GAME.probabilities.normal / card.ability.extra.odds then
                if not context.other_card.ability.eternal then
                    card.ability.extra.x_mult = card.ability.extra.x_mult * card.ability.extra.x_mult_gain
                    if not context.other_card.ability.eternal then context.other_card:start_dissolve() end
                    return {
                        message = 'Sacrificado!',
                        colour = G.C.PURPLE
                    }
                end
            end
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 128. Número da Sorte
SMODS.Joker({
    key = 'j_dimensions_lucky_number',
    config = { extra = { x_mult = 2, req_cards = 4 } },
    rarity = 1,
    atlas = 'j_dimensions_lucky_number',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.req_cards, extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_left == 0 then
            if #G.hand.cards == card.ability.extra.req_cards then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 129. Bonus Aleatório
SMODS.Joker({
    key = 'j_dimensions_random_bonus',
    config = { extra = { money = 2 } },
    rarity = 1,
    atlas = 'j_dimensions_random_bonus',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            if pseudorandom('random_bonus') < 0.15 then
                if pseudorandom('random_bonus_2') < 0.5 then
                    ease_dollars(card.ability.extra.money)
                    return {
                        message = localize('$') .. card.ability.extra.money,
                        colour = G.C.MONEY
                    }
                else
                    ease_discard(1)
                    return {
                        message = '+1',
                        colour = G.C.RED
                    }
                end
            end
        end
    end
})

-- 130. Cumulativo
SMODS.Joker({
    key = 'j_dimensions_cumulative',
    config = { extra = { x_mult = 1, x_mult_gain = 0.1 } },
    rarity = 1,
    atlas = 'j_dimensions_cumulative',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.x_mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.blind and G.GAME.chips >= G.GAME.blind.chips then
                card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 131. Sequência
SMODS.Joker({
    key = 'j_dimensions_streak',
    config = { extra = { mult_per_hand = 10, streak = 0 } },
    rarity = 1,
    atlas = 'j_dimensions_streak',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.streak * extra.mult_per_hand } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.streak = card.ability.extra.streak + 1
        end
        
        if context.discard and not context.blueprint then
            card.ability.extra.streak = 0
        end
        
        if context.joker_main and card.ability.extra.streak > 0 then
            local mult = card.ability.extra.streak * card.ability.extra.mult_per_hand
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                mult_mod = mult,
                colour = G.C.MULT
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.streak = 0
        end
    end
})

-- 132. Queima Rápida
SMODS.Joker({
    key = 'j_dimensions_fast_burn',
    config = { extra = { x_mult = 2, decay = 0.2 } },
    rarity = 1,
    atlas = 'j_dimensions_fast_burn',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.x_mult = math.max(1, card.ability.extra.x_mult - card.ability.extra.decay)
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 133. Tesouro Escondido
SMODS.Joker({
    key = 'j_dimensions_hidden_treasure',
    config = { extra = { money = 5, used_discard = false } },
    rarity = 1,
    atlas = 'j_dimensions_hidden_treasure',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            card.ability.extra.used_discard = true
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            if not card.ability.extra.used_discard then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
            card.ability.extra.used_discard = false
        end
    end
})

-- 134. Primeiras Três
SMODS.Joker({
    key = 'j_dimensions_first_three',
    config = { extra = { mult = 15, hands_played = 0, max_hands = 3 } },
    rarity = 1,
    atlas = 'j_dimensions_first_three',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.max_hands, extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.hands_played = card.ability.extra.hands_played + 1
        end
        
        if context.joker_main and card.ability.extra.hands_played <= card.ability.extra.max_hands then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.hands_played = 0
        end
    end
})

-- 135. Últimas Três
SMODS.Joker({
    key = 'j_dimensions_last_three',
    config = { extra = { mult = 20, max_hands = 3 } },
    rarity = 1,
    atlas = 'j_dimensions_last_three',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.max_hands, extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local hands_left = G.GAME.current_round.hands_left or 0
            if hands_left < card.ability.extra.max_hands then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 136. Melhor Jogada
SMODS.Joker({
    key = 'j_dimensions_best_play',
    config = { extra = { best_mult = 0, best_chips = 0 } },
    rarity = 1,
    atlas = 'j_dimensions_best_play',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,

    loc_vars = function(self, info_queue, card)


        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )


        return { vars = { extra.best_mult, extra.best_chips } }


    end,

    calculate = function(self, card, context)
        if context.after and not context.blueprint then
            local current_mult = G.mult or 1
            local current_chips = G.hand_chips or 0
            
            if current_mult > card.ability.extra.best_mult then
                card.ability.extra.best_mult = current_mult
            end
            if current_chips > card.ability.extra.best_chips then
                card.ability.extra.best_chips = current_chips
            end
        end

        if context.joker_main and G.GAME.current_round.hands_left == 0 then
            if card.ability.extra.best_mult > 0 or card.ability.extra.best_chips > 0 then
                return {
                    message = 'Melhor!',
                    mult_mod = card.ability.extra.best_mult,
                    chip_mod = card.ability.extra.best_chips,
                    colour = G.C.MULT
                }
            end
        end

        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.best_mult = 0
            card.ability.extra.best_chips = 0
        end
    end
})

-- ============================================
-- DIMENSIONS - Uncommon (Jokers 137-150)
-- ============================================

-- 137. Aprendizado
SMODS.Joker({
    key = 'j_dimensions_learning',
    config = { extra = { mult = 0, mult_gain = 5 } },
    rarity = 2,
    atlas = 'j_dimensions_learning',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local hands_played = G.GAME.current_round.hands_played or 0
            local won = G.GAME.blind and G.GAME.blind.chips_left and G.GAME.blind.chips_left <= 0
            
            if hands_played > 1 and won then
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 138. Memória
SMODS.Joker({
    key = 'j_dimensions_memory',
    config = { extra = { mult_per_card = 2, discarded_cards = {} } },
    rarity = 2,
    atlas = 'j_dimensions_memory',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_per_card } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            for i = 1, #context.full_hand do
                local id = context.full_hand[i].unique_val
                card.ability.extra.discarded_cards[id] = true
            end
        end
        
        if context.individual and context.cardarea == G.play then
            local id = context.other_card.unique_val
            if card.ability.extra.discarded_cards[id] then
                return {
                    mult = card.ability.extra.mult_per_card,
                    card = card
                }
            end
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.discarded_cards = {}
        end
    end
})

-- 139. Sorte Grande
SMODS.Joker({
    key = 'j_dimensions_big_luck',
    config = { extra = { odds = 4 } },
    rarity = 2,
    atlas = 'j_dimensions_big_luck',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { G.GAME.probabilities.normal or 1, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.after and not context.blueprint then
             if pseudorandom('big_luck') < G.GAME.probabilities.normal / card.ability.extra.odds then
                ease_hands_played(1)
                return {
                    message = 'Sorte!',
                    colour = G.C.BLUE
                }
             end
        end
    end
})

-- 140. Sinergia Temporal
SMODS.Joker({
    key = 'j_dimensions_temporal_synergy',
    config = { extra = { mult_per_joker = 3 } },
    rarity = 2,
    atlas = 'j_dimensions_temporal_synergy',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.jokers and G.jokers.cards then
            for i = 1, #G.jokers.cards do
                local key = G.jokers.cards[i].config.center.key
                if (string.find(key, 'temporal') or string.find(key, 'relogio') or 
                   string.find(key, 'tempo') or string.find(key, 'paradoxo') or
                   string.find(key, 'futuro') or string.find(key, 'passado') or
                   string.find(key, 'odyssey_j_temporal')) and G.jokers.cards[i] ~= card then
                    count = count + 1
                end
            end
        end
        return { vars = { card.ability.extra.mult_per_joker, count * card.ability.extra.mult_per_joker } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.jokers and G.jokers.cards then
                for i = 1, #G.jokers.cards do
                    local key = G.jokers.cards[i].config.center.key
                    if (string.find(key, 'temporal') or string.find(key, 'relogio') or 
                       string.find(key, 'tempo') or string.find(key, 'paradoxo') or
                       string.find(key, 'futuro') or string.find(key, 'passado') or
                       string.find(key, 'odyssey_j_temporal')) and G.jokers.cards[i] ~= card then
                        count = count + 1
                    end
                end
            end
            
            local mult = count * card.ability.extra.mult_per_joker
            if mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                    mult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 141. Estabilidade Suprema
SMODS.Joker({
    key = 'j_dimensions_ultimate_stability',
    config = { extra = { mult = 20, fixed_hands = 0, fixed_discards = 0 } },
    rarity = 3, -- Changed to Rare
    atlas = 'j_dimensions_ultimate_stability',
    pos = { x = 0, y = 0 },
    cost = 10,  -- Increased cost
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            card.ability.extra.fixed_hands = G.GAME.round_resets.hands
            card.ability.extra.fixed_discards = G.GAME.round_resets.discards
        end
        
        if context.before and not context.blueprint then
            -- Reset hands and discards to fixed values before playing/discarding
            G.GAME.current_round.hands_left = card.ability.extra.fixed_hands
            G.GAME.current_round.discards_left = card.ability.extra.fixed_discards
            
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = 'Estável!', colour = G.C.FILTER })
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 142. Caótico
SMODS.Joker({
    key = 'j_dimensions_chaotic',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_dimensions_chaotic',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if pseudorandom('chaotic') < 0.5 then
                card.ability.extra.mult = card.ability.extra.mult * 2
                return {
                    message = 'Dobrou!',
                    colour = G.C.MULT,
                    card = card
                }
            else
                card.ability.extra.mult = 0
                return {
                    message = 'Zerou!',
                    colour = G.C.RED,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 143. Primeira Carta
SMODS.Joker({
    key = 'j_dimensions_first_card',
    config = { extra = { chips = 50, first_card = true } },
    rarity = 2,
    atlas = 'j_dimensions_first_card',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.first_card = true
        end
        
        if context.individual and context.cardarea == G.play and card.ability.extra.first_card then
            card.ability.extra.first_card = false
            return {
                chips = card.ability.extra.chips,
                card = card
            }
        end
    end
})

-- 144. Última Carta
SMODS.Joker({
    key = 'j_dimensions_last_card',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_dimensions_last_card',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card == context.scoring_hand[#context.scoring_hand] then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 145. Duplo Processamento
SMODS.Joker({
    key = 'j_dimensions_double_processing',
    config = { extra = { money_loss = 2 } },
    rarity = 2,
    atlas = 'j_dimensions_double_processing',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.money_loss } }

    
    end,
    
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            return {
                message = localize('k_again_ex'),
                repetitions = 1,
                card = context.other_card
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            ease_dollars(-card.ability.extra.money_loss)
            return {
                message = '-$' .. card.ability.extra.money_loss,
                colour = G.C.RED
            }
        end
    end
})

-- 146. Começo de Ante
SMODS.Joker({
    key = 'j_dimensions_ante_start',
    config = { extra = { x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_dimensions_ante_start',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.round_resets.blind_states.Small == 'Current' then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 147. Lutador de Chefes
SMODS.Joker({
    key = 'j_dimensions_boss_fighter',
    config = { extra = { x_mult = 2, mult = 15 } },
    rarity = 2,
    atlas = 'j_dimensions_boss_fighter',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.round_resets.blind_states.Boss == 'Current' then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 148. Observador de Blind
SMODS.Joker({
    key = 'j_dimensions_blind_watcher',
    config = { extra = { mult = 0, mult_gain = 10 } },
    rarity = 2,
    atlas = 'j_dimensions_blind_watcher',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT,
                card = card
            }
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 149. Ordem Reversa
SMODS.Joker({
    key = 'j_dimensions_reverse_order',
    config = { extra = { chips = 15 } },
    rarity = 2,
    atlas = 'j_dimensions_reverse_order',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            return {
                chips = card.ability.extra.chips,
                card = card
            }
        end
    end
})

-- 150. Sacrifício Final
SMODS.Joker({
    key = 'j_dimensions_final_sacrifice',
    config = { extra = { x_mult = 1, x_mult_gain = 0.1 } },
    rarity = 2,
    atlas = 'j_dimensions_final_sacrifice',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.x_mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        -- Quando qualquer Joker é vendido (não blueprint)
        if context.selling_card and not context.blueprint then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
            card_eval_status_text(card, 'extra', nil, nil, nil, { 
                message = localize('k_upgrade_ex'), 
                colour = G.C.MULT 
            })
        end
        
        -- Aplica multiplicador
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- DIMENSIONS - Rare (Jokers 151-158)
-- ============================================

-- 151. Fusão Dimensional
SMODS.Joker({
    key = 'j_dimensions_merge',
    config = { extra = {} },
    rarity = 3,
    atlas = 'j_dimensions_merge',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    -- Mecânica implementada em 03_vanilla_override.lua
    calculate = function(self, card, context)
        if context.joker_main then
            if context.scoring_name == 'Four of a Kind' then
                local has_two_pair = false
                -- Verificar se as cartas marcadas originalmente continham dois pares
                -- Mas o override já mudou o nome da mão para Four of a Kind.
            end
        end
    end
})

-- 152. Universo de Bolso
SMODS.Joker({
    key = 'j_dimensions_pocket_universe',
    config = { extra = {} },
    rarity = 3,
    atlas = 'j_dimensions_pocket_universe',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.selling_card and context.card.ability.set == 'Joker' then
            if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Planet', G.consumeables, nil, nil, nil, nil, nil, 'pocket_universe')
                        new_card:add_to_deck()
                        G.consumeables:emplace(new_card)
                        G.GAME.consumeable_buffer = 0
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_planet'),
                    colour = G.C.SECONDARY_SET.Planet,
                    card = card
                }
            end
        end
    end
})

-- 153. Senhor Dimensional
SMODS.Joker({
    key = 'j_dimensions_lord',
    config = { extra = { x_mult_per_slot = 0.5 } },
    rarity = 3,
    atlas = 'j_dimensions_lord',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local empty_slots = 0
        if G.jokers then
            empty_slots = G.jokers.config.card_limit - #G.jokers.cards
        end
        local current_x_mult = 1 + (empty_slots * card.ability.extra.x_mult_per_slot)
        return { vars = { current_x_mult } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local empty_slots = G.jokers.config.card_limit - #G.jokers.cards
            local x_mult = 1 + (empty_slots * card.ability.extra.x_mult_per_slot)
            if x_mult > 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { x_mult } },
                    Xmult_mod = x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 154. Ruptura da Realidade
SMODS.Joker({
    key = 'j_dimensions_reality_breach',
    config = { extra = { mult = 0, mult_gain = 1 } },
    rarity = 3,
    atlas = 'j_dimensions_reality_breach',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        -- Reset after Boss
        if context.end_of_round and G.GAME.blind.boss and not context.repetition and not context.other_card then
            card.ability.extra.mult = 0
            return {
                message = localize('k_reset'),
                colour = G.C.RED
            }
        end

        -- Destroy discarded cards
        if context.discard then
            if context.other_card then
                -- Trigger dissolve
                if not context.other_card.ability.eternal then context.other_card:start_dissolve() end
                
                -- Add Mult
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult_gain } },
                    colour = G.C.MULT,
                    card = card
                }
            end
        end

        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 155. Onipresente
SMODS.Joker({
    key = 'j_dimensions_omnipresent',
    config = { extra = {} },
    rarity = 3,
    atlas = 'j_dimensions_omnipresent',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            return {
                message = localize('k_again_ex'),
                repetitions = 1,
                card = context.other_card
            }
        end
    end
})

-- 156. Colapso Dimensional
SMODS.Joker({
    key = 'j_dimensions_collapse',
    config = { extra = { active = false, xmult = 3, current_ante = 0 } },
    rarity = 3,
    atlas = 'j_dimensions_collapse',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.active and "Sim" or "Não" } }

    
    end,
    
    calculate = function(self, card, context)
        -- Reset if Ante changed
        if G.GAME.round_resets.ante > card.ability.extra.current_ante then
            card.ability.extra.current_ante = G.GAME.round_resets.ante
            card.ability.extra.active = false
        end

        -- Trigger on Boss Blind selection
        if context.setting_blind and not card.ability.extra.active then
            if G.GAME.blind.boss then
                local available_jokers = {}
                for i = 1, #G.jokers.cards do
                    if G.jokers.cards[i] ~= card and not G.jokers.cards[i].ability.eternal then
                        table.insert(available_jokers, G.jokers.cards[i])
                    end
                end
                
                if #available_jokers > 0 then
                    local victim = pseudorandom_element(available_jokers, pseudoseed('dimensions_collapse'))
                    victim:start_dissolve()
                    card.ability.extra.active = true
                    return {
                        message = localize('k_active_ex'),
                        colour = G.C.RED
                    }
                end
            end
        end

        if context.joker_main and card.ability.extra.active then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 157. Navegador do Multiverso
SMODS.Joker({
    key = 'j_dimensions_multiverse_navigator',
    config = { extra = {} },
    rarity = 3,
    atlas = 'j_dimensions_multiverse_navigator',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.before and context.scoring_name == 'Flush' then
            if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'multiverse_navigator')
                        new_card:add_to_deck()
                        G.consumeables:emplace(new_card)
                        G.GAME.consumeable_buffer = 0
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_tarot'),
                    colour = G.C.SECONDARY_SET.Tarot,
                    card = card
                }
            end
        end
    end
})

-- 158. Transcendência Dimensional
SMODS.Joker({
    key = 'j_dimensions_transcendence',
    config = { extra = { joker_slots = 1, hand_size = 1 } },
    rarity = 3,
    atlas = 'j_dimensions_transcendence',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    add_to_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.joker_slots
        G.hand:change_size(-card.ability.extra.hand_size)
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.joker_slots
        G.hand:change_size(card.ability.extra.hand_size)
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- ============================================
-- DIMENSIONS - Legendary (Jokers 159-160)
-- ============================================

-- 159. Mestre do Espaço
SMODS.Joker({
    key = 'j_dimensions_master_of_space',
    config = { extra = {} },
    rarity = 4,
    atlas = 'j_dimensions_master_of_space',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    -- Logic handled in overrides or context.before
    calculate = function(self, card, context)
        -- Placeholder for visual feedback
        if context.joker_main then
            return {
                message = localize('k_active_ex'),
                colour = G.C.PURPLE
            }
        end
    end
})

-- 160. Onidimensional
SMODS.Joker({
    key = 'j_dimensions_omnidimensional',
    config = { extra = { xmult = 5 } },
    rarity = 4,
    atlas = 'j_dimensions_omnidimensional',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    add_to_deck = function(self, card, from_debuff)
        ease_ante(-1)
    end,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- CELESTIAL - Common (Jokers 161-176)
-- ============================================

-- 161. Estrela Cadente
SMODS.Joker({
    key = 'j_celestial_shooting_star',
    config = { extra = { mult = 4, mult_gain = 2 } },
    rarity = 1,
    atlas = 'j_celestial_shooting_star',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.using_consumeable and not context.blueprint then
            if context.consumeable.ability.set == 'Planet' then
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 162. Constelação
SMODS.Joker({
    key = 'j_celestial_constellation',
    config = { extra = { xmult = 1.5, req_faces = 3 } },
    rarity = 1,
    atlas = 'j_celestial_constellation',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult, extra.req_faces } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local faces = 0
            for _, v in ipairs(context.scoring_hand) do
                if v:is_face() then
                    faces = faces + 1
                end
            end
            
            if faces >= card.ability.extra.req_faces then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 163. Lua Nova
SMODS.Joker({
    key = 'j_celestial_new_moon',
    config = { extra = { odds = 4 } },
    rarity = 1,
    atlas = 'j_celestial_new_moon',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { G.GAME.probabilities.normal or 1, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card:is_face() then
                if pseudorandom('new_moon') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    return {
                        message = localize('k_again_ex'),
                        repetitions = 1,
                        card = context.other_card
                    }
                end
            end
        end
    end
})

-- 164. Sol Nascente
SMODS.Joker({
    key = 'j_celestial_rising_sun',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_celestial_rising_sun',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.current_round.hands_played == 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 165. Nebulosa
SMODS.Joker({
    key = 'j_celestial_nebula',
    config = { extra = {} },
    rarity = 1,
    atlas = 'j_celestial_nebula',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.before and context.scoring_name == 'High Card' then
            if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Planet', G.consumeables, nil, nil, nil, nil, nil, 'nebula')
                        new_card:add_to_deck()
                        G.consumeables:emplace(new_card)
                        G.GAME.consumeable_buffer = 0
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_planet'),
                    colour = G.C.SECONDARY_SET.Planet,
                    card = card
                }
            end
        end
    end
})

-- 166. Cometa
SMODS.Joker({
    key = 'j_celestial_comet',
    config = { extra = { chips_per_card = 10 } },
    rarity = 1,
    atlas = 'j_celestial_comet',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local deck_size = G.playing_cards and #G.playing_cards or 0
        return { vars = { deck_size * ( (card and card.ability and card.ability.extra) or self.config.extra ).chips_per_card } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local deck_size = G.playing_cards and #G.playing_cards or 0
            local chips = deck_size * card.ability.extra.chips_per_card
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { chips } },
                chip_mod = chips,
                colour = G.C.CHIPS
            }
        end
    end
})

-- 167. Asteroide
SMODS.Joker({
    key = 'j_celestial_asteroid',
    config = { extra = { base_chips = 50, penalty = 5, current_chips = 50 } },
    rarity = 1,
    atlas = 'j_celestial_asteroid',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.current_chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local cards_played = #context.full_hand
            card.ability.extra.current_chips = math.max(0, card.ability.extra.current_chips - (cards_played * card.ability.extra.penalty))
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.current_chips } },
                chip_mod = card.ability.extra.current_chips,
                colour = G.C.CHIPS
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current_chips = card.ability.extra.base_chips
        end
    end
})

-- 168. Pulsar
SMODS.Joker({
    key = 'j_celestial_pulsar',
    config = { extra = { mult = 10, mult_gain = 10, hands_counter = 0, req_hands = 3 } },
    rarity = 1,
    atlas = 'j_celestial_pulsar',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.hands_counter = card.ability.extra.hands_counter + 1
            if card.ability.extra.hands_counter >= card.ability.extra.req_hands then
                card.ability.extra.hands_counter = 0
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        
        if context.end_of_round and G.GAME.blind.boss and not context.repetition and not context.other_card then
            card.ability.extra.mult = 10
            card.ability.extra.hands_counter = 0
            return {
                message = localize('k_reset'),
                colour = G.C.RED
            }
        end
    end
})

-- 169. Quasar
SMODS.Joker({
    key = 'j_celestial_quasar',
    config = { extra = { base_chips = 40, chips_per_discard = 5, current_chips = 40 } },
    rarity = 1,
    atlas = 'j_celestial_quasar',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.current_chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            card.ability.extra.current_chips = card.ability.extra.current_chips + card.ability.extra.chips_per_discard
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.CHIPS,
                card = card
            }
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.current_chips } },
                chip_mod = card.ability.extra.current_chips,
                colour = G.C.CHIPS
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current_chips = card.ability.extra.base_chips
        end
    end
})

-- 170. Supernova
SMODS.Joker({
    key = 'j_celestial_supernova',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_celestial_supernova',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.after and context.scoring_name == 'High Card' and not context.blueprint then
            card.ability.extra.x_mult = 1
            return {
                message = localize('k_reset'),
                colour = G.C.RED
            }
        end
    end
})

-- 171. Buraco de Minhoca (Comum)
SMODS.Joker({
    key = 'j_celestial_wormhole_common',
    config = { extra = { money = 1 } },
    rarity = 1,
    atlas = 'j_celestial_wormhole',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            if context.other_card:is_face() then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 172. Satélite
SMODS.Joker({
    key = 'j_celestial_satellite',
    config = { extra = { money_per_10 = 1, max_money = 5 } },
    rarity = 1,
    atlas = 'j_celestial_satellite',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.money_per_10, extra.max_money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local bonus = math.min(card.ability.extra.max_money, math.floor(G.GAME.dollars / 10) * card.ability.extra.money_per_10)
            if bonus > 0 then
                ease_dollars(bonus)
                return {
                    message = localize('$') .. bonus,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 173. Eclipse
SMODS.Joker({
    key = 'j_celestial_eclipse',
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    atlas = 'j_celestial_eclipse',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local has_face = false
            for _, v in ipairs(context.scoring_hand) do
                if v:is_face() then
                    has_face = true
                    break
                end
            end
            
            if not has_face then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 174. Meteoro
SMODS.Joker({
    key = 'j_celestial_meteor',
    config = { extra = { base_chips = 40, chips_per_card = 4 } },
    rarity = 1,
    atlas = 'j_celestial_meteor',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.base_chips, extra.chips_per_card } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local held_cards = #G.hand.cards
            local chips = card.ability.extra.base_chips + (held_cards * card.ability.extra.chips_per_card)
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { chips } },
                chip_mod = chips,
                colour = G.C.CHIPS
            }
        end
    end
})

-- 175. Poeira Cósmica
SMODS.Joker({
    key = 'j_celestial_cosmic_dust',
    config = { extra = { mult_per_card = 2 } },
    rarity = 1,
    atlas = 'j_celestial_cosmic_dust',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local deck_size = G.playing_cards and #G.playing_cards or 0
        local excess = math.max(0, deck_size - 52)
        return { vars = { excess * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_card } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local deck_size = G.playing_cards and #G.playing_cards or 0
            local excess = math.max(0, deck_size - 52)
            local mult = excess * card.ability.extra.mult_per_card
            if mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                    mult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 176. Radiação Estelar
SMODS.Joker({
    key = 'j_celestial_stellar_radiation',
    config = { extra = { chips = 5 } },
    rarity = 1,
    atlas = 'j_celestial_stellar_radiation',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            return {
                chips = card.ability.extra.chips,
                card = context.other_card
            }
        end
    end
})

-- ============================================
-- CELESTIAL - Uncommon (Jokers 177-190)
-- ============================================

-- 177. Alinhamento Planetário
SMODS.Joker({
    key = 'j_celestial_planetary_alignment',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_celestial_planetary_alignment',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if #context.scoring_hand == 4 then
                local suits = {}
                for _, v in ipairs(context.scoring_hand) do
                    suits[v.base.suit] = true
                end
                
                local count = 0
                for _ in pairs(suits) do count = count + 1 end
                
                if count == 4 then
                    return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    end
})

-- 178. Chuva de Meteoros
SMODS.Joker({
    key = 'j_celestial_meteor_shower',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_celestial_meteor_shower',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card == context.scoring_hand[1] then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = context.other_card
                }
            end
        end
    end
})

-- 179. Tempestade Solar
SMODS.Joker({
    key = 'j_celestial_solar_storm',
    config = { extra = { mult = 0, mult_gain = 3 } },
    rarity = 2,
    atlas = 'j_celestial_solar_storm',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            if context.other_card:is_suit('Spades') then
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.mult = 0
        end
    end
})

-- 180. Anéis de Saturno
SMODS.Joker({
    key = 'j_celestial_rings_of_saturn',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_celestial_rings_of_saturn',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:get_id() == 8 then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 181. Gravidade Zero
SMODS.Joker({
    key = 'j_celestial_zero_gravity',
    config = { extra = { x_mult = 3, odyssey_wraparound_straight = true } },
    rarity = 2,
    atlas = 'j_celestial_zero_gravity',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Straight" then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                x_mult = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 182. Campo Estelar
SMODS.Joker({
    key = 'j_celestial_stellar_field',
    config = { extra = { xmult = 2 } },
    rarity = 2,
    atlas = 'j_celestial_stellar_field',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if #context.scoring_hand == 5 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 183. Fusão Nuclear
SMODS.Joker({
    key = 'j_celestial_nuclear_fusion',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_celestial_nuclear_fusion',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.before and context.scoring_name == 'Pair' and not context.blueprint then
            local destroyed_cards = {}
            for _, v in ipairs(context.scoring_hand) do
                destroyed_cards[#destroyed_cards+1] = v
                v:start_dissolve()
            end
            
            if #destroyed_cards > 0 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Default', G.hand, nil, nil, nil, nil, 'm_odyssey_emerald', 'nuclear_fusion')
                        new_card:add_to_deck()
                        G.hand:emplace(new_card)
                        return true
                    end
                }))
                return {
                    message = localize('k_fusion'),
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 184. Vento Solar
SMODS.Joker({
    key = 'j_celestial_solar_wind',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_celestial_solar_wind',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card == context.scoring_hand[#context.scoring_hand] then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = context.other_card
                }
            end
        end
    end
})

-- 185. Maré Gravitacional
SMODS.Joker({
    key = 'j_celestial_gravitational_tide',
    config = { extra = { hand_size = 1, discards = 1 } },
    rarity = 2,
    atlas = 'j_celestial_gravitational_tide',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    add_to_deck = function(self, card, from_debuff)
        G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 186. Horizonte de Eventos
SMODS.Joker({
    key = 'j_celestial_event_horizon',
    config = { extra = { mult = 0, mult_gain = 3, destroyed_this_round = false } },
    rarity = 2,
    atlas = 'j_celestial_event_horizon',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint and not card.ability.extra.destroyed_this_round then
            if context.other_card == context.full_hand[1] then -- First card in discard selection
                card.ability.extra.destroyed_this_round = true
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                if not context.other_card.ability.eternal then context.other_card:start_dissolve() end
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.destroyed_this_round = false
        end
    end
})

-- 187. Singularidade Estelar
SMODS.Joker({
    key = 'j_celestial_stellar_singularity',
    config = { extra = { x_mult_per_slot = 0.2 } },
    rarity = 2,
    atlas = 'j_celestial_stellar_singularity',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local empty_slots = (G.jokers and G.jokers.config and G.jokers.cards) and math.max(0, G.jokers.config.card_limit - #G.jokers.cards) or 0
        local total_x_mult = 1 + (empty_slots * ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_per_slot)
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_per_slot, empty_slots, total_x_mult } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local empty_slots = math.max(0, G.jokers.config.card_limit - #G.jokers.cards)
            local total_x_mult = 1 + (empty_slots * card.ability.extra.x_mult_per_slot)
            if total_x_mult > 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { total_x_mult } },
                    Xmult_mod = total_x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 188. Nebulosa Planetária
SMODS.Joker({
    key = 'j_celestial_planetary_nebula',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_celestial_planetary_nebula',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.end_of_round and G.GAME.blind.boss and not context.repetition and not context.other_card then
            if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Planet', G.consumeables, nil, nil, nil, nil, nil, 'planetary_nebula')
                        new_card:add_to_deck()
                        G.consumeables:emplace(new_card)
                        G.GAME.consumeable_buffer = 0
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_planet'),
                    colour = G.C.SECONDARY_SET.Planet,
                    card = card
                }
            end
        end
    end
})

-- 189. Proto-estrela
SMODS.Joker({
    key = 'j_celestial_protostar',
    config = { extra = { x_mult = 1, x_mult_gain = 0.1 } },
    rarity = 2,
    atlas = 'j_celestial_protostar',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT,
                card = card
            }
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 190. Anã Branca
SMODS.Joker({
    key = 'j_celestial_white_dwarf',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_celestial_white_dwarf',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played == 0 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- ============================================
-- CELESTIAL - Rare (Jokers 191-198)
-- ============================================

-- 191. Big Bang
SMODS.Joker({
    key = 'j_celestial_big_bang',
    rarity = 3,
    atlas = 'j_celestial_big_bang',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = false,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.selling_self then
            -- Destroy all other jokers
            local jokers_to_destroy = {}
            for _, v in ipairs(G.jokers.cards) do
                if v ~= card then
                    jokers_to_destroy[#jokers_to_destroy+1] = v
                end
            end
            
            for _, v in ipairs(jokers_to_destroy) do
                v:start_dissolve()
            end
            
            -- Create 5 random common jokers
            G.E_MANAGER:add_event(Event({
                func = function()
                    for i = 1, 5 do
                        local card = create_card('Joker', G.jokers, nil, 0, nil, nil, nil, 'celestial_big_bang')
                        card:add_to_deck()
                        G.jokers:emplace(card)
                    end
                    return true
                end
            }))
            return {
                message = localize('k_big_bang'),
                colour = G.C.RED
            }
        end
    end
})

-- 192. Buraco Negro Supermassivo
SMODS.Joker({
    key = 'j_celestial_supermassive_black_hole',
    config = { extra = { x_mult = 4 } },
    rarity = 3,
    atlas = 'j_celestial_supermassive_black_hole',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.after and not context.blueprint then
            if #G.hand.cards > 0 then
                local random_card = pseudorandom_element(G.hand.cards, pseudoseed('celestial_supermassive'))
                if random_card then
                    if not random_card.ability.eternal then random_card:start_dissolve() end
                    return {
                        message = localize('k_destroyed'),
                        colour = G.C.RED,
                        card = card
                    }
                end
            end
        end
    end
})

-- 193. Explosão de Raios Gama
SMODS.Joker({
    key = 'j_celestial_gamma_ray_burst',
    config = { extra = { x_mult = 10 } },
    rarity = 3,
    atlas = 'j_celestial_gamma_ray_burst',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = false,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.after and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                func = function()
                    if not card.ability.eternal then card:start_dissolve() end
                    return true
                end
            }))
            return {
                message = localize('k_destroyed'),
                colour = G.C.RED
            }
        end
    end
})

-- 194. Matéria Escura
SMODS.Joker({
    key = 'j_celestial_dark_matter',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_celestial_dark_matter',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.current_round.discards_left == 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 195. Energia Escura
SMODS.Joker({
    key = 'j_celestial_dark_energy',
    rarity = 3,
    atlas = 'j_celestial_dark_energy',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    add_to_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit + 1
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 196. Inflação Cósmica
SMODS.Joker({
    key = 'j_celestial_cosmic_inflation',
    config = { extra = { max_gain = 50 } },
    rarity = 3,
    atlas = 'j_celestial_cosmic_inflation',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local gain = math.min(G.GAME.dollars, card.ability.extra.max_gain)
            if gain > 0 then
                ease_dollars(gain)
                return {
                    message = localize('$') .. gain,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 197. Falso Vácuo
SMODS.Joker({
    key = 'j_celestial_false_vacuum',
    config = { extra = { x_mult = 5, odds = 20 } },
    rarity = 3,
    atlas = 'j_celestial_false_vacuum',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            if pseudorandom('celestial_false_vacuum') < G.GAME.probabilities.normal / card.ability.extra.odds then
                ease_dollars(-G.GAME.dollars)
                return {
                    message = localize('k_reset'),
                    colour = G.C.RED,
                    card = card
                }
            end
        end
    end
})


-- 198. Esfera de Dyson
SMODS.Joker({
    key = 'j_celestial_dyson_sphere',
    rarity = 3,
    atlas = 'j_celestial_dyson_sphere',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    add_to_deck = function(self, card, from_debuff)
        G.GAME.interest_cap = 100
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.interest_cap = 25
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- ============================================
-- CELESTIAL - Legendary (Jokers 199-200)
-- ============================================

-- 199. Gerador de Universos
SMODS.Joker({
    key = 'j_celestial_universe_generator',
    rarity = 4,
    atlas = 'j_celestial_universe_generator',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = false,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                func = function()
                    local legendary = create_card('Joker', G.jokers, true, 4, nil, nil, nil, 'celestial_universe_generator')
                    legendary:add_to_deck()
                    G.jokers:emplace(legendary)
                    if not card.ability.eternal then card:start_dissolve() end
                    return true
                end
            }))
            return {
                message = localize('k_universe'),
                colour = G.C.LEGENDARY
            }
        end
    end
})

-- 200. Entidade Cósmica
SMODS.Joker({
    key = 'j_celestial_cosmic_entity',
    config = { extra = { x_mult = 4 } },
    rarity = 4,
    atlas = 'j_celestial_cosmic_entity',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.repetition and context.cardarea == G.play then
            return {
                message = localize('k_again_ex'),
                repetitions = 1,
                card = context.other_card
            }
        end
    end
})


-- ============================================
-- CHAOS - Common (Jokers 201-216)
-- ============================================

-- 201. Dado Viciado (Loaded Die)
SMODS.Joker({
    key = 'j_chaos_loaded_die',
    config = { extra = { mult = 30, odds = 6 } },
    rarity = 1,
    atlas = 'j_chaos_loaded_die',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('j_chaos_loaded_die') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 202. Moeda da Sorte (Lucky Coin)
SMODS.Joker({
    key = 'j_chaos_lucky_coin',
    config = { extra = { mult = 15, odds = 2 } },
    rarity = 1,
    atlas = 'j_chaos_lucky_coin',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('j_chaos_lucky_coin') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 203. Roleta (Roulette)
SMODS.Joker({
    key = 'j_chaos_roulette',
    config = { extra = { x_mult = 4, odds = 20 } },
    rarity = 1,
    atlas = 'j_chaos_roulette',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('j_chaos_roulette') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 204. Imprevisível (Unpredictable)
SMODS.Joker({
    key = 'j_chaos_unpredictable',
    config = { extra = { max_mult = 20 } },
    rarity = 1,
    atlas = 'j_chaos_unpredictable',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.max_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local rand_mult = pseudorandom('j_chaos_unpredictable') * card.ability.extra.max_mult
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { math.floor(rand_mult) } },
                mult_mod = rand_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 205. Caos Controlado (Controlled Chaos)
SMODS.Joker({
    key = 'j_chaos_controlled_chaos',
    config = { extra = { mult = 10, chips = 50 } },
    rarity = 1,
    atlas = 'j_chaos_controlled_chaos',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local is_red = false
            for _, c in ipairs(context.scoring_hand) do
                if c:is_suit('Hearts') or c:is_suit('Diamonds') then
                    is_red = true
                    break
                end
            end

            if is_red then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 206. Entropia Menor (Minor Entropy)
SMODS.Joker({
    key = 'j_chaos_minor_entropy',
    config = { extra = { mult = 4 } },
    rarity = 1,
    atlas = 'j_chaos_minor_entropy',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local odd_count = 0
            for _, c in ipairs(G.hand.cards) do
                if not c.debuff and (c:get_id() == 14 or c:get_id() == 3 or c:get_id() == 5 or c:get_id() == 7 or c:get_id() == 9) then
                    odd_count = odd_count + 1
                end
            end
            if odd_count > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult * odd_count } },
                    mult_mod = card.ability.extra.mult * odd_count,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 207. Embaralhador (Shuffler)
SMODS.Joker({
    key = 'j_chaos_shuffler',
    config = { extra = { chips = 50 } },
    rarity = 1,
    atlas = 'j_chaos_shuffler',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                chip_mod = card.ability.extra.chips,
                colour = G.C.CHIPS
            }
        end
        if context.after and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.1,
                func = function()
                    G.hand:shuffle('j_chaos_shuffler')
                    return true
                end
            }))
            return {
                message = localize('k_shuffled'),
                colour = G.C.ORANGE
            }
        end
    end
})

-- 208. Coringa Selvagem (Wild Joker)
SMODS.Joker({
    key = 'j_chaos_wild_joker',
    config = { extra = { mult = 10, odds = 5 } },
    rarity = 1,
    atlas = 'j_chaos_wild_joker',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        if context.before and not context.blueprint then
            for _, c in ipairs(context.scoring_hand) do
                if pseudorandom('j_chaos_wild_joker') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    local suits = {'Spades', 'Hearts', 'Clubs', 'Diamonds'}
                    local new_suit = suits[pseudorandom('j_chaos_wild_joker_suit', 1, 4)]
                    c:change_suit(new_suit)
                    card_eval_status_text(c, 'extra', nil, nil, nil, {message = localize(new_suit, 'suits_singular'), colour = G.C.SUITS[new_suit]})
                end
            end
        end
    end
})

-- 209. Sorte de Principiante (Beginner's Luck)
SMODS.Joker({
    key = 'j_chaos_beginners_luck',
    config = { extra = { x_mult = 2, odds = 3 } },
    rarity = 1,
    atlas = 'j_chaos_beginners_luck',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played == 0 then
            if pseudorandom('j_chaos_beginners_luck') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize('k_nope_ex'),
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 210. Aposta Alta (High Stakes)
SMODS.Joker({
    key = 'j_chaos_high_stakes',
    config = { extra = { mult = 20, dollars = 1 } },
    rarity = 1,
    atlas = 'j_chaos_high_stakes',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.dollars } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if not context.blueprint then
                ease_dollars(-card.ability.extra.dollars)
            end
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 211. Risco Calculado (Calculated Risk)
SMODS.Joker({
    key = 'j_chaos_calculated_risk',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_chaos_calculated_risk',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_left == 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 212. Frenesi (Frenzy)
SMODS.Joker({
    key = 'j_chaos_frenzy',
    config = { extra = { mult_gain = 5, current_mult = 0 } },
    rarity = 1,
    atlas = 'j_chaos_frenzy',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_gain, extra.current_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.cardarea == G.jokers and context.before and not context.blueprint then
            card.ability.extra.current_mult = card.ability.extra.current_mult + card.ability.extra.mult_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.current_mult } },
                mult_mod = card.ability.extra.current_mult,
                colour = G.C.MULT
            }
        end
        if context.discard and not context.blueprint and not context.other_card then
            card.ability.extra.current_mult = 0
            return {
                message = localize('k_reset'),
                colour = G.C.RED
            }
        end
        if context.end_of_round and not context.blueprint and not context.repetition and not context.other_card then
            card.ability.extra.current_mult = 0
        end
    end
})

-- 213. Dispersão (Scatter)
SMODS.Joker({
    key = 'j_chaos_scatter',
    config = { extra = { max_chips = 10 } },
    rarity = 1,
    atlas = 'j_chaos_scatter',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.max_chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local rand_chips = pseudorandom('j_chaos_scatter') * card.ability.extra.max_chips
            return {
                chips = rand_chips,
                card = context.other_card
            }
        end
    end
})

-- 214. Ruído Branco (White Noise)
SMODS.Joker({
    key = 'j_chaos_white_noise',
    config = { extra = { mult = 10, odds = 10 } },
    rarity = 1,
    atlas = 'j_chaos_white_noise',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        if context.before and not context.blueprint then
            for _, c in ipairs(context.scoring_hand) do
                if pseudorandom('j_chaos_white_noise') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    c:set_ability(G.P_CENTERS.m_odyssey_emerald)
                    card_eval_status_text(c, 'extra', nil, nil, nil, {message = localize('k_stone'), colour = G.C.GREY})
                end
            end
        end
    end
})

-- 215. Turbulência (Turbulence)
SMODS.Joker({
    key = 'j_chaos_turbulence',
    config = { extra = { chips = 40, penalty = 10 } },
    rarity = 1,
    atlas = 'j_chaos_turbulence',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips, extra.penalty } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local chips = card.ability.extra.chips
            if #context.scoring_hand == 5 then
                chips = chips - card.ability.extra.penalty
            end
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { chips } },
                chip_mod = chips,
                colour = G.C.CHIPS
            }
        end
    end
})

-- 216. Instável (Unstable)
SMODS.Joker({
    key = 'j_chaos_unstable',
    config = { extra = { x_mult = 1.5, odds = 10 } },
    rarity = 1,
    atlas = 'j_chaos_unstable',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        if context.end_of_round and not context.blueprint and not context.repetition and not context.other_card then
            if pseudorandom('j_chaos_unstable') < G.GAME.probabilities.normal / card.ability.extra.odds then
                if not card.ability.eternal then
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            card:start_dissolve()
                            return true
                        end
                    }))
                    return {
                        message = localize('k_destroyed'),
                        colour = G.C.RED
                    }
                end
            end
        end
    end
})

-- 217. Chaos Theory
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_theory',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_chaos_theory',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            local suit_count = 0
            for i = 1, #context.scoring_hand do
                local s = (context.scoring_hand[i]:get_id() > 0 or context.scoring_hand[i].config.center.key == 'j_odyssey_j_chaos_butterfly_effect') and context.scoring_hand[i].base.suit or 'None'
                if s ~= 'None' and not suits[s] then
                    suits[s] = true
                    suit_count = suit_count + 1
                end
            end
            
            if suit_count >= 4 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 218. Butterfly Effect
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_butterfly_effect',
    config = {},
    rarity = 2,
    atlas = 'j_chaos_butterfly_effect',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local first_card = context.scoring_hand[1]
            if first_card then
                local target_suit = first_card.base.suit
                card.ability.extra_original_suits = {}
                for i = 2, #context.scoring_hand do
                   local c = context.scoring_hand[i]
                   card.ability.extra_original_suits[c] = c.base.suit
                   c:change_suit(target_suit)
                end
                return {
                    message = localize('k_active_ex'),
                    card = card
                }
            end
        end
        if context.after and not context.blueprint and card.ability.extra_original_suits then
            for c, original_suit in pairs(card.ability.extra_original_suits) do
                c:change_suit(original_suit)
            end
            card.ability.extra_original_suits = nil
        end
    end
})

-- 219. Pandemonium
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_pandemonium',
    config = { extra = { repetitions = 3 } },
    rarity = 2,
    atlas = 'j_chaos_pandemonium',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
           if #G.hand.cards > 0 then
               local rng = pseudorandom('j_chaos_pandemonium')
               local idx = math.ceil(rng * #G.hand.cards)
               card.ability.extra.target_card = G.hand.cards[idx]
           else
               card.ability.extra.target_card = nil
           end
        end
        
        if context.repetition and context.cardarea == G.hand then
             if card.ability.extra.target_card and context.other_card == card.ability.extra.target_card then
                 return {
                     message = localize('k_again_ex'),
                     repetitions = card.ability.extra.repetitions,
                     card = context.other_card
                 }
             end
        end
    end
})

-- 220. Discord
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_discord',
    config = { extra = { mult = 30 } },
    rarity = 2,
    atlas = 'j_chaos_discord',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local played_hand = context.scoring_name
            local max_played = 0
            local most_played_hand = ''
            
            for k, v in pairs(G.GAME.hands) do
                if v.played > max_played then
                    max_played = v.played
                    most_played_hand = k
                end
            end
            
            if played_hand ~= most_played_hand then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 221. Anarchy
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_anarchy',
    config = { extra = { min = 0.5, max = 3 } },
    rarity = 2,
    atlas = 'j_chaos_anarchy',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.min, extra.max } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local x_mult = card.ability.extra.min + (pseudorandom('j_chaos_anarchy') * (card.ability.extra.max - card.ability.extra.min))
            -- Round to 1 decimal like in DOC
            x_mult = math.floor(x_mult * 10) / 10
             return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { x_mult } },
                Xmult_mod = x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 222. Mana Vortex
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_mana_vortex',
    loc_txt = {
        name = "Mana Vortex",
        text = {
            "Creates a random {C:tarot}Tarot{} card,",
            "but destroys a random {C:attention}Common Joker{}",
            "(if any) at end of round"
        }
    },
    config = {},
    rarity = 2,
    atlas = 'j_chaos_mana_vortex',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            -- Create Tarot
            if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local tarot = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'j_chaos_mana_vortex')
                        tarot:add_to_deck()
                        G.consumeables:emplace(tarot)
                        return true
                    end
                }))
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_plus_tarot'), colour = G.C.PURPLE})
            end
            
            -- Destroy Common Joker
            local commons = {}
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] ~= card and G.jokers.cards[i].config.center.rarity == 1 and not G.jokers.cards[i].ability.eternal then
                    commons[#commons + 1] = G.jokers.cards[i]
                end
            end
            
            if #commons > 0 then
                local victim = pseudorandom_element(commons, pseudorandom('j_chaos_mana_vortex'))
                G.E_MANAGER:add_event(Event({
                    func = function()
                        victim:start_dissolve()
                        return true
                    end
                }))
                 card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_destroyed'), colour = G.C.RED})
            end
        end
    end
})

-- 223. Transmutation
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_transmutation',
    loc_txt = {
        name = "Transmutation",
        text = {
            "When sold, transforms into",
            "a random {C:attention}Uncommon Joker{}"
        }
    },
    config = {},
    rarity = 2,
    atlas = 'j_chaos_transmutation',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = false,
    eternal_compat = false,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.selling_self then
             G.E_MANAGER:add_event(Event({
                func = function()
                    local joker = create_card('Joker', G.jokers, nil, 0.9, nil, nil, nil, 'j_chaos_transmutation')
                    joker:add_to_deck()
                    G.jokers:emplace(joker)
                    joker:start_materialize()
                    return true
                end
            }))
             return {
                message = localize('k_transmuted'),
                colour = G.C.PURPLE
            }     
        end
    end
})

-- 224. Unstable Alchemy
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_unstable_alchemy',
    loc_txt = {
        name = "Unstable Alchemy",
        text = {
            "Earn {C:money}$#1#{} when playing a {C:attention}Flush{}.",
            "{C:green}#2# in #3#{} chance to transform",
            "the Flush into {C:diamonds}Diamonds{}"
        }
    },
    config = { extra = { dollars = 4, odds = 4 } },
    rarity = 2,
    atlas = 'j_chaos_unstable_alchemy',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars, G.GAME.probabilities.normal, extra.odds } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'Flush' then
            G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + card.ability.extra.dollars
            G.E_MANAGER:add_event(Event({func = function() G.GAME.dollars = G.GAME.dollars + card.ability.extra.dollars; G.GAME.dollar_buffer = G.GAME.dollar_buffer - card.ability.extra.dollars; return true end}))
            
            if pseudorandom('j_chaos_unstable_alchemy') < G.GAME.probabilities.normal / card.ability.extra.odds then
                 for i = 1, #context.scoring_hand do
                    local c = context.scoring_hand[i]
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            c:change_suit('Diamonds')
                            c:juice_up()
                            return true
                        end
                    }))
                 end
                 return {
                    message = localize('k_alchemy'), 
                    colour = G.C.DIAMONDS
                }
            else
                 return {
                    message = localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 225. Chain Reaction
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_chain_reaction',
    loc_txt = {
        name = "Chain Reaction",
        text = {
            "{C:mult}+#1#{} Mult for each time a",
            "Joker ability activated this hand"
        }
    },
    config = { extra = { mult_per_trigger = 5 } },
    rarity = 2,
    atlas = 'j_chaos_chain_reaction',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult_per_trigger } }

    end,
    calculate = function(self, card, context)
        -- Counting triggers is hard, so we estimate based on jokers count if we can't get official count.
        -- But for now, we'll use a safer proxy: +5 Mult for each Joker you own.
        -- Actually, let's use the intended mechanic if possible.
        if context.joker_main then
            local count = #G.jokers.cards
            -- Simplified to +5 per Joker for now to avoid crashes with non-existent global counters
            local mult = count * card.ability.extra.mult_per_trigger
             return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                mult_mod = mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 226. Will-o'-the-Wisp
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_will_o_the_wisp',
    loc_txt = {
        name = "Will-o'-the-Wisp",
        text = {
            "Create a {C:dark_edition}Negative{} copy",
            "of a random consumable",
            "when you defeat a {C:attention}Boss Blind{}"
        }
    },
    config = {},
    rarity = 2,
    atlas = 'j_chaos_will_o_the_wisp',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.blind.boss then
                 local card_type = pseudorandom_element({'Tarot', 'Planet', 'Spectral'}, pseudorandom('j_chaos_will_o_the_wisp'))
                 G.E_MANAGER:add_event(Event({
                    func = function()
                        local consum = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, 'j_chaos_will_o_the_wisp')
                        consum:set_edition('e_negative', true)
                        consum:add_to_deck()
                        G.consumeables:emplace(consum)
                        return true
                    end
                }))
                 return {
                    message = localize('k_wisp'),
                    colour = G.C.DARK_EDITION
                 }
            end
        end
    end
})

-- 227. Pandora's Box
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_pandoras_box',
    loc_txt = {
        name = "Pandora's Box",
        text = {
            "When bought, gain {C:money}$#1#{}.",
            "Sets your Mult to {C:attention}0{}",
            "on the next hand played"
        }
    },
    config = { extra = { money = 20 } },
    rarity = 2,
    atlas = 'j_chaos_pandoras_box',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = false,
    eternal_compat = false,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.buying_card and context.card == card then
            G.GAME.dollars = G.GAME.dollars + card.ability.extra.money
             card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('$')..card.ability.extra.money, colour = G.C.MONEY})
             card.ability.extra.active_debuff = true
        end
        
        if context.joker_main and card.ability.extra.active_debuff then
            card.ability.extra.active_debuff = false
            return {
                message = localize('k_pandora'),
                mult_mod = -100000,
                Xmult_mod = 0
            }
        end
    end
})

-- 228. Bad Omen
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_bad_omen',
    config = { extra = { x_mult = 3, odds = 4, severe_x_mult = 0.5 } },
    rarity = 2,
    atlas = 'j_chaos_bad_omen',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds, extra.severe_x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('j_chaos_bad_omen') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.severe_x_mult } },
                    Xmult_mod = card.ability.extra.severe_x_mult,
                    colour = G.C.RED
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 229. Leap of Faith
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_leap_of_faith',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_chaos_leap_of_faith',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.current_round.hands_left == 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})


-- 230. Dissonance
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_dissonance',
    loc_txt = {
        name = "Dissonance",
        text = {
            "{C:chips}+#1#{} Chips if played cards",
            "do not form any poker hand",
            "({C:attention}High Card{})"
        }
    },
    config = { extra = { chips = 100 } },
    rarity = 2,
    atlas = 'j_chaos_dissonance',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if context.scoring_name == 'High Card' then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- 231. Agent of Chaos
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_agent_of_chaos',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_chaos_agent_of_chaos',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        if context.before and not context.blueprint then
            if #G.hand.cards > 0 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local victim = pseudorandom_element(G.hand.cards, pseudorandom('j_chaos_agent'))
                        G.hand:add_to_highlighted(victim)
                        return true
                    end
                }))
            end
        end
    end
})

-- 232. Improbability Drive
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_improbability_drive',
    config = { extra = { odds = 100, dollars = 100 } },
    rarity = 3,
    atlas = 'j_chaos_improbability_drive',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.odds } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('j_chaos_improbability_drive') < G.GAME.probabilities.normal / card.ability.extra.odds then
                G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + card.ability.extra.dollars
                G.E_MANAGER:add_event(Event({func = function() G.GAME.dollars = G.GAME.dollars + card.ability.extra.dollars; G.GAME.dollar_buffer = G.GAME.dollar_buffer - card.ability.extra.dollars; return true end}))
                return {
                    message = localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 233. Chance Nexus
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_chance_nexus',
    loc_txt = {
        name = "Chance Nexus",
        text = {
            "Increases probabilities list in",
            "other Jokers by {C:attention}25%{}",
            "{C:inactive}(e.g. 1 in 4 becomes 1 in 3){}"
        }
    },
    config = { extra = { percentage = 1.25 } },
    rarity = 3,
    atlas = 'j_chaos_chance_nexus',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    -- Implementing this by multiplying G.GAME.probabilities.normal
    add_to_deck = function(self, card, from_debuff)
        G.GAME.probabilities.normal = G.GAME.probabilities.normal * card.ability.extra.percentage
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.probabilities.normal = G.GAME.probabilities.normal / card.ability.extra.percentage
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 234. Primal Form
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_primal_form',
    config = {},
    rarity = 3,
    atlas = 'j_chaos_primal_form',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    eternal_compat = false,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            for i = 1, #G.hand.cards do
                local c = G.hand.cards[i]
                c:set_base(G.P_CARDS[c.base.suit..'_A'])
            end
            G.E_MANAGER:add_event(Event({
                func = function()
                    if not card.ability.eternal then card:start_dissolve() end
                    return true
                end
            }))
            return {
                message = localize('k_primal'),
                colour = G.C.FILTER
            }
        end
    end
})

-- 235. Maximum Entropy
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_maximum_entropy',
    config = { extra = { x_mult = 4 } },
    rarity = 3,
    atlas = 'j_chaos_maximum_entropy',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            local victim = pseudorandom_element(G.jokers.cards, pseudorandom('maximum_entropy'))
            if victim then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        victim:start_dissolve()
                        return true
                    end
                }))
            end
        end
    end
})

-- 236. Heart of Chaos
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_heart_of_chaos',
    config = { extra = { copy_target = nil } },
    rarity = 3,
    atlas = 'j_chaos_heart_of_chaos',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local right_jokers = {}
            local my_pos = nil
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then my_pos = i end
            end
            if my_pos then
                for i = my_pos + 1, #G.jokers.cards do
                    right_jokers[#right_jokers+1] = G.jokers.cards[i]
                end
            end
            if #right_jokers > 0 then
                card.ability.extra.copy_target = pseudorandom_element(right_jokers, pseudorandom('j_chaos_heart'))
            else
                card.ability.extra.copy_target = nil
            end
        end
        
        if card.ability.extra.copy_target then
            local other_joker = card.ability.extra.copy_target
            context.blueprint = true
            local ret = other_joker:calculate_joker(context)
            if ret then
                ret.card = card
                return ret
            end
        end
    end
})

-- 237. Warp Storm
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_warp_storm',
    config = { extra = { mult_per_suit = 10 } },
    rarity = 3,
    atlas = 'j_chaos_warp_storm',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult_per_suit } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            local suit_count = 0
            for i = 1, #G.playing_cards do
                local s = G.playing_cards[i].base.suit
                if not suits[s] then
                    suits[s] = true
                    suit_count = suit_count + 1
                end
            end
            local mult = suit_count * card.ability.extra.mult_per_suit
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                mult_mod = mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 238. The Great Filter
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_the_great_filter',
    config = { extra = { x_mult = 1 } },
    rarity = 3,
    atlas = 'j_chaos_the_great_filter',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if card.ability.extra.x_mult > 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
        if context.before and not context.blueprint then
            if context.scoring_name == '5 of a Kind' and card.ability.extra.x_mult < 5 then
                card.ability.extra.x_mult = 5
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT
                }
            end
        end
    end
})


-- 239. Azathoth
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_azathoth',
    config = { extra = { x_mult = 10 } },
    rarity = 4,
    atlas = 'j_chaos_azathoth',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        if context.end_of_round and not context.blueprint and not context.repetition and not context.other_card then
            if G.playing_cards and #G.playing_cards > 0 then
                local target = G.playing_cards[pseudorandom('j_chaos_azathoth', 1, #G.playing_cards)]
                G.E_MANAGER:add_event(Event({
                    func = function()
                        play_sound('tarot1')
                        target:start_dissolve()
                        return true
                    end
                }))
                return {
                    message = localize('k_eaten_ex'),
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 240. Crawling Chaos
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_crawling_chaos',
    config = { extra = { x_mult = 2, gain = 0.5 } },
    rarity = 4,
    atlas = 'j_chaos_crawling_chaos',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.gain } }

    end,
    calculate = function(self, card, context)
        if context.cardarea == G.jokers and context.before and not context.blueprint then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 241. Visual Bug
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_visual_bug',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_glitch_visual_bug',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        if context.before and not context.blueprint then
            -- Visual effect: flip cards face down only for this hand
            for k, v in ipairs(context.scoring_hand) do
                v.facing = 'back'
                v.sprite_facing = 'back'
            end
        end
        if context.after and not context.blueprint then
            -- Reset visual effect
            for k, v in ipairs(G.play.cards) do
                v.facing = 'front'
                v.sprite_facing = 'front'
            end
        end
    end
})

-- 242. Syntax Error
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_syntax_error',
    config = { extra = { chips = 50, money = 2 } },
    rarity = 1,
    atlas = 'j_glitch_syntax_error',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                chip_mod = card.ability.extra.chips,
                colour = G.C.CHIPS
            }
        end
        if context.before and context.scoring_name == 'High Card' and not context.blueprint then
            ease_dollars(card.ability.extra.money)
            return {
                message = localize('$')..card.ability.extra.money,
                colour = G.C.MONEY,
                card = card
            }
        end
    end
})

-- 243. Lag
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_lag',
    config = { extra = { mult = 20, active = false } },
    rarity = 1,
    atlas = 'j_glitch_lag',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if card.ability.extra.active then
                card.ability.extra.active = false
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            else
                card.ability.extra.active = true
                return {
                    message = 'Lag...',
                    colour = G.C.ATTENTION
                }
            end
        end
    end
})

-- 244. Dead Pixel
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_dead_pixel',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_glitch_dead_pixel',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        if context.before and not context.blueprint then
            local available_cards = {}
            for k, v in ipairs(G.hand.cards) do
                if not v.debuff then table.insert(available_cards, v) end
            end
            if #available_cards > 0 then
                local target = pseudorandom_element(available_cards, pseudorandom('dead_pixel'))
                target:set_debuff(true)
                return {
                    message = 'Dead Pixel!',
                    colour = G.C.RED,
                    card = card
                }
            end
        end
    end
})

-- 245. Money Glitch
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_money_glitch',
    config = { extra = { odds = 10, money = 5 } },
    rarity = 1,
    atlas = 'j_glitch_money_glitch',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money, G.GAME.probabilities.normal, extra.odds } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('money_glitch') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize('$')..card.ability.extra.money,
                    dollars = card.ability.extra.money,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 246. Overflow
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_overflow',
    config = { extra = { threshold = 100, mult = 10 } },
    rarity = 1,
    atlas = 'j_glitch_overflow',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.threshold, extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local chips = G.GAME.hands[context.scoring_name].chips
            if chips > card.ability.extra.threshold then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 247. Underflow
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_underflow',
    config = { extra = { threshold = 20, mult = 30 } },
    rarity = 1,
    atlas = 'j_glitch_underflow',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.threshold, extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local chips = G.GAME.hands[context.scoring_name].chips
            if chips < card.ability.extra.threshold then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 248. Clipping
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_clipping',
    config = { extra = {} },
    rarity = 1,
    atlas = 'j_glitch_clipping',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.hand.config.highlighted_limit = G.hand.config.highlighted_limit + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.hand.config.highlighted_limit = G.hand.config.highlighted_limit - 1
    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            if #context.full_hand > 5 then
                local rightmost = context.full_hand[#context.full_hand]
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function() 
                        draw_card(G.play, G.discard, 90, 'down', nil, rightmost)
                        return true 
                    end
                }))
                return {
                    message = 'Clipped!',
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 249. Corrupted
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_corrupted',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_glitch_corrupted',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        if context.before and not context.blueprint then
            local suits = {'Spades', 'Hearts', 'Clubs', 'Diamonds'}
            for k, v in ipairs(context.scoring_hand) do
                local new_suit = suits[pseudorandom('corrupted', 1, 4)]
                v:change_suit(new_suit)
            end
            return {
                message = 'Corrupted!',
                colour = G.C.PURPLE
            }
        end
    end
})

-- 250. MissingNo
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_missingno',
    config = { extra = { min = 1, max = 3 } },
    rarity = 1,
    atlas = 'j_glitch_missingno',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local xmult = card.ability.extra.min + (pseudorandom('missingno') * (card.ability.extra.max - card.ability.extra.min))
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { string.format("%.2f", xmult) } },
                Xmult_mod = xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 251. Blue Screen
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_blue_screen',
    config = { extra = { money = 4 } },
    rarity = 1,
    atlas = 'j_glitch_blue_screen',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.discard then
            if #context.full_hand == 5 then
                local suit = context.full_hand[1].base.suit
                local all_same = true
                for k, v in ipairs(context.full_hand) do
                    if v.base.suit ~= suit then all_same = false; break end
                end
                
                if all_same then
                    ease_dollars(card.ability.extra.money)
                    return {
                        message = localize('$')..card.ability.extra.money,
                        colour = G.C.MONEY,
                        card = card
                    }
                end
            end
        end
    end
})

-- 252. Error 404
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_error_404',
    config = { extra = { chips = 40, mult = 40 } },
    rarity = 1,
    atlas = 'j_glitch_error_404',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if context.scoring_name == 'High Card' then
                return {
                    message = localize('k_val_up'),
                    chip_mod = card.ability.extra.chips,
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- 253. Infinite Loop
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_infinite_loop',
    loc_txt = {
        name = "Infinite Loop",
        text = {
            "{C:mult}+5{} Mult.",
            "Increases by {C:mult}+1{} Mult",
            "each time it triggers in a round",
            "{C:inactive}(Currently {C:mult}+#1#{}{C:inactive} Mult){}"
        }
    },
    config = { extra = { mult = 5, gain = 1, current = 5 } },
    rarity = 1,
    atlas = 'j_glitch_infinite_loop',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.current } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local current = card.ability.extra.current
            card.ability.extra.current = current + card.ability.extra.gain
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { current } },
                mult_mod = current,
                colour = G.C.MULT
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current = card.ability.extra.mult
        end
    end
})

-- 254. Stack Overflow
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_stack_overflow',
    loc_txt = {
        name = "Stack Overflow",
        text = {
            "{C:mult}+4{} Mult for each",
            "card in your {C:attention}hand{}"
        }
    },
    config = { extra = { mult_per_card = 4 } },
    rarity = 1,
    atlas = 'j_glitch_stack_overflow',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult_per_card } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local cards_in_hand = #G.hand.cards
            local mult = cards_in_hand * card.ability.extra.mult_per_card
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                mult_mod = mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 255. Memory Leak
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_memory_leak',
    loc_txt = {
        name = "Memory Leak",
        text = {
            "{C:mult}+20{} Mult.",
            "{C:red}-1{} Discard"
        }
    },
    config = { extra = { mult = 20 } },
    rarity = 1,
    atlas = 'j_glitch_memory_leak',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + 1
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 256. Patch
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_patch',
    loc_txt = {
        name = "Patch",
        text = {
            "{C:mult}+10{} Mult for each",
            "{C:attention}debuffed Joker{} you have"
        }
    },
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_glitch_patch',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local debuffed_count = 0
            for k, v in ipairs(G.jokers.cards) do
                if v.debuff then debuffed_count = debuffed_count + 1 end
            end
            
            if debuffed_count > 0 then
                local mult = debuffed_count * card.ability.extra.mult
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                    mult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})


local local_jokers = {
    {
        key = 'j_glitch_exploit',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_exploit',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main and context.scoring_hand then
                local debuffed_found = false
                for _, other_card in ipairs(context.scoring_hand) do
                    if other_card.debuff then
                        debuffed_found = true
                        break
                    end
                end
                
                if debuffed_found then
                    return {
                        message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}},
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_debug_mode',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_debug_mode',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 10 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_glitch_god_mode',
        rarity = 2,
        cost = 8,
        atlas = 'j_glitch_god_mode',
        pos = { x = 0, y = 0 },
        config = {},
        blueprint_compat = false,
        calculate = function(self, card, context)
            if context.game_over and (not context.repetition) and not context.blueprint then
                if G.GAME.chips / G.GAME.blind.chips < 1 then
                    return {
                        message = localize('k_saved_ex'),
                        saved = true,
                        colour = G.C.RED,
                        func = function() 
                            G.E_MANAGER:add_event(Event({
                                func = function()
                                    play_sound('tarot1')
                                    card.T.r = -0.2
                                    card:juice_up(0.3, 0.4)
                                    card.states.drag.is = true
                                    card.children.center.pinch.x = true
                                    G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.3, blockable = false,
                                        func = function()
                                            G.jokers:remove_card(card)
                                            card:remove()
                                            card = nil
                                            return true; 
                                        end
                                    })) 
                                    return true
                                end
                            }))
                        end
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_noclip',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_noclip',
        pos = { x = 0, y = 0 },
        blueprint_compat = false,
        config = {},
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_noclip = (G.GAME.modifiers.odyssey_noclip or 0) + 1
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_noclip = (G.GAME.modifiers.odyssey_noclip or 0) - 1
        end
    },
    {
        key = 'j_glitch_speedrun',
        rarity = 2,
        cost = 5,
        atlas = 'j_glitch_speedrun',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 50 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main and G.GAME.current_round.hands_played == 0 then
                return {
                    message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_glitch_softlock',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_softlock',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 3 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if G.GAME.current_round.discards_left == 0 and G.GAME.dollars <= 0 then
                    return {
                        message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}},
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_duplication_glitch',
        rarity = 2,
        cost = 7,
        atlas = 'j_glitch_duplication_glitch',
        pos = { x = 0, y = 0 },
        config = { extra = { odds = 5 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { G.GAME.probabilities.normal, extra.odds } }

        end,
        calculate = function(self, card, context)
            if context.cardarea == G.jokers and context.before and not context.blueprint then
                if context.scoring_hand then
                    local triggered = false
                    for i = 1, #context.scoring_hand do
                        if pseudorandom('duplication_glitch') < G.GAME.probabilities.normal / card.ability.extra.odds then
                            triggered = true
                            local shop_card = context.scoring_hand[i]
                            G.E_MANAGER:add_event(Event({
                                func = function()
                                    local _card = copy_card(shop_card, nil, nil, G.playing_card, nil)
                                    _card:add_to_deck()
                                    G.deck.config.card_limit = G.deck.config.card_limit + 1
                                    table.insert(G.playing_cards, _card)
                                    G.hand:emplace(_card)
                                    _card:start_materialize()
                                    return true
                                end
                            }))
                        end
                    end
                    if triggered then
                        return {
                            message = localize('k_copied_ex'),
                            colour = G.C.CHIPS,
                            card = card
                        }
                    end
                end
            end
        end
    },
    {
        key = 'j_glitch_source_code',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_source_code',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 20 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)
            info_queue[#info_queue+1] = G.P_CENTERS.m_odyssey_emerald
            return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult } }
        end,
        calculate = function(self, card, context)
            if context.setting_blind and not context.blueprint then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = create_card('Default', G.hand, nil, nil, nil, nil, 'm_odyssey_emerald', 'odyssey_source_code')
                        _card:add_to_deck()
                        G.deck.config.card_limit = G.deck.config.card_limit + 1
                        table.insert(G.playing_cards, _card)
                        G.hand:emplace(_card)
                        _card:start_materialize()
                        return true
                    end
                }))
                return {
                    message = localize('k_active_ex'),
                    colour = G.C.FILTER
                }
            end
            
            if context.joker_main then
                local stone_found = false
                if G.hand and G.hand.cards then
                    for _, c in ipairs(G.hand.cards) do
                        if c.config.center == G.P_CENTERS.m_odyssey_emerald then
                            stone_found = true
                            break
                        end
                    end
                end
                
                if stone_found then
                    return {
                        message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}},
                        mult_mod = card.ability.extra.mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_hacker',
        rarity = 2,
        cost = 7,
        atlas = 'j_glitch_hacker',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 1.5 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}},
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
            
            if context.before and context.scoring_name then
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = localize('k_level_up_ex')})
                update_hand_text({sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3}, {handname=context.scoring_name,level=G.GAME.hands[context.scoring_name].level})
                level_up_hand(context.blueprint_card or card, context.scoring_name, true, 1)        
            end

            if context.after and context.scoring_name and not context.blueprint then
                level_up_hand(card, context.scoring_name, true, -1)
                update_hand_text({sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3}, {handname=context.scoring_name,level=G.GAME.hands[context.scoring_name].level})
            end 
        end
    },
    {
        key = 'j_glitch_firewall',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_firewall',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main and G.GAME.blind.boss then
                return {
                    message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}},
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_glitch_virus',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_virus',
        pos = { x = 0, y = 0 },
        config = {},
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.before and not context.blueprint then
                if context.scoring_hand and #context.scoring_hand > 0 and G.hand.cards and #G.hand.cards > 0 then
                    local target_suit = context.scoring_hand[1].base.suit
                    local random_card = pseudorandom_element(G.hand.cards, pseudorandom('virus'))
                    
                    random_card:change_suit(target_suit)
                    card:juice_up()
                    
                    return {
                        message = localize('k_active_ex'),
                        colour = G.C.RED,
                        card = card
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_trojan',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_trojan',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 4,  x_mult = 3, rounds_remaining = 3 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, 3, extra.x_mult, extra.rounds_remaining } }

        end,
        calculate = function(self, card, context)
            if context.end_of_round and not context.repetition and not context.other_card then
                if card.ability.extra.rounds_remaining > 0 then
                    card.ability.extra.rounds_remaining = card.ability.extra.rounds_remaining - 1
                    return {
                        message = card.ability.extra.rounds_remaining .. '',
                        colour = G.C.FILTER
                    }
                else
                    return {
                        message = localize('k_active_ex'),
                        colour = G.C.FILTER
                    }
                end
            end
            
            if context.joker_main then
                if card.ability.extra.rounds_remaining > 0 then
                    return {
                        message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}},
                        mult_mod = card.ability.extra.mult,
                        colour = G.C.MULT
                    }
                else
                    return {
                        message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}},
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_phishing',
        rarity = 2,
        cost = 5,
        atlas = 'j_glitch_phishing',
        pos = { x = 0, y = 0 },
        config = { extra = { odds = 3, dollars = 1 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { G.GAME.probabilities.normal, extra.odds, extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.discard and not context.blueprint then
                if context.other_card and context.other_card:is_face() then
                     if pseudorandom('phishing') < G.GAME.probabilities.normal / card.ability.extra.odds then
                        ease_dollars(card.ability.extra.dollars)
                        return {
                            message = localize('$')..card.ability.extra.dollars,
                            colour = G.C.MONEY,
                            card = card
                        }
                     end
                end
            end
        end
    },
    {
        key = 'j_glitch_zero_day',
        rarity = 2,
        cost = 5,
        atlas = 'j_glitch_zero_day',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2.5 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                -- first hand of FIRST ante
                if G.GAME.round_resets.ante == 1 and G.GAME.current_round.hands_played == 0 then
                    return {
                        message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}},
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    } 
                end
            end
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end


local local_jokers = {
    {
        key = 'j_glitch_game_breaker',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_game_breaker',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = false,
        add_to_deck = function(self, card, from_debuff)
            G.jokers.config.card_limit = G.jokers.config.card_limit + 1
            G.hand.config.card_limit = G.hand.config.card_limit - 2
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.jokers.config.card_limit = G.jokers.config.card_limit - 1
            G.hand.config.card_limit = G.hand.config.card_limit + 2
        end
    },
    {
        key = 'j_glitch_kill_screen',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_kill_screen',
        pos = { x = 0, y = 0 },
        config = { extra = { threshold = 1000000, money = 20 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.money, extra.threshold } }

        end,
        calculate = function(self, card, context)
            if context.end_of_round and not context.repetition and not context.other_card then
                if G.GAME.blind.chips >= card.ability.extra.threshold then
                    ease_dollars(card.ability.extra.money)
                    return {
                        message = localize('$')..card.ability.extra.money,
                        colour = G.C.MONEY
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_matrix_glitch',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_matrix_glitch',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.repetition then
                if context.cardarea == G.play then
                    return {
                        message = localize('k_again_ex'),
                        repetitions = 1,
                        card = context.other_card
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_overwrite',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_overwrite',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = false,
        calculate = function(self, card, context)
            if context.selling_card and context.card.edition and context.card ~= card then
                card:set_edition(context.card.edition, true)
                return {
                    message = 'Overwritten!',
                    colour = G.C.RED
                }
            end
        end
    },
    {
        key = 'j_glitch_hex_editor',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_hex_editor',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.discard and not context.blueprint then
                if context.other_card then
                    local ranks = {'2','3','4','5','6','7','8','9','10','J','Q','K','A'}
                    local suits = {Spades = 'S', Hearts = 'H', Clubs = 'C', Diamonds = 'D'}
                    local suit_names = {'Spades','Hearts','Clubs','Diamonds'}
                    local new_rank = pseudorandom_element(ranks, pseudorandom('hex_editor_rank'))
                    local new_suit_name = pseudorandom_element(suit_names, pseudorandom('hex_editor_suit'))
                    local new_suit = suits[new_suit_name]
                    context.other_card:set_base(G.P_CARDS[new_suit..'_'..new_rank])
                    return {
                        message = 'Edited!',
                        colour = G.C.PURPLE,
                        card = card
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_corruption',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_corruption',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 1.5, odds = 10 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local mult = 1
                for k, v in ipairs(G.jokers.cards) do
                    if v ~= card then
                        mult = mult * card.ability.extra.x_mult
                    end
                end
                if mult > 1 then
                    return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { mult } },
                        Xmult_mod = mult,
                        colour = G.C.MULT
                    }
                end
            end
            if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
                for k, v in ipairs(G.jokers.cards) do
                    if v ~= card and pseudorandom('corruption') < G.GAME.probabilities.normal / card.ability.extra.odds then
                        v:start_dissolve()
                    end
                end
            end
        end
    },
    {
        key = 'j_glitch_segfault',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_segfault',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 5 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if context.full_hand and #context.full_hand > 5 then
                    return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_root_access',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_root_access',
        pos = { x = 0, y = 0 },
        config = { extra = { bonus_slots = 5 } },
        blueprint_compat = false,
        add_to_deck = function(self, card, from_debuff)
            G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra.bonus_slots
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.consumeables.config.card_limit = G.consumeables.config.card_limit - card.ability.extra.bonus_slots
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end

local local_jokers = {
    {
        key = 'j_glitch_the_architect',
        rarity = 4,
        cost = 20,
        atlas = 'j_glitch_the_architect',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end,
        update = function(self, card, dt)
            if G.GAME and G.GAME.current_round then
                G.GAME.current_round.reroll_cost = 0
            end
        end
    },
    {
        key = 'j_glitch_digital_singularity',
        rarity = 4,
        cost = 20,
        atlas = 'j_glitch_digital_singularity',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 5, gain = 1 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)
            local count = 0
            if G.jokers then
                for k, v in ipairs(G.jokers.cards) do
                    if v ~= card and v.config.center.key and string.find(v.config.center.key, 'j_glitch_') then
                        count = count + 1
                    end
                end
            end
            return { vars = { card.ability.extra.x_mult, card.ability.extra.gain, card.ability.extra.x_mult + (count * card.ability.extra.gain) } }
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local count = 0
                for k, v in ipairs(G.jokers.cards) do
                    if v ~= card and v.config.center.key and string.find(v.config.center.key, 'j_glitch_') then
                        count = count + 1
                    end
                end
                local total_xmult = card.ability.extra.x_mult + (count * card.ability.extra.gain)
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { total_xmult } },
                    Xmult_mod = total_xmult,
                    colour = G.C.MULT
                }
            end
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end


local local_jokers = {
    {
        key = 'j_corruption_blood_pact',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_blood_pact',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 30, hands_lost = 1 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
            if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
                if G.GAME.round_resets.hands > 1 then
                    G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hands_lost
                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = '-1 Hand'})
                end
            end
        end
    },
    {
        key = 'j_corruption_sold_soul',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_sold_soul',
        pos = { x = 0, y = 0 },
        config = { extra = { chips = 100 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        add_to_deck = function(self, card, from_debuff)
            ease_dollars(-G.GAME.dollars, true)
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    },
    {
        key = 'j_corruption_cursed_blade',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_cursed_blade',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 15 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
            if context.after and not context.blueprint then
                if context.scoring_hand and #context.scoring_hand > 0 then
                    local target = context.scoring_hand[#context.scoring_hand]
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            target:start_dissolve()
                            return true
                        end
                    }))
                    return {
                        message = localize('k_destroyed'),
                        colour = G.C.RED
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_poisoned_chalice',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_poisoned_chalice',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2, dollars = 2 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
            if context.after and not context.blueprint then
                ease_dollars(-card.ability.extra.dollars)
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = '-$'..card.ability.extra.dollars, colour = G.C.MONEY})
            end
        end
    },
    {
        key = 'j_corruption_minor_sacrifice',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_minor_sacrifice',
        pos = { x = 0, y = 0 },
        config = { extra = { dollars = 3 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.discard and #context.full_hand == 1 and not context.blueprint then
                return {
                    message = localize('k_val_up'),
                    remove = true,
                    dollars = card.ability.extra.dollars
                }
            end
        end
    },
    {
        key = 'j_corruption_life_drain',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_life_drain',
        pos = { x = 0, y = 0 },
        config = { extra = { mult_per_hand = 10, hands_lost = 1 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult_per_hand } }

        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hands_lost
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra.hands_lost
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local hands_left = G.GAME.current_round.hands_left
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { hands_left * card.ability.extra.mult_per_hand } },
                    mult_mod = hands_left * card.ability.extra.mult_per_hand,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_corruption_parasite',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_parasite',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 5 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local other_jokers = 0
                if G.jokers then
                    for k, v in pairs(G.jokers.cards) do
                        if v ~= card then other_jokers = other_jokers + 1 end
                    end
                end
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { other_jokers * card.ability.extra.mult } },
                    mult_mod = other_jokers * card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end,
        update = function(self, card, dt)
            if G.jokers then
                for k, v in pairs(G.jokers.cards) do
                    if v ~= card and not v.debuff then
                        v.debuff = true
                    end
                end
            end
        end,
        remove_from_deck = function(self, card, from_debuff)
            if G.jokers then
                for k, v in pairs(G.jokers.cards) do
                    if v ~= card then
                        v.debuff = false
                    end
                end
            end
        end
    },
    {
        key = 'j_corruption_decomposition',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_decomposition',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 0, gain = 5 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.gain } }

        end,
        calculate = function(self, card, context)
            if context.discard and not context.blueprint then
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
                return {
                    message = localize('k_val_up'),
                    colour = G.C.MULT,
                    remove = true
                }
            end
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_corruption_rust',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_rust',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 1.5, odds = 6 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds } }

        end,
        calculate = function(self, card, context)
            if context.individual and context.cardarea == G.play then
                if context.other_card.ability.effect == 'Steel Card' then
                    return {
                        x_mult = card.ability.extra.x_mult,
                        card = card
                    }
                end
            end
            if context.after and not context.blueprint then
                for _, other_card in ipairs(context.scoring_hand) do
                    if other_card.ability.effect == 'Steel Card' then
                         if pseudorandom('rust') < G.GAME.probabilities.normal / card.ability.extra.odds then
                            if not other_card.ability.eternal then other_card:start_dissolve() end
                            card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_shattered')})
                         end
                    end
                end
            end
        end
    },
    {
        key = 'j_corruption_noxious_spores',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_noxious_spores',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 20 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)
            info_queue[#info_queue+1] = G.P_CENTERS.m_odyssey_emerald
            return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult } }
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
            if context.before and not context.blueprint then
                for k, v in ipairs(context.scoring_hand) do
                    v:set_ability(G.P_CENTERS.m_odyssey_emerald, nil, true)
                end
            end
        end
    },
    {
        key = 'j_corruption_contamination',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_contamination',
        pos = { x = 0, y = 0 },
        config = { extra = { chips = 10 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
            if context.after and not context.blueprint then
                for k, v in ipairs(context.scoring_hand) do
                    v:change_suit('Spades')
                end
            end
        end
    },
    {
        key = 'j_corruption_necrosis',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_necrosis',
        pos = { x = 0, y = 0 },
        config = { extra = { face_pen = -10, num_bonus = 20 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.face_pen, extra.num_bonus } }

        end,
        calculate = function(self, card, context)
            if context.individual and context.cardarea == G.play then
                if context.other_card:is_face() then
                    return {
                        chips = card.ability.extra.face_pen,
                        card = card
                    }
                else
                    return {
                        chips = card.ability.extra.num_bonus,
                        card = card
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_plague',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_plague',
        pos = { x = 0, y = 0 },
        config = { extra = { odds = 3 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { G.GAME.probabilities.normal, extra.odds } }

        end,
        calculate = function(self, card, context)
            if context.discard and not context.blueprint then
                if pseudorandom('plague') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    return {
                        remove = true,
                        message = localize('k_destroyed')
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_rotten_hand',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_rotten_hand',
        pos = { x = 0, y = 0 },
        config = { extra = { dollars = 10 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.before and not context.blueprint then
                if G.GAME.last_hand_played == context.scoring_name then
                    ease_dollars(card.ability.extra.dollars)
                end
            end
            if context.joker_main then
                 if G.GAME.last_hand_played == context.scoring_name then
                     return {
                         message = localize('k_nope_ex'),
                         Xmult_mod = 0,
                         colour = G.C.RED
                     }
                 end
            end
        end
    },
    {
        key = 'j_corruption_dark_heart',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_dark_heart',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 15 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local has_hearts = false
                for k, v in pairs(G.playing_cards) do
                    if v.base.suit == 'Hearts' then has_hearts = true break end
                end
                if not has_hearts then
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                        mult_mod = card.ability.extra.mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_corrupted_mind',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_corrupted_mind',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 25, hand_size = -1 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.hand_size } }

        end,
        add_to_deck = function(self, card, from_debuff)
            G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end


local local_jokers = {
    {
        key = 'j_corruption_cannibalism',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_cannibalism',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 3, active = false } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.setting_blind and not context.blueprint then
                local destroyable_jokers = {}
                if G.jokers then
                    for k, v in pairs(G.jokers.cards) do
                        if v ~= card and not v.ability.eternal then
                            table.insert(destroyable_jokers, v)
                        end
                    end
                end
                
                if #destroyable_jokers > 0 then
                    local joker_to_destroy = pseudorandom_element(destroyable_jokers, pseudorandom('cannibalism'))
                    joker_to_destroy:start_dissolve(nil, true)
                    card.ability.extra.active = true
                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_active_ex')})
                else
                    card.ability.extra.active = false
                end
            end
            if context.joker_main and card.ability.extra.active then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
            if context.end_of_round and not context.repetition and not context.other_card then
                card.ability.extra.active = false
            end
        end
    },
    {
        key = 'j_corruption_vampirism',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_vampirism',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 0, gain = 2 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.gain } }

        end,
        calculate = function(self, card, context)
            if context.before and not context.blueprint then
                for k, v in ipairs(context.scoring_hand) do
                    if v.config.center ~= G.P_CENTERS.c_base then
                        v:set_ability(G.P_CENTERS.c_base, nil, true)
                        card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
                        card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_upgrade_ex')})
                    end
                end
            end
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_corruption_necromancy',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_necromancy',
        pos = { x = 0, y = 0 },
        config = { extra = { triggered_this_round = false } },
        blueprint_compat = false,
        eternal_compat = true,
        calculate = function(self, card, context)
            if context.destroying_card and not context.blueprint then
                    if not card.ability.extra.triggered_this_round then
                        local destroyed_card = context.destroying_card
                        G.E_MANAGER:add_event(Event({
                            trigger = 'after',
                            delay = 0.4,
                            func = function()
                                G.playing_card = (G.playing_card or 0) + 1
                                local _card = copy_card(destroyed_card, nil, nil, G.playing_card)
                                _card:add_to_deck()
                                G.deck.config.card_limit = G.deck.config.card_limit + 1
                                table.insert(G.playing_cards, _card)
                                G.hand:emplace(_card)
                                return true
                            end
                        }))
                        card.ability.extra.triggered_this_round = true
                        return {
                            message = localize('k_saved'),
                            colour = G.C.GREEN
                        }
                    end
            end
            if context.end_of_round and not context.repetition and not context.other_card then
                card.ability.extra.triggered_this_round = false
            end
        end
    },
    {
        key = 'j_corruption_offering',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_offering',
        pos = { x = 0, y = 0 },
        config = { extra = { dollars = 50 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.discard and not context.blueprint then
                if #context.full_hand == 5 then
                    local suits = {}
                    local ranks = {}
                    for _, c in ipairs(context.full_hand) do
                        suits[c.base.suit] = (suits[c.base.suit] or 0) + 1
                        ranks[c.base.id] = (ranks[c.base.id] or 0) + 1
                    end
                    local is_flush = false
                    for s, count in pairs(suits) do
                        if count == 5 then is_flush = true break end
                    end
                    local is_royal = ranks[10] and ranks[11] and ranks[12] and ranks[13] and ranks[14]
                    
                    if is_flush and is_royal then
                        ease_dollars(card.ability.extra.dollars)
                        return {
                            message = localize('k_val_up'),
                            colour = G.C.MONEY
                        }
                    end
                end
            end
        end
    },
    {
        key = 'j_corruption_curse_of_gold',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_curse_of_gold',
        pos = { x = 0, y = 0 },
        config = { extra = { dollars = 1 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.individual and context.cardarea == G.play then
                ease_dollars(card.ability.extra.dollars)
                context.other_card.ability.perma_bonus = 0 
                return {
                    chips = -context.other_card.base.nominal, 
                    card = card
                }
            end
        end
    },
    {
        key = 'j_corruption_void_whispers',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_void_whispers',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2.5, threshold = 20 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.threshold } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if #G.playing_cards < card.ability.extra.threshold then
                    return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_mark_of_the_beast',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_mark_of_the_beast',
        pos = { x = 0, y = 0 },
        config = { extra = { chips = 666, hands_mod = 0 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        add_to_deck = function(self, card, from_debuff)
            card.ability.extra.hands_mod = G.GAME.round_resets.hands - 1
            G.GAME.round_resets.hands = 1
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.round_resets.hands = G.GAME.round_resets.hands + (card.ability.extra.hands_mod or 0)
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    },
    {
        key = 'j_corruption_soul_corruption',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_soul_corruption',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = false,
        eternal_compat = true,
        update = function(self, card, dt)
            if G.consumeables then
                for k, v in pairs(G.consumeables.cards) do
                    if v.config.center.set == 'Tarot' then
                        local spectral = pseudorandom_element(G.P_CENTER_POOLS.Spectral, pseudorandom('soul_corruption'))
                        v:set_ability(spectral)
                        v:set_edition(nil, true)
                    end
                end
            end
        end
    },
    {
        key = 'j_corruption_decadence',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_decadence',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 4, loss = 1 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.loss } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local current_ante = G.GAME.round_resets.ante
                local mult = math.max(1, card.ability.extra.x_mult - (current_ante - 1) * card.ability.extra.loss)
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { mult } },
                    Xmult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_corruption_toxin',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_toxin',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 50 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
            if context.after and not context.blueprint then
                for k, v in ipairs(context.scoring_hand) do
                    v.ability.perma_debuff = true
                    v:set_debuff(true)
                end
            end
        end
    },
    {
        key = 'j_corruption_mutation',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_mutation',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 15 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
            if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
                local random_card = pseudorandom_element(G.playing_cards, pseudorandom('mutation'))
                local new_rank = pseudorandom_element({'2','3','4','5','6','7','8','9','10','J','Q','K','A'}, pseudorandom('mutation_rank'))
                local new_suit = pseudorandom_element({'Spades','Hearts','Clubs','Diamonds'}, pseudorandom('mutation_suit'))
                
                assert(SMODS.change_base(random_card, new_suit, new_rank))
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_reset'), colour = G.C.PURPLE})
            end
        end
    },
    {
        key = 'j_corruption_scar',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_scar',
        pos = { x = 0, y = 0 },
        config = { extra = { chips = 0 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        calculate = function(self, card, context)
            if context.destroying_card and not context.blueprint then
                card.ability.extra.chips = (card.ability.extra.chips or 0) + 10
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.CHIPS
                }
            end
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    },
    {
        key = 'j_corruption_slow_poison',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_slow_poison',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 3, limit = 3 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.limit } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
            if context.after and not context.blueprint then
                if G.GAME.current_round.hands_played >= card.ability.extra.limit and G.GAME.chips < G.GAME.blind.chips then
                    G.STATE = G.STATES.GAME_OVER
                    G.STATE_COMPLETE = false
                    return {
                        message = localize('k_game_over'),
                        colour = G.C.RED
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_grim_harvest',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_grim_harvest',
        pos = { x = 0, y = 0 },
        config = { extra = { dollars = 0 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.destroying_card and not context.blueprint then
                card.ability.extra.dollars = card.ability.extra.dollars + 1
            end
            if context.end_of_round and not context.repetition and not context.other_card then
                local gain = card.ability.extra.dollars
                card.ability.extra.dollars = 0
                ease_dollars(gain)
                return {
                    message = localize{ type = 'variable', key = 'a_dollars', vars = { gain } },
                    colour = G.C.MONEY
                }
            end
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end

local local_jokers = {
    {
        key = 'j_corruption_pestilence',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_pestilence',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = true,
        eternal_compat = true,
        calculate = function(self, card, context)
            if context.before and not context.blueprint then
                local text, poker_hands, scoring_hand = G.FUNCS.get_poker_hand_info(G.play.cards)
                if text == 'Flush' then
                    local suit = scoring_hand[1].base.suit
                    for k, v in ipairs(G.hand.cards) do
                        v:change_suit(suit)
                    end
                    return {
                        message = localize('k_infected'),
                        colour = G.C.PURPLE
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_famine',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_famine',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 5, hand_size_mod = -5 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.hand_size_mod } }

        end,
        add_to_deck = function(self, card, from_debuff)
            G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size_mod
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size_mod
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_corruption_war',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_war',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 0, gain = 10 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.gain } }

        end,
        calculate = function(self, card, context)
            if context.after and not context.blueprint then
                local destroyed_cards = {}
                for k, v in ipairs(G.hand.cards) do
                    if not v.ability.eternal then
                        destroyed_cards[#destroyed_cards+1] = v
                    end
                end
                if #destroyed_cards > 0 then
                    for _, v in ipairs(destroyed_cards) do
                        v:start_dissolve(nil, true)
                    end
                    card.ability.extra.mult = card.ability.extra.mult + (#destroyed_cards * card.ability.extra.gain)
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                        colour = G.C.RED
                    }
                end
            end
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
            if context.end_of_round and not context.repetition and not context.other_card then
                card.ability.extra.mult = 0
                return {
                    message = localize('k_reset'),
                    colour = G.C.RED
                }
            end
        end
    },
    {
        key = 'j_corruption_death',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_death',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = false,
        eternal_compat = true,
        calculate = function(self, card, context)
            if context.after and not context.blueprint then
                if G.GAME.current_round.hands_left == 0 then
                    G.E_MANAGER:add_event(Event({
                        trigger = 'immediate',
                        func = function()
                            for k, v in ipairs(G.playing_cards) do
                                v:set_ability(G.P_CENTERS.m_odyssey_plastic, nil, true)
                            end
                            G.GAME.chips = G.GAME.blind.chips
                            return true
                        end
                    }))
                    return {
                        message = localize('k_death_win'),
                        colour = G.C.BLACK
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_apocalypse',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_apocalypse',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 1, gain = 10 } },
        blueprint_compat = false,
        eternal_compat = true,
        calculate = function(self, card, context)
            if context.selling_self and not context.blueprint then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        for k, v in pairs(G.jokers.cards) do
                            if v ~= card and not v.ability.eternal then
                                v:start_dissolve(nil, true)
                            end
                        end
                        local token = create_card('Joker', G.jokers, nil, nil, nil, nil, 'j_corruption_post_apocalypse')
                        token:add_to_deck()
                        G.jokers:emplace(token)
                        return true
                    end
                }))
            end
        end
    },
    {
        key = 'j_corruption_entropy',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_entropy',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = true,
        eternal_compat = true,
        calculate = function(self, card, context)
            if context.after and not context.blueprint then
                for k, v in ipairs(G.hand.cards) do
                    local new_rank = pseudorandom_element({'2','3','4','5','6','7','8','9','10','J','Q','K','A'}, pseudorandom('entropy_rank'))
                    local new_suit = pseudorandom_element({'Spades','Hearts','Clubs','Diamonds'}, pseudorandom('entropy_suit'))
                    v:set_base(G.P_CARDS[new_suit..'_'..new_rank])
                end
                return {
                    message = localize('k_chaos'),
                    colour = G.C.RED
                }
            end
        end
    },
    {
        key = 'j_corruption_absolute_chaos',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_absolute_chaos',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local suits = {}
                local unique_suits = 0
                for k, v in ipairs(context.scoring_hand) do
                    if not suits[v.base.suit] then
                        suits[v.base.suit] = true
                        unique_suits = unique_suits + 1
                    end
                end
                if unique_suits > 0 then
                    local mult = card.ability.extra.x_mult ^ unique_suits
                    return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { mult } },
                        x_mult_mod = mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_the_end',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_the_end',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 100 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if G.GAME.current_round.hands_left == 1 and G.GAME.current_round.discards_left == 0 then
                        return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                        x_mult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_post_apocalypse',
        rarity = 1,
        cost = 0,
        atlas = 'j_corruption_apocalypse',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 10 } },
        blueprint_compat = true,
        eternal_compat = true,
        yes_pool_flag = 'post_apocalypse_token',
        in_pool = function() return false end,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end


local local_jokers = {
    {
        key = 'j_corruption_world_eater',
        rarity = 4,
        cost = 20,
        atlas = 'j_corruption_world_eater',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 1, gain = 0.5 } },
        blueprint_compat = false,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.gain } }

        end,
        calculate = function(self, card, context)
            if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
                local destroyed_count = 0
                if G.playing_cards then
                    for k, v in pairs(G.playing_cards) do
                        if not v.ability.eternal then
                            v:start_dissolve(nil, true)
                            destroyed_count = destroyed_count + 1
                        end
                    end
                end
                
                if destroyed_count > 0 then
                    card.ability.extra.x_mult = card.ability.extra.x_mult + (destroyed_count * card.ability.extra.gain)
                    return {
                        message = localize('k_upgrade_ex'),
                        colour = G.C.RED
                    }
                end
            end
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_corruption_the_entity',
        rarity = 4,
        cost = 20,
        atlas = 'j_corruption_the_entity',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = false,
        eternal_compat = true,
        calculate = function(self, card, context)
            if context.blueprint then return end
            
            local ret = {}
            local triggered = false
            
            if G.jokers then
                for k, v in pairs(G.jokers.cards) do
                    if v ~= card and v.edition and v.edition.negative then
                        context.blueprint = true
                        context.blueprint_card = card
                        if v.ability.blueprint_compat then
                            local other_joker_ret = v:calculate_joker(context)
                            if other_joker_ret then
                                triggered = true
                                if other_joker_ret.mult_mod then
                                    ret.mult_mod = (ret.mult_mod or 0) + other_joker_ret.mult_mod
                                end
                                if other_joker_ret.chip_mod then
                                    ret.chip_mod = (ret.chip_mod or 0) + other_joker_ret.chip_mod
                                end
                                if other_joker_ret.x_mult_mod then
                                    ret.x_mult_mod = (ret.x_mult_mod or 1) * other_joker_ret.x_mult_mod
                                end
                                if other_joker_ret.message then
                                    ret.message = other_joker_ret.message
                                end
                                if other_joker_ret.colour then
                                    ret.colour = other_joker_ret.colour
                                end
                            end
                        end
                        context.blueprint = false
                        context.blueprint_card = nil
                    end
                end
            end
            
            if triggered then
                return ret
            end
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end


-- ============================================
-- PARADOX - Common (Jokers 321-336)
-- ============================================

-- 321. Menos é Mais (Less is More)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_less_is_more',
    atlas = 'j_paradox_less_is_more',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 20, max_cards = 3 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.max_cards } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and #context.full_hand < card.ability.extra.max_cards then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 322. Fraco é Forte (Weak is Strong)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_weak_is_strong',
    atlas = 'j_paradox_weak_is_strong',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 10 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local rank = context.other_card:get_id()
            if rank >= 2 and rank <= 4 then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 323. Perder para Ganhar (Lose to Win)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_lose_to_win',
    atlas = 'j_paradox_lose_to_win',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { dollars = 3 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.after and G.GAME.chips < (G.GAME.blind.chips * 0.1) then
            ease_dollars(card.ability.extra.dollars)
            return {
                message = localize('$')..card.ability.extra.dollars,
                colour = G.C.MONEY,
                card = card
            }
        end
    end
})

-- 324. Descarte Útil (Useful Discard)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_useful_discard',
    atlas = 'j_paradox_useful_discard',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { current_chips = 0, chip_gain = 2 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chip_gain, extra.current_chips } }

    end,
    calculate = function(self, card, context)
        if context.discard and not context.other_card and not context.blueprint then
            card.ability.extra.current_chips = card.ability.extra.current_chips + card.ability.extra.chip_gain
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.current_chips } },
                colour = G.C.CHIPS,
                card = card
            }
        end
        if context.joker_main and card.ability.extra.current_chips > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.current_chips } },
                chip_mod = card.ability.extra.current_chips,
                colour = G.C.CHIPS
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current_chips = 0
            return {
                message = localize('k_reset'),
                colour = G.C.RED
            }
        end
    end
})

-- 325. Mão Torta (Crooked Hand)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_crooked_hand',
    atlas = 'j_paradox_crooked_hand',
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 10 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if context.scoring_name == 'Flush' or context.scoring_name == 'Straight' or context.scoring_name == 'Straight Flush' then
                return nil
            end
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 326. Flush Reverso (Reverse Flush)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_reverse_flush',
    atlas = 'j_paradox_reverse_flush',
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    config = { extra = { x_mult = 2 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = { ['Spades'] = 0, ['Hearts'] = 0, ['Clubs'] = 0, ['Diamonds'] = 0 }
            local unique_suits = 0
            for _, v in ipairs(context.scoring_hand) do
                if suits[v.base.suit] == 0 then
                    suits[v.base.suit] = 1
                    unique_suits = unique_suits + 1
                end
            end
            
            if unique_suits >= 4 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 327. Par Ímpar (Odd Pair)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_odd_pair',
    atlas = 'j_paradox_odd_pair',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 15 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local is_odd_pair = false
            if context.poker_hands and context.poker_hands['Pair'] and #context.poker_hands['Pair'] > 0 then
                for _, p in ipairs(context.poker_hands['Pair']) do
                    local rank = p[1]:get_id()
                    if rank % 2 ~= 0 then
                        is_odd_pair = true
                    end
                end
            end
            
            if is_odd_pair then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 328. Full House Vazio (Empty Full House)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_empty_full_house',
    atlas = 'j_paradox_empty_full_house',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 12 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and #context.full_hand == 5 and context.scoring_name ~= 'Full House' then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 329. High Low (High Low)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_high_low',
    atlas = 'j_paradox_high_low',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 15 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_2 = false
            local has_ace_or_king = false
            for _, v in ipairs(context.scoring_hand) do
                local id = v:get_id()
                if id == 2 then has_2 = true end
                if id == 13 or id == 14 then has_ace_or_king = true end
            end
            if has_2 and has_ace_or_king then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 330. Cego que Vê (Seeing Blind)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_seeing_blind',
    atlas = 'j_paradox_seeing_blind',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 15 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.blind.boss then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 331. Pobre Rico (Rich Poor)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_rich_poor',
    atlas = 'j_paradox_rich_poor',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { threshold = 10, per_dollar = 1 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.per_dollar, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.dollars < card.ability.extra.threshold then
            local diff = card.ability.extra.threshold - math.max(0, G.GAME.dollars)
            local bonus = diff * card.ability.extra.per_dollar
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { bonus } },
                mult_mod = bonus,
                colour = G.C.MULT
            }
        end
    end
})

-- 332. Lento Rápido (Slow Fast)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_slow_fast',
    atlas = 'j_paradox_slow_fast',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 10 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played == 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 333. Joker Pacifista (Pacifist Joker)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_pacifist_joker',
    atlas = 'j_paradox_pacifist_joker',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { x_mult = 1.2, active = false } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and card.ability.extra.active then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                x_mult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        if context.after and not context.blueprint then
            if G.GAME.chips < G.GAME.blind.chips then
                card.ability.extra.active = true
            else
                card.ability.extra.active = false
            end
        end
    end
})

-- 334. Paradoxo do Mentiroso (Liar's Paradox)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_liars_paradox',
    atlas = 'j_paradox_liars_paradox',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 20 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'High Card' then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 335. Inversão de Valor (Value Inversion)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_value_inversion',
    atlas = 'j_paradox_value_inversion',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { chip_mod = -10, ace_bonus = 20 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chip_mod, extra.ace_bonus } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_face() then
               return {
                   chips = card.ability.extra.chip_mod,
                   card = card
               }
            elseif context.other_card:get_id() == 14 then
                return {
                    chips = card.ability.extra.ace_bonus,
                    card = card
                }
            end
        end
    end
})

-- 336. Silêncio Ruidoso (Loud Silence)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_loud_silence',
    atlas = 'j_paradox_loud_silence',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { chips = 30 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local face = false
            for _, v in ipairs(context.scoring_hand) do
                if v:is_face() then face = true end
            end
            
            if not face then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- ============================================
-- PARADOX - Uncommon (Jokers 337-350)
-- ============================================

-- 337. Failure's Success
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_failures_success',
    config = { extra = { dollars = 10 } },
    rarity = 2,
    atlas = 'j_paradox_failures_success',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = false,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.game_over and not context.other_card then
            if G.GAME.chips < G.GAME.blind.chips then
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = localize('$') .. card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 338. Order of Chaos
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_order_of_chaos',
    config = { extra = { x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_paradox_order_of_chaos',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local is_straight = false
            if context.poker_hands and context.poker_hands['Straight'] and next(context.poker_hands['Straight']) then
                is_straight = true
            end
            
            if not is_straight then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 339. All or Nothing
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_all_or_nothing',
    config = { extra = { high_x_mult = 4, low_x_mult = 0.5, odds = 2 } },
    rarity = 2,
    atlas = 'j_paradox_all_or_nothing',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.high_x_mult, (G.GAME.probabilities.normal or 1), extra.odds, extra.low_x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('all_or_nothing') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.high_x_mult } },
                    x_mult_mod = card.ability.extra.high_x_mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.low_x_mult } },
                    x_mult_mod = card.ability.extra.low_x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 340. Zeno's Paradox
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_zenos_paradox',
    config = { extra = { x_mult = 8 } },
    rarity = 2,
    atlas = 'j_paradox_zenos_paradox',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                x_mult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        if context.after and not context.blueprint then
            if card.ability.extra.x_mult > 1 then
                card.ability.extra.x_mult = card.ability.extra.x_mult / 2
                return {
                    message = localize('k_lower'),
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 341. Alive and Dead Cat
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_alive_and_dead_cat',
    config = { extra = { x_mult = 5 } },
    rarity = 2,
    atlas = 'j_paradox_alive_and_dead_cat',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.current_round.discards_left == 0 and G.GAME.current_round.hands_left == 1 then -- This is the last hand
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 342. Beginning of the End
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_beginning_of_the_end',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_paradox_beginning_of_the_end',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_left == 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                x_mult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 343. Square Circle
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_square_circle',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_paradox_square_circle',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Logic handled in Card:is_suit override
    end
})

-- 344. Hot Cold
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_hot_cold',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_paradox_hot_cold',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Logic handled in Card:is_suit override
    end
})

-- 345. Past Future
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_past_future',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_paradox_past_future',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.odyssey_prev_round_1_hand then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 346. False Truth
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_false_truth',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_paradox_false_truth',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_ceramic then
                 return {
                     mult = card.ability.extra.mult,
                     card = card
                 }
            end
        end
    end
})

-- 347. Mortal Immortal
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_mortal_immortal',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_paradox_mortal_immortal',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_can_sell_eternal = true
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_can_sell_eternal = false
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Logic handled in overrides
    end
})

-- 348. Unlucky Luck
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_unlucky_luck',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_paradox_unlucky_luck',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_undead or
               context.other_card.config.center == G.P_CENTERS.m_odyssey_light or
               context.other_card.config.center == G.P_CENTERS.m_odyssey_magic then
                 return {
                     mult = card.ability.extra.mult,
                     card = card
                 }
            end
        end
    end
})

-- 349. Shrinking Growth
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_shrinking_growth',
    config = { extra = { mult = 50, loss = 2 } },
    rarity = 2,
    atlas = 'j_paradox_shrinking_growth',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.loss } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             return {
                 message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                 mult_mod = card.ability.extra.mult,
                 colour = G.C.MULT
             }
        end
        if context.end_of_round and not context.repetition and not context.game_over and not context.other_card then
            if card.ability.extra.mult > 0 then
                card.ability.extra.mult = math.max(0, card.ability.extra.mult - card.ability.extra.loss)
                return {
                    message = localize{ type = 'variable', key = 'a_mult_minus', vars = { card.ability.extra.loss } },
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 350. Polarity Reversal
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_polarity_reversal',
    config = { extra = { mult = 15, chips = 50 } },
    rarity = 2,
    atlas = 'j_paradox_polarity_reversal',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Spades') or context.other_card:is_suit('Clubs') then
                return {
                    mult = card.ability.extra.mult,
                    card = context.other_card
                }
            elseif context.other_card:is_suit('Hearts') or context.other_card:is_suit('Diamonds') then
                 return {
                    chips = card.ability.extra.chips,
                    card = context.other_card
                }
            end
        end
    end
})

-- local commons = require('src/jokers/33_paradox_common')

-- 351. Bootstrap Paradox
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_bootstrap_paradox',
    discovered = true,
    atlas = 'j_paradox_bootstrap_paradox',
    config = { extra = { x_mult = 1.5 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult
            }
        end
        
        -- Respawn logic: If end of round and we only have one, create another.
        if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
            local count = 0
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i].config.center.key == 'odyssey_j_paradox_bootstrap_paradox' then
                    count = count + 1
                end
            end
            
            if count < 2 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local card_copy = create_card('Joker', G.jokers, nil, nil, nil, nil, 'odyssey_j_paradox_bootstrap_paradox')
                        card_copy:add_to_deck()
                        G.jokers:emplace(card_copy)
                        card_copy:start_materialize()
                        play_sound('timpani')
                        return true
                    end
                }))
                return {
                    message = "Paradox!",
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 352. Chicken and Egg
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_chicken_egg',
    discovered = true,
    atlas = 'j_paradox_chicken_egg',
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
             if context.other_card == context.scoring_hand[1] then
                 return {
                     message = localize('k_again_ex'),
                     repetitions = 1,
                     card = card
                 }
             end
        end
    end
})

-- 353. Ship of Theseus
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_ship_of_theseus',
    discovered = true,
    atlas = 'j_paradox_ship_of_theseus',
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local clean_deck = true
            for k, v in pairs(G.playing_cards) do
                if v.config and v.config.center == G.P_CENTERS.c_base and not v.edition and not v.seal then
                    clean_deck = false
                    break
                end
            end
            
            if clean_deck then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end
        end
    end
})

-- 354. Fermi's Paradox
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_fermi_paradox',
    discovered = true,
    atlas = 'j_paradox_fermi_paradox',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.hands then
            local planets_used = false
            for k, v in pairs(G.GAME.hands) do
                if v.level > 1 then
                    planets_used = true
                    break
                end
            end
            
            if not planets_used then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end
        end
    end
})

-- 355. Evil Twin
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_evil_twin',
    discovered = true,
    atlas = 'j_paradox_evil_twin',
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local other_joker = nil
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then
                    other_joker = G.jokers.cards[i+1]
                    break
                end
            end
            
            if other_joker and other_joker ~= card then
                -- Protection against copying another Evil Twin or self
                if other_joker.config.center.key == 'odyssey_j_paradox_evil_twin' then return end

                context.blueprint = (context.blueprint or 0) + 1
                local ret = other_joker:calculate_joker(context)
                context.blueprint = (context.blueprint or 0) - 1
                
                if ret then
                    if ret.mult_mod then ret.mult_mod = -ret.mult_mod end
                    if ret.chip_mod then ret.chip_mod = -ret.chip_mod end
                    if ret.Xmult_mod then ret.Xmult_mod = 1 / ret.Xmult_mod end
                    ret.message = "Evil!"
                    ret.colour = G.C.BLACK
                    ret.card = card
                    return ret
                end
            end
        end
    end
})

-- 356. Anti-Joker
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_anti_joker',
    discovered = true,
    atlas = 'j_paradox_anti_joker',
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local t_chips = hand_chips
            local t_mult = mult
            
            -- Swap global values
            hand_chips = t_mult
            mult = t_chips
            
            update_hand_text({delay = 0}, {mult = mult, chips = hand_chips})
            
            return {
                message = "Swap!",
                colour = G.C.PURPLE,
                card = card
            }
        end
    end
})

-- 357. Reverse Logic
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_reverse_logic',
    discovered = true,
    atlas = 'j_paradox_reverse_logic',
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local current_hand = context.scoring_name
            local max_level = 0
            for k, v in pairs(G.GAME.hands) do
                if v.level > max_level then max_level = v.level end
            end
            
            local current_level = G.GAME.hands[current_hand].level
            if max_level > current_level then
                local diff = max_level - current_level
                local bonus_chips = G.GAME.hands[current_hand].l_chips * diff
                local bonus_mult = G.GAME.hands[current_hand].l_mult * diff
                
                return {
                     message = "Reverse!",
                     chip_mod = bonus_chips,
                     mult_mod = bonus_mult,
                     card = card
                }
            end
        end
    end
})

-- 358. Impossible
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_impossible',
    discovered = true,
    atlas = 'j_paradox_impossible',
    config = { extra = { x_mult = 100 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             local hand = context.scoring_hand
             if #hand == 5 then
                 local first_rank = hand[1].base.id
                 local same_rank = true
                 for i=2, 5 do
                     if hand[i].base.id ~= first_rank then
                         same_rank = false
                         break
                     end
                 end
                 
                 if same_rank then
                     local suits = {}
                     for i=1, 5 do
                         suits[hand[i].base.suit] = true
                     end
                     
                     local suit_count = 0
                     for k,v in pairs(suits) do suit_count = suit_count + 1 end
                     
                     if suit_count >= 5 then
                         return {
                             message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                             Xmult_mod = card.ability.extra.x_mult
                         }
                     end
                 end
             end
        end
    end
})

-- local commons = require('src/jokers/33_paradox_common')

-- 359. Ouroboros
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_ouroboros',
    discovered = true,
    atlas = 'j_paradox_ouroboros',
    config = { extra = { x_mult = 3 } },
    rarity = 4,
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult
            }
        end
        
        if context.end_of_round and not context.repetition and not context.blueprint and not context.other_card then
            if G.GAME.round_resets.ante >= 8 and G.GAME.blind.boss then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        if G.GAME.chips >= G.GAME.blind.chips then
                             -- Reset Ante to 1
                             G.GAME.round_resets.ante = 0 -- Becomes 1
                             G.GAME.round_resets.ante_scaling = (G.GAME.round_resets.ante_scaling or 1) * 1.5
                             play_sound('gold_seal', 1.2, 0.4)
                        end
                        return true
                    end
                }))
            end
        end
    end
})

-- 360. Grandfather Paradox
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_grandfather_paradox',
    discovered = true,
    atlas = 'j_paradox_grandfather_paradox',
    rarity = 4,
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.blueprint and not context.other_card then
            if G.GAME.chips < G.GAME.blind.chips then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        G.hand_text_area.blind_chips:juice_up()
                        G.hand_text_area.game_chips:juice_up()
                        play_sound('timpani')
                        return true
                    end
                })) 
                if not card.ability.eternal then card:start_dissolve() end
                return {
                    message = localize('k_saved_ex'),
                    saved = true,
                    colour = G.C.RED
                }
            end
        end
    end
})


local jokers = {
    -- 361. Spade Anomaly
    {
        key = 'j_anomaly_spade_anomaly',
        config = { extra = { mult = 10 } },
        rarity = 1,
        atlas = 'j_anomaly_spade_anomaly',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_spade_heart = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_spade_heart = nil
        end
    },
    -- 362. Heart Anomaly
    {
        key = 'j_anomaly_heart_anomaly',
        config = { extra = { mult = 10 } },
        rarity = 1,
        atlas = 'j_anomaly_heart_anomaly',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_heart_club = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_heart_club = nil
        end
    },
    -- 363. Club Anomaly
    {
        key = 'j_anomaly_club_anomaly',
        config = { extra = { mult = 10 } },
        rarity = 1,
        atlas = 'j_anomaly_club_anomaly',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_club_diamond = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_club_diamond = nil
        end
    },
    -- 364. Diamond Anomaly
    {
        key = 'j_anomaly_diamond_anomaly',
        config = { extra = { mult = 10 } },
        rarity = 1,
        atlas = 'j_anomaly_diamond_anomaly',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_diamond_spade = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_diamond_spade = nil
        end
    },
    -- 365. Rank Shift (Ases = 2s, 2s = Ases)
    {
        key = 'j_anomaly_rank_shift',
        config = { },
        rarity = 1,
        atlas = 'j_anomaly_rank_shift',
        cost = 4,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_rank_shift = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_rank_shift = nil
        end
    },
    -- 366. Numeric Inversion (Evens = Mult, Odds = Chips)
    {
        key = 'j_anomaly_numeric_inversion',
        config = { extra = { mult = 4, chips = 20 } },
        rarity = 1,
        atlas = 'j_anomaly_numeric_inversion',
        cost = 4,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.chips } }

        end,
        calculate = function(self, card, context)
            if context.individual and context.cardarea == G.play then
                if context.other_card:get_id() % 2 == 0 then
                    -- Even
                    return {
                        mult = card.ability.extra.mult,
                        card = card
                    }
                elseif context.other_card:get_id() % 2 ~= 0 then
                    -- Odd (includes Ace=14, Jack=11, King=13. Queen=12 is even)
                    return {
                        chips = card.ability.extra.chips,
                        card = card
                    }
                end
            end
        end
    },
    -- 367. Chromatic Anomaly
    {
        key = 'j_anomaly_chromatic_anomaly',
        config = { },
        rarity = 1,
        atlas = 'j_anomaly_chromatic_anomaly',
        cost = 6,
        add_to_deck = function(self, card, from_debuff)
            if not G.GAME.modifiers.odyssey_chromatic_rate then G.GAME.modifiers.odyssey_chromatic_rate = 1 end
            G.GAME.modifiers.odyssey_chromatic_rate = G.GAME.modifiers.odyssey_chromatic_rate + 2
        end,
        remove_from_deck = function(self, card, from_debuff)
            if G.GAME.modifiers.odyssey_chromatic_rate then
                G.GAME.modifiers.odyssey_chromatic_rate = G.GAME.modifiers.odyssey_chromatic_rate - 2
            end
        end
    },
    -- 368. Material Anomaly (Stone = Gold)
    {
        key = 'j_anomaly_material_anomaly',
        config = { extra = { money = 3 } },
        rarity = 1,
        atlas = 'j_anomaly_material_anomaly',
        cost = 5,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.money } }

        end,
        calculate = function(self, card, context)
            if context.individual and context.cardarea == G.play then
                if context.other_card.config.center == G.P_CENTERS.m_odyssey_emerald then
                    return {
                        dollars = card.ability.extra.money,
                        card = card
                    }
                end
            end
            -- Also Held
             if context.individual and context.end_of_round and context.cardarea == G.hand then
                 if context.other_card.config.center == G.P_CENTERS.m_odyssey_emerald then
                     return {
                         dollars = card.ability.extra.money,
                         card = card
                     }
                 end
             end
        end
    },
    -- 369. Anomalous Echo
    {
        key = 'j_anomaly_anomalous_echo',
        config = { },
        rarity = 1,
        atlas = 'j_anomaly_anomalous_echo',
        cost = 5,
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.repetition and context.cardarea == G.play then
                local scoring = context.scoring_hand
                if scoring and #scoring > 1 and context.other_card == scoring[#scoring] then
                    local first = scoring[1]
                    if not context.other_card:is_suit(first.base.suit) then
                        return {
                            message = localize('k_again_ex'),
                            repetitions = 1,
                            card = card
                        }
                    end
                end
            end
        end
    },
    -- 370. Phantom
    {
        key = 'j_anomaly_phantom',
        config = { extra = { mult = 20 } },
        rarity = 1,
        atlas = 'j_anomaly_phantom',
        cost = 6,
        blueprint_compat = true,
        eternal_compat = true,
        perishable_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        add_to_deck = function(self, card, from_debuff)
            if not from_debuff then
                G.jokers.config.card_limit = G.jokers.config.card_limit + 1
            end
        end,
        remove_from_deck = function(self, card, from_debuff)
            if not from_debuff then
                G.jokers.config.card_limit = G.jokers.config.card_limit - 1
            end
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    },
    -- 371. Instability
    {
        key = 'j_anomaly_instability',
        config = { extra = { mult = 15, current_suit = 'Spades' } },
        rarity = 1,
        atlas = 'j_anomaly_instability',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, localize(extra.current_suit, 'suits_singular') } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local has_suit = false
                for _, playing_card in ipairs(context.scoring_hand) do
                    if playing_card:is_suit(card.ability.extra.current_suit) then
                        has_suit = true
                        break
                    end
                end
                
                if has_suit then
                    return {
                        mult_mod = card.ability.extra.mult,
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                    }
                end
            end
            if context.end_of_round and not context.repetition and not context.other_card then
                local suits = {'Spades', 'Hearts', 'Clubs', 'Diamonds'}
                card.ability.extra.current_suit = suits[pseudorandom('instability') % 4 + 1]
                return {
                    message = localize(card.ability.extra.current_suit, 'suits_singular'),
                    colour = G.C.ORANGE
                }
            end
        end
    },
    -- 372. Distortion
    {
        key = 'j_anomaly_distortion',
        config = { extra = { chips = 50 } },
        rarity = 1,
        atlas = 'j_anomaly_distortion',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    },
    -- 373. Interference
    {
        key = 'j_anomaly_interference',
        config = { extra = { mult = 10, bonus = 20 } },
        rarity = 1,
        atlas = 'j_anomaly_interference',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.bonus } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local bonus = card.ability.extra.mult
                local has_another = false
                for k, v in pairs(G.jokers.cards) do
                    if v ~= card and v.config.center.key and string.find(v.config.center.key, 'anomaly') then
                        has_another = true
                        break 
                    end
                end
                if has_another then
                    bonus = bonus + card.ability.extra.bonus
                end
                return {
                    mult_mod = bonus,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { bonus } }
                }
            end
        end
    },
    -- 374. Static Noise
    {
        key = 'j_anomaly_static_noise',
        config = { extra = { money = 5, odds = 4 } },
        rarity = 1,
        atlas = 'j_anomaly_static_noise',
        cost = 4,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.money, (G.GAME and G.GAME.probabilities.normal or 1), extra.odds } }

        end,
        calculate = function(self, card, context)
            if context.end_of_round and not context.repetition and not context.other_card then
                if pseudorandom('static_noise') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    return {
                        dollars = card.ability.extra.money,
                        message = localize('$')..card.ability.extra.money,
                        colour = G.C.MONEY
                    }
                end
            end
        end
    },
    -- 375. Lost Signal
    {
        key = 'j_anomaly_lost_signal',
        config = { extra = { hands = 1 } },
        rarity = 1,
        atlas = 'j_anomaly_lost_signal',
        cost = 6,
        blueprint_compat = false,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.hands } }

        end,
        calculate = function(self, card, context)
            if context.discard and not context.blueprint then
                if #context.full_hand == 5 then
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            ease_hands_played(card.ability.extra.hands)
                            return true
                        end
                    }))
                    return {
                        message = localize('k_upgrade_ex'),
                        colour = G.C.BLUE
                    }
                end
            end
        end
    },
    -- 376. Audio Glitch
    {
        key = 'j_anomaly_audio_glitch',
        config = { extra = { chips = 30 } },
        rarity = 1,
        atlas = 'j_anomaly_audio_glitch',
        cost = 4,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    }
}

for _, joker_def in ipairs(jokers) do
    joker_def.unlocked = true
    joker_def.discovered = true
    SMODS.Joker(joker_def)
end


local jokers = {
    -- 377. Gravitational Anomaly
    {
        key = 'j_anomaly_gravitational_anomaly',
        config = { extra = { mult = 20 } },
        rarity = 2,
        atlas = 'j_anomaly_gravitational_anomaly',
        cost = 6,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local low_ranks = true
                for _, playing_card in ipairs(context.scoring_hand) do
                    if playing_card:get_id() > 5 then
                        low_ranks = false
                        break
                    end
                end
                
                if low_ranks then
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                        mult_mod = card.ability.extra.mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    -- 378. Temporal Anomaly
    {
        key = 'j_anomaly_temporal_anomaly',
        config = { },
        rarity = 2,
        atlas = 'j_anomaly_temporal_anomaly',
        cost = 8,
        blueprint_compat = false,
        calculate = function(self, card, context)
            if context.selling_self then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        play_sound('timpani')
                        G.GAME.blind:defeat()
                        return true
                    end
                })) 
            end
        end
    },
    -- 379. Spatial Anomaly
    {
        key = 'j_anomaly_spatial_anomaly',
        config = { extra = { hand_size = 2, joker_slot = 1 } },
        rarity = 2,
        atlas = 'j_anomaly_spatial_anomaly',
        cost = 6,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.hand_size, extra.joker_slot } }

        end,
        add_to_deck = function(self, card, from_debuff)
            G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size
            G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.joker_slot
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size
            G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.joker_slot
        end
    },
    -- 380. Unstable Wormhole
    {
        key = 'j_anomaly_unstable_wormhole',
        config = { extra = { x_mult = 2, odds = 10 } },
        rarity = 2,
        atlas = 'j_anomaly_unstable_wormhole',
        cost = 6,
        blueprint_compat = true,
        eternal_compat = true,
        perishable_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, (G.GAME and G.GAME.probabilities.normal or 1), extra.odds } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if not context.blueprint and not context.retrigger_joker then
                    if pseudorandom('wormhole') < G.GAME.probabilities.normal / card.ability.extra.odds then
                        local neighbors = {}
                        local my_pos = -1
                        for i, j in ipairs(G.jokers.cards) do
                            if j == card then my_pos = i; break end
                        end
                        if my_pos > 1 then table.insert(neighbors, G.jokers.cards[my_pos-1]) end
                        if my_pos < #G.jokers.cards then table.insert(neighbors, G.jokers.cards[my_pos+1]) end
                        
                        if #neighbors > 0 then
                            local target = neighbors[pseudorandom('wormhole_target') % #neighbors + 1]
                            if not target.ability.eternal then
                                target.getting_sliced = true
                                G.E_MANAGER:add_event(Event({func = function()
                                    target:start_dissolve()
                                return true end }))
                                card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_eaten_ex')})
                            end
                        end
                    end
                end
                
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end
        end
    },
    -- 381. Augmented Reality
    {
        key = 'j_anomaly_augmented_reality',
        config = { },
        rarity = 2,
        atlas = 'j_anomaly_augmented_reality',
        cost = 6,
        eternal_compat = true,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_glass_safe = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_glass_safe = nil
        end
    },
    -- 382. Simulation
    {
        key = 'j_anomaly_simulation',
        config = { extra = { x_mult = 4 } },
        rarity = 2,
        atlas = 'j_anomaly_simulation',
        cost = 7,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if G.GAME.current_round.odyssey_last_hand_ranks then
                    local current_ranks = ''
                    for _, c in ipairs(context.scoring_hand) do current_ranks = current_ranks .. c.base.id .. ',' end
                    
                    if current_ranks == G.GAME.current_round.odyssey_last_hand_ranks then
                        return {
                            message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                            Xmult_mod = card.ability.extra.x_mult
                        }
                    end
                end
            end
            if context.after and not context.blueprint then
                local current_ranks = ''
                for _, c in ipairs(context.scoring_hand) do current_ranks = current_ranks .. c.base.id .. ',' end
                G.GAME.current_round.odyssey_last_hand_ranks = current_ranks
            end
        end
    },
    -- 383. Broken Code
    {
        key = 'j_anomaly_broken_code',
        config = { extra = { chips = 100 } },
        rarity = 2,
        atlas = 'j_anomaly_broken_code',
        cost = 5,
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                 return {
                    chip_mod = card.ability.extra.chips,
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    },
    -- 384. Hidden Variable
    {
        key = 'j_anomaly_hidden_variable',
        config = { extra = { x_mult = 0.5 } },
        rarity = 2,
        atlas = 'j_anomaly_hidden_variable',
        cost = 6,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local count = 0
                for _, v in pairs(G.jokers.cards) do
                    if v.config.center.key and string.find(v.config.center.key, 'anomaly') then
                        count = count + 1
                    end
                end
                
                local total_xmult = 1 + (count * card.ability.extra.x_mult)
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { total_xmult } },
                    Xmult_mod = total_xmult
                }
            end
        end
    },
    -- 385. Unhandled Exception
    {
        key = 'j_anomaly_unhandled_exception',
        config = { extra = { money = 10 } },
        rarity = 2,
        atlas = 'j_anomaly_unhandled_exception',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.money } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if G.GAME.current_round.discards_left <= 0 then
                     return {
                        dollars = card.ability.extra.money,
                        message = localize('$')..card.ability.extra.money,
                        colour = G.C.MONEY
                     }
                end
            end
        end
    },
    -- 386. Buffer Overflow
    {
        key = 'j_anomaly_buffer_overflow',
        config = { },
        rarity = 2,
        atlas = 'j_anomaly_buffer_overflow',
        cost = 6,
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.repetition and context.cardarea == G.play then
                if #G.play.cards == 5 then
                    local middle_card = G.play.cards[3]
                    if context.other_card == middle_card then
                        return {
                            message = localize('k_again_ex'),
                            repetitions = 2,
                            card = card
                        }
                    end
                end
            end
        end
    },
    -- 387. Memory Dump
    {
        key = 'j_anomaly_memory_dump',
        config = { },
        rarity = 2,
        atlas = 'j_anomaly_memory_dump',
        cost = 4,
        calculate = function(self, card, context)
            if context.selling_self then
                G.E_MANAGER:add_event(Event({
                    func = function() 
                        for i=1, 3 do
                            local _card = create_card('Base', G.pack_cards, nil, nil, true, true, nil, 'memdump')
                            _card:add_to_deck()
                            G.hand:emplace(_card)
                        end
                        return true
                    end
                }))
            end
        end
    },
    -- 388. Race Condition
    {
        key = 'j_anomaly_race_condition',
        config = { extra = { mult = 50, seconds = 5 } },
        rarity = 2,
        atlas = 'j_anomaly_race_condition',
        cost = 6,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.seconds } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    -- 389. Deadlock
    {
        key = 'j_anomaly_deadlock',
        config = { extra = { x_mult = 3 } },
        rarity = 2,
        atlas = 'j_anomaly_deadlock',
        cost = 6,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if G.GAME.current_round.discards_left == 0 and G.GAME.current_round.hands_left == 0 then
                    return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                        Xmult_mod = card.ability.extra.x_mult
                    }
                end
            end
        end
    },
    -- 390. Heisenbug
    {
        key = 'j_anomaly_heisenbug',
        config = { extra = { mult = 15, chips = 100, dollars = 5, mode = 1 } },
        rarity = 2,
        atlas = 'j_anomaly_heisenbug',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)
            local modes = {"Mult", "Chips", "Money"}
            return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult, ( (card and card.ability and card.ability.extra) or self.config.extra ).chips, ( (card and card.ability and card.ability.extra) or self.config.extra ).dollars, modes[( (card and card.ability and card.ability.extra) or self.config.extra ).mode] } }
        end,
        calculate = function(self, card, context)
             if context.end_of_round and not context.repetition and not context.other_card then
                 card.ability.extra.mode = pseudorandom('heisenbug') % 3 + 1
                 return { message = 'Glitch!', colour = G.C.RED }
             end
             
             if context.joker_main then
                 if card.ability.extra.mode == 1 then
                     return { mult_mod = card.ability.extra.mult, message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } } }
                 elseif card.ability.extra.mode == 2 then
                     return { chip_mod = card.ability.extra.chips, message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } } }
                 else
                     return { dollars = card.ability.extra.dollars, message = localize('$')..card.ability.extra.dollars, colour = G.C.MONEY }
                 end
             end
        end
    }
}

for _, joker_def in ipairs(jokers) do
    joker_def.unlocked = true
    joker_def.discovered = true
    SMODS.Joker(joker_def)
end

local jokers = {
    -- 391. The Monolith
    {
        key = 'j_anomaly_the_monolith',
        config = { extra = { x_mult = 4 } },
        rarity = 3,
        atlas = 'j_anomaly_the_monolith',
        cost = 8,
        blueprint_compat = true,
        eternal_compat = true,
        perishable_compat = false,
        add_to_deck = function(self, card, from_debuff)
            if not from_debuff then
                card.ability.eternal = true
            end
        end,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end
        end
    },
    -- 392. Primordial Anomaly
    {
        key = 'j_anomaly_primordial_anomaly',
        config = { },
        rarity = 3,
        atlas = 'j_anomaly_primordial_anomaly',
        cost = 8,
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
                if G.GAME.blind.boss and G.GAME.current_round.discards_used == 0 then
                    G.E_MANAGER:add_event(Event({
                        func = function() 
                            local card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, 'c_soul', 'primordial')
                            card:add_to_deck()
                            G.consumeables:emplace(card)
                            return true
                        end
                    }))
                    return {
                        message = localize('k_soul_ex'),
                        colour = G.C.PURPLE
                    }
                end
            end
        end
    },
    -- 393. Reality Rift
    {
        key = 'j_anomaly_reality_rift',
        config = { extra = { consumable = 1, joker = 1 } },
        rarity = 3,
        atlas = 'j_anomaly_reality_rift',
        cost = 8,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.consumable, extra.joker } }

        end,
        add_to_deck = function(self, card, from_debuff)
            if not from_debuff then
                G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra.consumable
                G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.joker
            end
        end,
        remove_from_deck = function(self, card, from_debuff)
            if not from_debuff then
                G.consumeables.config.card_limit = G.consumeables.config.card_limit - card.ability.extra.consumable
                G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.joker
            end
        end
    },
    -- 394. Mirror Universe
    {
        key = 'j_anomaly_mirror_universe',
        config = { },
        rarity = 3,
        atlas = 'j_anomaly_mirror_universe',
        cost = 8,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_mirror_universe = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_mirror_universe = nil
        end
    },
    -- 395. Strange Matter
    {
        key = 'j_anomaly_strange_matter',
        config = { },
        rarity = 3,
        atlas = 'j_anomaly_strange_matter',
        cost = 8,
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.before and not context.blueprint then
                 for _, c in ipairs(context.scoring_hand) do
                    c:set_ability(G.P_CENTERS.m_odyssey_plastic)
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            c:juice_up()
                            return true
                        end
                    }))
                 end
                 return {
                    message = localize('k_gold'),
                    colour = G.C.MONEY
                 }
            end
        end
    },
    -- 396. Phantom Energy
    {
        key = 'j_anomaly_phantom_energy',
        config = { extra = { consumable = 1, joker = 1, hand = 2 } },
        rarity = 3,
        atlas = 'j_anomaly_phantom_energy',
        cost = 8,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.consumable, extra.joker, extra.hand } }

        end,
        add_to_deck = function(self, card, from_debuff)
            if not from_debuff then
                G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra.consumable
                G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.joker
                G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand
            end
        end,
        remove_from_deck = function(self, card, from_debuff)
            if not from_debuff then
                G.consumeables.config.card_limit = G.consumeables.config.card_limit - card.ability.extra.consumable
                G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.joker
                G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand
            end
        end
    },
    -- 397. Function Collapse
    {
        key = 'j_anomaly_function_collapse',
        config = { extra = { x_mult = 3 } },
        rarity = 3,
        atlas = 'j_anomaly_function_collapse',
        cost = 8,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                 return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end
        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_faceless_suits = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_faceless_suits = nil
        end
    },
    -- 398. Parity Error
    {
        key = 'j_anomaly_parity_error',
        config = { extra = { money = 20 } },
        rarity = 3,
        atlas = 'j_anomaly_parity_error',
        cost = 8,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.money } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if #context.scoring_hand == 5 then
                    local odds = 0
                    local evens = 0
                    for _, c in ipairs(context.scoring_hand) do
                        if c:get_id() % 2 == 0 then evens = evens + 1 else odds = odds + 1 end
                    end
                    
                    if evens == 5 or odds == 5 then
                        return {
                            dollars = card.ability.extra.money,
                            message = localize('$')..card.ability.extra.money,
                            colour = G.C.MONEY
                        }
                    end
                end
            end
        end
    }
}

for _, joker_def in ipairs(jokers) do
    joker_def.unlocked = true
    joker_def.discovered = true
    SMODS.Joker(joker_def)
end


local jokers = {
    -- 399. The Watcher
    {
        key = 'j_anomaly_the_watcher',
        config = { extra = { x_mult = 3 } },
        rarity = 4,
        atlas = 'j_anomaly_the_watcher',
        cost = 20,
        blueprint_compat = true,
        eternal_compat = true,
        perishable_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end
        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_reveal_deck = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_reveal_deck = nil
        end
    },
    -- 400. Fatal Error
    {
        key = 'j_anomaly_fatal_error',
        config = { extra = { x_mult = 10, money = 100 } },
        rarity = 4,
        atlas = 'j_anomaly_fatal_error',
        cost = 20,
        blueprint_compat = true,
        eternal_compat = true,
        perishable_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.money } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end

            if context.end_of_round and not context.repetition and not context.other_card then
                if not context.blueprint then
                    local deletable_jokers = {}
                    for _, j in ipairs(G.jokers.cards) do
                        if not j.ability.eternal and j ~= card then
                            table.insert(deletable_jokers, j)
                        end
                    end
                    if #deletable_jokers > 0 then
                        local target = deletable_jokers[pseudorandom('fatal_error') % #deletable_jokers + 1]
                        target.getting_sliced = true
                        G.E_MANAGER:add_event(Event({func = function()
                            target:start_dissolve()
                        return true end }))
                    end
                end

                return {
                    dollars = card.ability.extra.money,
                    message = localize('$')..card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
    }
}

for _, joker_def in ipairs(jokers) do
    joker_def.unlocked = true
    joker_def.discovered = true
    SMODS.Joker(joker_def)
end


-- ============================================
-- ELEMENTAL - Common (Jokers 401-420)
-- ============================================

-- 401. Eternal Flame
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_eternal_flame',
    discovered = true,
    config = { extra = { mult = 4 } },
    rarity = 1,
    atlas = 'j_elemental_eternal_flame',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Hearts") then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 402. Raindrop
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_raindrop',
    discovered = true,
    config = { extra = { chips = 20 } },
    rarity = 1,
    atlas = 'j_elemental_raindrop',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Spades") then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
    end
})

-- 403. Runestone
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_runestone',
    discovered = true,
    config = { extra = { mult = 4 } },
    rarity = 1,
    atlas = 'j_elemental_runestone',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Diamonds") then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 404. Gentle Breeze
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_gentle_breeze',
    discovered = true,
    config = { extra = { chips = 20 } },
    rarity = 1,
    atlas = 'j_elemental_gentle_breeze',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Clubs") then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
    end
})

-- 405. Inferno
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_inferno',
    discovered = true,
    config = { extra = { mult = 15, perma_mult = 0, gain = 2 } },
    rarity = 1,
    atlas = 'j_elemental_inferno',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) 
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult, ( (card and card.ability and card.ability.extra) or self.config.extra ).perma_mult, ( (card and card.ability and card.ability.extra) or self.config.extra ).gain } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local total_mult = card.ability.extra.mult + card.ability.extra.perma_mult
            return {
                mult_mod = total_mult,
                message = localize{type='variable', key='a_mult', vars={total_mult}}
            }
        end
        if context.before and not context.blueprint then
            local hearts = 0
            for i=1, #context.scoring_hand do 
                if context.scoring_hand[i]:is_suit("Hearts") then hearts = hearts + 1 end 
            end
            if hearts >= 5 then
                card.ability.extra.perma_mult = card.ability.extra.perma_mult + card.ability.extra.gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
    end
})

-- 406. Tsunami
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_tsunami',
    discovered = true,
    config = { extra = { chips = 50, perma_chips = 0, gain = 10 } },
    rarity = 1,
    atlas = 'j_elemental_tsunami',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) 
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).chips, ( (card and card.ability and card.ability.extra) or self.config.extra ).perma_chips, ( (card and card.ability and card.ability.extra) or self.config.extra ).gain } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local total_chips = card.ability.extra.chips + card.ability.extra.perma_chips
            return {
                chip_mod = total_chips,
                message = localize{type='variable', key='a_chips', vars={total_chips}}
            }
        end
        if context.before and not context.blueprint then
            local spades = 0
            for i=1, #context.scoring_hand do 
                if context.scoring_hand[i]:is_suit("Spades") then spades = spades + 1 end 
            end
            if spades >= 5 then
                card.ability.extra.perma_chips = card.ability.extra.perma_chips + card.ability.extra.gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.CHIPS,
                    card = card
                }
            end
        end
    end
})

-- 407. Earthquake
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_earthquake',
    discovered = true,
    config = { extra = { mult = 10, dollars = 2 } },
    rarity = 1,
    atlas = 'j_elemental_earthquake',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).dollars } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
        if context.discard and not context.blueprint then
            if context.other_card:is_suit("Diamonds") then
                ease_dollars(card.ability.extra.dollars)
                if not context.other_card.ability.eternal then context.other_card:start_dissolve() end
                return {
                    message = localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 408. Tornado
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_tornado',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_elemental_tornado',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
        if (context.after or context.discard) and not context.blueprint then
             G.FUNCS.sort_hand_suit(nil)
        end
    end
})

-- 409. Volcano
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_volcano',
    discovered = true,
    config = { extra = { odds = 4, x_mult = 2 } },
    rarity = 1,
    atlas = 'j_elemental_volcano',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds, ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Hearts") then
                if pseudorandom('volcano') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    if not context.other_card.ability.eternal then context.other_card:start_dissolve() end
                    return {
                        x_mult = card.ability.extra.x_mult,
                        card = card
                    }
                end
            end
        end
    end
})

-- 410. Iceberg
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_iceberg',
    discovered = true,
    config = { extra = { chips = 10, mult = 2 } },
    rarity = 1,
    atlas = 'j_elemental_iceberg',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips, (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Spades") then
                return {
                    chips = card.ability.extra.chips,
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 411. Lightning
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_lightning',
    discovered = true,
    config = { extra = { mult = 30 } },
    rarity = 1,
    atlas = 'j_elemental_lightning',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local clubs = false
            local diamonds = false
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit("Clubs") then clubs = true end
                if context.scoring_hand[i]:is_suit("Diamonds") then diamonds = true end
            end
            if clubs and diamonds then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
                }
            end
        end
    end
})

-- 412. Magma
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_magma',
    discovered = true,
    config = { extra = { } },
    rarity = 1,
    atlas = 'j_elemental_magma',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_magma_active = true
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_magma_active = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 413. Mud
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_mud',
    discovered = true,
    config = { extra = { } },
    rarity = 1,
    atlas = 'j_elemental_mud',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_mud_active = true
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_mud_active = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 414. Ember
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_ember',
    discovered = true,
    config = { extra = { mult = 5, gain = 1 } },
    rarity = 1,
    atlas = 'j_elemental_ember',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).gain } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
        if context.before and not context.blueprint then
            if context.scoring_name == "Flush" then
                local hearts = true
                for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Hearts") then hearts = false end end
                if hearts then
                    card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
                    return {
                        message = localize('k_upgrade_ex'),
                        colour = G.C.MULT
                    }
                end
            end
        end
    end
})

-- 415. Dew
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_dew',
    discovered = true,
    config = { extra = { chips = 20, gain = 5 } },
    rarity = 1,
    atlas = 'j_elemental_dew',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips, (( (card and card.ability and card.ability.extra) or self.config.extra )).gain } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize{type='variable', key='a_chips', vars={card.ability.extra.chips}}
            }
        end
        if context.before and not context.blueprint then
            if context.scoring_name == "Flush" then
                local spades = true
                for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Spades") then spades = false end end
                if spades then
                    card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.gain
                    return {
                        message = localize('k_upgrade_ex'),
                        colour = G.C.CHIPS
                    }
                end
            end
        end
    end
})

-- 416. Crystal
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_crystal',
    discovered = true,
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    atlas = 'j_elemental_crystal',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local only_diamonds = true
            for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Diamonds") then only_diamonds = false end end
            if only_diamonds then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 417. Smoke
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_smoke',
    discovered = true,
    config = { extra = { odds = 3 } },
    rarity = 1,
    atlas = 'j_elemental_smoke',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } } end,
    calculate = function(self, card, context)
        if context.before and G.GAME.blind.boss and not G.GAME.blind.disabled then
            local clubs = false
            for i=1, #context.scoring_hand do if context.scoring_hand[i]:is_suit("Clubs") then clubs = true end end
            if clubs and pseudorandom('smoke') < G.GAME.probabilities.normal / card.ability.extra.odds then
                G.GAME.blind:disable()
                return {
                    message = localize('k_safe_ex'),
                    colour = G.C.FILTER,
                    card = card
                }
            end
        end
    end
})

-- 418. Spark
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_spark',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_elemental_spark',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played == 0 then
            local red = true
            for i=1, #context.scoring_hand do 
                if not (context.scoring_hand[i]:is_suit("Hearts") or context.scoring_hand[i]:is_suit("Diamonds")) then red = false end 
            end
            if red then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
                }
            end
        end
    end
})

-- 419. Wave
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_wave',
    discovered = true,
    config = { extra = { chips = 40 } },
    rarity = 1,
    atlas = 'j_elemental_wave',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played == 0 then
            local black = true
            for i=1, #context.scoring_hand do 
                if not (context.scoring_hand[i]:is_suit("Spades") or context.scoring_hand[i]:is_suit("Clubs")) then black = false end 
            end
            if black then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize{type='variable', key='a_chips', vars={card.ability.extra.chips}}
                }
            end
        end
    end
})

-- 420. Ash
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_ash',
    discovered = true,
    config = { extra = { dollars = 3 } },
    rarity = 1,
    atlas = 'j_elemental_ash',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).dollars } } end,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            local red_count = 0
            for i=1, #context.full_hand do
                if context.full_hand[i]:is_suit("Hearts") or context.full_hand[i]:is_suit("Diamonds") then
                    red_count = red_count + 1
                end
            end
            if red_count >= 5 then
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})



-- ============================================
-- ELEMENTAL - Uncommon (Jokers 421-438)
-- ============================================

-- 421. Fire Spirit
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_fire_spirit',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_elemental_fire_spirit',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Flush" then
            local hearts = true
            for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Hearts") then hearts = false end end
            if hearts then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 422. Water Spirit
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_water_spirit',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_elemental_water_spirit',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Flush" then
            local spades = true
            for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Spades") then spades = false end end
            if spades then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 423. Earth Spirit
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_earth_spirit',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_elemental_earth_spirit',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Flush" then
            local diamonds = true
            for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Diamonds") then diamonds = false end end
            if diamonds then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 424. Air Spirit
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_air_spirit',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_elemental_air_spirit',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Flush" then
            local clubs = true
            for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Clubs") then clubs = false end end
            if clubs then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 425. Elemental Fusion
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_elemental_fusion',
    discovered = true,
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_elemental_elemental_fusion',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {Hearts=false, Spades=false, Diamonds=false, Clubs=false}
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit("Hearts") then suits.Hearts = true end
                if context.scoring_hand[i]:is_suit("Spades") then suits.Spades = true end
                if context.scoring_hand[i]:is_suit("Diamonds") then suits.Diamonds = true end
                if context.scoring_hand[i]:is_suit("Clubs") then suits.Clubs = true end
            end
            local count = 0
            for _, v in pairs(suits) do if v then count = count + 1 end end
            if count >= 4 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 426. Steam
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_steam',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_elemental_steam',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local hearts = false
            local spades = false
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit("Hearts") then hearts = true end
                if context.scoring_hand[i]:is_suit("Spades") then spades = true end
            end
            if hearts and spades then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
                }
            end
        end
    end
})

-- 427. Lava
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_lava',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_elemental_lava',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local hearts = false
            local diamonds = false
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit("Hearts") then hearts = true end
                if context.scoring_hand[i]:is_suit("Diamonds") then diamonds = true end
            end
            if hearts and diamonds then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
                }
            end
        end
    end
})

-- 428. Sandstorm
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_sandstorm',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_elemental_sandstorm',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local diamonds = false
            local clubs = false
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit("Diamonds") then diamonds = true end
                if context.scoring_hand[i]:is_suit("Clubs") then clubs = true end
            end
            if diamonds and clubs then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
                }
            end
        end
    end
})

-- 429. Storm
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_storm',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_elemental_storm',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local spades = false
            local clubs = false
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit("Spades") then spades = true end
                if context.scoring_hand[i]:is_suit("Clubs") then clubs = true end
            end
            if spades and clubs then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
                }
            end
        end
    end
})

-- 430. Element Master
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_element_master',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 2,
    atlas = 'j_elemental_element_master',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            for k, v in ipairs(G.playing_cards) do suits[v.base.suit] = true end
            local count = 0
            for _ in pairs(suits) do count = count + 1 end
            return {
                mult_mod = count * card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={count * card.ability.extra.mult}}
            }
        end
    end
})

-- 431. Prism
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_prism',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_elemental_prism',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.edition and context.other_card.edition.polychrome then
                return {
                    x_mult = card.ability.extra.x_mult,
                    card = card
                }
            end
        end
    end
})

-- 432. Aether
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_aether',
    discovered = true,
    config = { extra = { mult = 50 } },
    rarity = 2,
    atlas = 'j_elemental_aether',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_emerald then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 433. Plasma
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_plasma',
    discovered = true,
    config = { extra = { x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_elemental_plasma',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Hearts") or context.other_card:is_suit("Spades") then
                return {
                    x_mult = card.ability.extra.x_mult,
                    card = card
                }
            end
        end
    end
})

-- 434. Geode
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_geode',
    discovered = true,
    config = { extra = { odds = 3, dollars = 5, mult = 20 } },
    rarity = 2,
    atlas = 'j_elemental_geode',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds, ( (card and card.ability and card.ability.extra) or self.config.extra ).dollars, ( (card and card.ability and card.ability.extra) or self.config.extra ).mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_emerald then
                if pseudorandom('geode') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    if pseudorandom('geode_type') < 0.5 then
                        ease_dollars(card.ability.extra.dollars)
                        return {
                            message = localize('$')..card.ability.extra.dollars,
                            colour = G.C.MONEY,
                            card = card
                        }
                    else
                        return {
                            mult = card.ability.extra.mult,
                            card = card
                        }
                    end
                end
            end
        end
    end
})

-- 435. Thunderbolt
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_thunderbolt',
    discovered = true,
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_elemental_thunderbolt',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.before and context.scoring_name == "Straight Flush" then
            if #context.scoring_hand >= 3 then
                local middle = math.ceil(#context.scoring_hand / 2)
                local target = context.scoring_hand[middle]
                if not target.ability.eternal then
                    target:start_dissolve()
                end
            end
        end
        if context.joker_main and context.scoring_name == "Straight Flush" then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                card = card
            }
        end
    end
})

-- 436. Blizzard
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_blizzard',
    discovered = true,
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_elemental_blizzard',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local spades = 0
            for i=1, #context.scoring_hand do if context.scoring_hand[i]:is_suit("Spades") then spades = spades + 1 end end
            if spades >= 5 then
                G.GAME.modifiers.odyssey_blizzard_frozen = true
                return {
                    message = "Frozen!",
                    colour = G.C.FILTER,
                    card = card
                }
            end
        end
    end
})

-- 437. Fire Meteor
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_fire_meteor',
    discovered = true,
    config = { extra = { chips = 100, mult = 10 } },
    rarity = 2,
    atlas = 'j_elemental_fire_meteor',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips, (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local hearts_in_hand = 0
            for i=1, #G.hand.cards do if G.hand.cards[i]:is_suit("Hearts") then hearts_in_hand = hearts_in_hand + 1 end end
            local bonus_mult = hearts_in_hand * card.ability.extra.mult
            return {
                chip_mod = card.ability.extra.chips,
                mult_mod = bonus_mult,
                message = localize{type='variable', key='a_mult', vars={bonus_mult}}
            }
        end
    end
})

-- 438. Garden
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_garden',
    discovered = true,
    config = { extra = { bonus = 1 } },
    rarity = 2,
    atlas = 'j_elemental_garden',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).bonus } } end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.blueprint then
            for i=1, #G.hand.cards do
                if G.hand.cards[i]:is_suit("Diamonds") then
                    local c = G.hand.cards[i]
                    c.ability.perma_bonus = (c.ability.perma_bonus or 0) + card.ability.extra.bonus
                    c:juice_up()
                end
            end
            return {
                message = "Grown!",
                colour = G.C.CHIPS
            }
        end
    end
})


-- ============================================
-- ELEMENTAL - Rare (Jokers 439-448)
-- ============================================

-- 439. Phoenix
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_phoenix',
    discovered = true,
    config = { extra = { mult = 0, gain = 1 } },
    rarity = 3,
    atlas = 'j_elemental_phoenix',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).gain } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
        if context.discard and not context.blueprint then
             local hearts = 0
             for i=1, #context.full_hand do if context.full_hand[i]:is_suit("Hearts") then hearts = hearts + 1 end end
             if hearts >= 5 then
                 card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
                 return {
                     message = localize('k_upgrade_ex'),
                     colour = G.C.MULT
                 }
             end
        end
    end
})

-- 440. Leviathan
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_leviathan',
    discovered = true,
    config = { extra = { hands = 1 } },
    rarity = 3,
    atlas = 'j_elemental_leviathan',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and context.scoring_name == "Flush" then
            local spades = 0
            for i=1, #context.scoring_hand do if context.scoring_hand[i]:is_suit("Spades") then spades = spades + 1 end end
            if spades >= 5 then
                ease_hands_played(card.ability.extra.hands)
                return {
                    message = "+"..card.ability.extra.hands.." Hand",
                    colour = G.C.BLUE
                }
            end
        end
    end
})

-- 441. Behemoth
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_behemoth',
    discovered = true,
    config = { extra = { slots = 1 } },
    rarity = 3,
    atlas = 'j_elemental_behemoth',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and context.scoring_name == "Flush" then
            local diamonds = 0
            for i=1, #context.scoring_hand do if context.scoring_hand[i]:is_suit("Diamonds") then diamonds = diamonds + 1 end end
            if diamonds >= 5 and not context.blueprint then
                G.GAME.modifiers.odyssey_behemoth_slots = (G.GAME.modifiers.odyssey_behemoth_slots or 0) + card.ability.extra.slots
                G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.slots
                return {
                    message = "+1 Slot!",
                    colour = G.C.JOKER_GREY,
                    card = card
                }
            end
        end
        if context.end_of_round and not context.other_card and not context.blueprint then
            if G.GAME.modifiers.odyssey_behemoth_slots and G.GAME.modifiers.odyssey_behemoth_slots > 0 then
                G.jokers.config.card_limit = G.jokers.config.card_limit - G.GAME.modifiers.odyssey_behemoth_slots
                G.GAME.modifiers.odyssey_behemoth_slots = 0
            end
        end
    end
})

-- 442. Ziz
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_ziz',
    discovered = true,
    config = { extra = { discards = 1, dollars = 5 } },
    rarity = 3,
    atlas = 'j_elemental_ziz',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and context.scoring_name == "Flush" then
            local clubs = 0
            for i=1, #context.scoring_hand do if context.scoring_hand[i]:is_suit("Clubs") then clubs = clubs + 1 end end
            if clubs >= 5 then
                ease_discard(card.ability.extra.discards)
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = "+1 Discard / $5",
                    colour = G.C.GREEN
                }
            end
        end
    end
})

-- 443. Fifth Element
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_fifth_element',
    discovered = true,
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    atlas = 'j_elemental_fifth_element',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local elements = { fire=false, water=false, earth=false, air=false }
            for i = 1, #G.jokers.cards do
                local j = G.jokers.cards[i]
                if j.config.center.key == 'j_elemental_fire_spirit' or j.config.center.key == 'odyssey_j_elemental_fire_spirit' then elements.fire = true end
                if j.config.center.key == 'j_elemental_water_spirit' or j.config.center.key == 'odyssey_j_elemental_water_spirit' then elements.water = true end
                if j.config.center.key == 'j_elemental_earth_spirit' or j.config.center.key == 'odyssey_j_elemental_earth_spirit' then elements.earth = true end
                if j.config.center.key == 'j_elemental_air_spirit' or j.config.center.key == 'odyssey_j_elemental_air_spirit' then elements.air = true end
            end
            local count = 0
            for _, v in pairs(elements) do if v then count = count + 1 end end
            if count >= 4 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 444. Master Alchemist
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_master_alchemist',
    discovered = true,
    config = { extra = {} },
    rarity = 3,
    atlas = 'j_elemental_master_alchemist',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.setting_blind and G.GAME.blind.boss and not context.blueprint then
            for i=1, #G.hand.cards do
                local c = G.hand.cards[i]
                local new_base = 'D_' .. (c.base.value == '10' and 'T' or string.sub(c.base.value, 1, 1))
                if c.base.value == 'Ace' then new_base = 'D_A' end
                if c.base.value == 'Jack' then new_base = 'D_J' end
                if c.base.value == 'Queen' then new_base = 'D_Q' end
                if c.base.value == 'King' then new_base = 'D_K' end
                -- Safe way:
                local rank = c.base.value
                local suit = 'Diamonds'
                c:set_base(G.P_CARDS[suit .. '_' .. rank])
            end
            return {
                message = "Golden Hand!",
                colour = G.C.MONEY
            }
        end
    end
})

-- 445. Heart of the World
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_heart_of_the_world',
    discovered = true,
    config = { extra = { x_mult = 3, odyssey_suit_immune = true } },
    rarity = 3,
    atlas = 'j_elemental_heart_of_the_world',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
            }
        end
        if context.setting_blind then
            G.GAME.modifiers.odyssey_suit_immune = true
        end
    end
})

-- 446. Neutron Star
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_neutron_star',
    discovered = true,
    config = { extra = { mult = 20 } },
    rarity = 3,
    atlas = 'j_elemental_neutron_star',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local c = context.other_card
            if c.config.center == G.P_CENTERS.m_odyssey_platinum or c.config.center == G.P_CENTERS.m_odyssey_plastic or c.config.center == G.P_CENTERS.m_odyssey_emerald then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 447. Superconductor
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_superconductor',
    discovered = true,
    config = { extra = {} },
    rarity = 3,
    atlas = 'j_elemental_superconductor',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_plastic then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- 448. Absolute Zero
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_absolute_zero',
    discovered = true,
    config = { extra = { x_mult = 10, next_hand_active = false } },
    rarity = 3,
    atlas = 'j_elemental_absolute_zero',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and card.ability.extra.next_hand_active then
            card.ability.extra.next_hand_active = false
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
            }
        end
        if context.after and not context.blueprint then
            if G.GAME.chips - G.GAME.chips_at_start_of_hand == 0 then
                card.ability.extra.next_hand_active = true
            end
        end
    end
})


-- ============================================
-- ELEMENTAL - Legendary (Jokers 449-450)
-- ============================================

-- 449. Avatar
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_avatar',
    discovered = true,
    config = { extra = { x_mult = 4 } },
    rarity = 4,
    atlas = 'j_elemental_avatar',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
            }
        end
        if context.setting_blind then
            G.GAME.modifiers.odyssey_any_flush = true
        end
    end
})

-- 450. Cataclysm
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_cataclysm',
    discovered = true,
    config = { extra = { x_mult = 10 } },
    rarity = 4,
    atlas = 'j_elemental_cataclysm',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
            }
        end
        if context.buy_joker and not context.blueprint then
            local suits = {"Hearts", "Spades", "Diamonds", "Clubs"}
            local target_suit = suits[pseudorandom('cataclysm') % 4 + 1]
            local cards_to_destroy = {}
            for i = 1, #G.playing_cards do
                if G.playing_cards[i].base.suit == target_suit then
                    table.insert(cards_to_destroy, G.playing_cards[i])
                end
            end
            for _, c in ipairs(cards_to_destroy) do
                c:start_dissolve()
            end
            return {
                message = "Cataclysm: " .. target_suit .. " destroyed!",
                colour = G.C.SECONDARY_SET.Spectral
            }
        end
    end
})



SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_squire',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_squire',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_jack = false
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == 11 then
                    has_jack = true
                    break
                end
            end
            if has_jack then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_lady_in_waiting',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_lady_in_waiting',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_queen = false
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == 12 then
                    has_queen = true
                    break
                end
            end
            if has_queen then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_royal_guard',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_royal_guard',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_king = false
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == 13 then
                    has_king = true
                    break
                end
            end
            if has_king then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_jester',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_jester',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_ace = false
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == 14 then
                    has_ace = true
                    break
                end
            end
            if has_ace then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_warrior',
    discovered = true,
    config = { extra = { chips = 20 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_warrior',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit('Spades') then
                    count = count + 1
                end
            end
            if count > 0 then
                return {
                    message = localize{type='variable', key='a_chips', vars={card.ability.extra.chips * count}},
                    chip_mod = card.ability.extra.chips * count
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_mage',
    discovered = true,
    config = { extra = { mult = 4 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_mage',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit('Clubs') then
                    count = count + 1
                end
            end
            if count > 0 then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult * count}},
                    mult_mod = card.ability.extra.mult * count
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_rogue',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_rogue',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Diamonds') then
                G.GAME.dollar_cap = G.GAME.dollar_cap or 0
                ease_dollars(card.ability.extra.money)
                return {
                    extra = {focus = context.other_card, message = localize('$')..card.ability.extra.money, colour = G.C.MONEY},
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_cleric',
    discovered = true,
    config = { extra = { hearts_needed = 5, hand_gained = 1 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_cleric',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.hearts_needed, extra.hand_gained } }

    end,
    calculate = function(self, card, context)
        if context.after_hand and not context.blueprint then
            local hearts = 0
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit('Hearts') then
                    hearts = hearts + 1
                end
            end
            if hearts >= card.ability.extra.hearts_needed and not G.GAME.current_round.odyssey_cleric_activated then
                G.GAME.current_round.odyssey_cleric_activated = true
                ease_hands_played(card.ability.extra.hand_gained)
                return {
                    message = localize('k_plus_one_hand'),
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_barbarian',
    discovered = true,
    config = { extra = { mult = 30 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_barbarian',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_face = false
            for i = 1, #context.full_hand do
                if context.full_hand[i]:is_face() then
                    has_face = true
                    break
                end
            end
            if not has_face then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_paladin',
    discovered = true,
    config = { extra = { chips = 50 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_paladin',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local all_face = true
            for i = 1, #context.full_hand do
                if not context.full_hand[i]:is_face() then
                    all_face = false
                    break
                end
            end
            if all_face and #context.full_hand > 0 then
                return {
                    message = localize{type='variable', key='a_chips', vars={card.ability.extra.chips}},
                    chip_mod = card.ability.extra.chips
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_druid',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_druid',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            local suit_count = 0
            for i = 1, #context.scoring_hand do
                local suit = context.scoring_hand[i].base.suit
                if not suits[suit] then
                    suits[suit] = true
                    suit_count = suit_count + 1
                end
            end
            if suit_count > 1 then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_necromancer',
    discovered = true,
    config = { extra = {} },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_necromancer',
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and not context.blueprint and G.GAME.last_destroyed_face_card then
            local card_data = G.GAME.last_destroyed_face_card
            G.GAME.last_destroyed_face_card = nil
            
            G.E_MANAGER:add_event(Event({
                func = function()
                    local _card = create_playing_card(G.P_CARDS[card_data.card_key], G.deck, nil, nil, nil)
                    
                    _card:set_ability(card_data.ability)
                    _card:set_edition(card_data.edition)
                    _card:set_seal(card_data.seal)
                    _card:juice_up()
                    
                    return true
                end
            }))
            return {
                message = localize('k_plus_card'),
                colour = G.C.BLUE
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_bard',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_bard',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                mult_mod = card.ability.extra.mult
            }
        end
        if context.repetition and context.cardarea == G.play then
            -- Retrigger last face card played
            local last_face = nil
            for i = #context.scoring_hand, 1, -1 do
                if context.scoring_hand[i]:is_face() then
                    last_face = context.scoring_hand[i]
                    break
                end
            end
            if last_face and context.other_card == last_face then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_monk',
    discovered = true,
    config = { extra = { chips = 20 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_monk',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.scoring_hand do
                local id = context.scoring_hand[i]:get_id()
                if id >= 2 and id <= 4 then
                    count = count + 1
                end
            end
            if count > 0 then
                return {
                    message = localize{type='variable', key='a_chips', vars={card.ability.extra.chips * count}},
                    chip_mod = card.ability.extra.chips * count
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_hunter',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_hunter',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.blind and G.GAME.blind.boss then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                mult_mod = card.ability.extra.mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_blacksmith',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_blacksmith',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_platinum or context.other_card.ability.effect == 'Steel Card' then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
        if context.individual and context.cardarea == G.hand and not context.end_of_round then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_platinum or context.other_card.ability.effect == 'Steel Card' then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_merchant',
    discovered = true,
    config = { extra = { money = 2 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_merchant',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_plastic or context.other_card.ability.effect == 'Gold Card' then
                ease_dollars(card.ability.extra.money)
                return {
                    extra = {focus = context.other_card, message = localize('$')..card.ability.extra.money, colour = G.C.MONEY},
                    card = card
                }
            end
        end
        if context.individual and context.cardarea == G.hand and not context.end_of_round then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_plastic or context.other_card.ability.effect == 'Gold Card' then
                ease_dollars(card.ability.extra.money)
                return {
                    extra = {focus = context.other_card, message = localize('$')..card.ability.extra.money, colour = G.C.MONEY},
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_alchemist',
    discovered = true,
    config = { extra = { odds = 5 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_alchemist',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.odds } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.c_base and pseudorandom('alchemist') < G.GAME.probabilities.normal / card.ability.extra.odds then
                context.other_card:set_ability(G.P_CENTERS.m_odyssey_platinum)
                return {
                    extra = {focus = context.other_card, message = localize('k_platinum'), colour = G.C.CHIPS},
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_seer',
    discovered = true,
    config = { extra = { mult = 5 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_seer',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local next_card = (G.deck and G.deck.cards) and G.deck.cards[#G.deck.cards] or nil
        local next_suit = next_card and next_card.base.suit or 'None'
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult, next_suit } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                mult_mod = card.ability.extra.mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_peasant',
    discovered = true,
    config = { extra = { mult = 5 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_peasant',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.scoring_hand do
                local id = context.scoring_hand[i]:get_id()
                if id >= 2 and id <= 5 then
                    count = count + 1
                end
            end
            if count > 0 then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult * count}},
                    mult_mod = card.ability.extra.mult * count
                }
            end
        end
    end
})


SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_barbarian_king',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_barbarian_king',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local only_black = true
            for i = 1, #context.full_hand do
                if context.full_hand[i]:is_suit('Hearts') or context.full_hand[i]:is_suit('Diamonds') then
                    only_black = false
                    break
                end
            end
            if only_black and #context.full_hand > 0 then
                return {
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                    x_mult = card.ability.extra.x_mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_fairy_queen',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_fairy_queen',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local only_red = true
            for i = 1, #context.full_hand do
                if context.full_hand[i]:is_suit('Spades') or context.full_hand[i]:is_suit('Clubs') then
                    only_red = false
                    break
                end
            end
            if only_red and #context.full_hand > 0 then
                return {
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                    x_mult = card.ability.extra.x_mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_archmage',
    discovered = true,
    config = { extra = { mult_per_club = 10 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_archmage',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.playing_cards then
            for _, c in ipairs(G.playing_cards) do
                if c:is_suit('Clubs') then count = count + 1 end
            end
        end
        return { vars = { card.ability.extra.mult_per_club, count, count * card.ability.extra.mult_per_club } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for _, c in ipairs(G.playing_cards) do
                if c:is_suit('Clubs') then count = count + 1 end
            end
            if count > 0 then
                return {
                    message = localize{type='variable', key='a_mult', vars={count * card.ability.extra.mult_per_club}},
                    mult_mod = count * card.ability.extra.mult_per_club
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_grandmaster',
    discovered = true,
    config = { extra = { x_mult = 1.5 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_grandmaster',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.hand and not context.end_of_round then
            if context.other_card:is_face() then
                return {
                    x_mult = card.ability.extra.x_mult,
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_assassin',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_assassin',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint and #G.hand.cards > 0 then
            local lowest_card = G.hand.cards[1]
            for i = 2, #G.hand.cards do
                if G.hand.cards[i]:get_id() < lowest_card:get_id() then
                    lowest_card = G.hand.cards[i]
                end
            end
            if not lowest_card.ability.eternal then lowest_card:start_dissolve() end
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_berserker',
    discovered = true,
    config = { extra = { mult = 50, discards = 1 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_berserker',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.discards } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                mult_mod = card.ability.extra.mult
            }
        end
    end,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards
        ease_discard(-card.ability.extra.discards)
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards
        ease_discard(card.ability.extra.discards)
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_shaman',
    discovered = true,
    config = { extra = {} },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_shaman',
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint and not G.GAME.current_round.odyssey_shaman_activated then
            G.GAME.current_round.odyssey_shaman_activated = true
            local suits = {'Spades', 'Hearts', 'Clubs', 'Diamonds'}
            local new_suit = pseudorandom_element(suits, pseudoseed('shaman'))
            for i = 1, #G.hand.cards do
                G.hand.cards[i]:change_suit(new_suit)
            end
            return {
                message = localize('k_suit'),
                colour = G.C.PURPLE
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_knight',
    discovered = true,
    config = { extra = { chips = 0, chip_gain = 50 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_knight',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.chip_gain } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_face() then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
        if context.end_of_round and G.GAME.blind and G.GAME.blind.boss and not context.blueprint and not context.other_card then
            card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chip_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.CHIPS
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_ninja',
    discovered = true,
    config = { extra = { odds = 4 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_ninja',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.odds } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_face() and pseudorandom('ninja') < G.GAME.probabilities.normal / card.ability.extra.odds then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = copy_card(context.other_card, nil)
                        _card:add_to_deck()
                        table.insert(G.playing_cards, _card)
                        G.deck:emplace(_card)
                        _card:juice_up()
                        return true
                    end
                }))
                return {
                    extra = {focus = context.other_card, message = localize('k_plus_card'), colour = G.C.BLUE},
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_samurai',
    discovered = true,
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_samurai',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'High Card' then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_viking',
    discovered = true,
    config = { extra = { money_per_card = 1 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_viking',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = G.GAME.viking_destroyed_count or 0
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).money_per_card, count, count * ( (card and card.ability and card.ability.extra) or self.config.extra ).money_per_card } }
    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.blueprint and not context.other_card then
            local count = G.GAME.viking_destroyed_count or 0
            if count > 0 then
                ease_dollars(count * card.ability.extra.money_per_card)
                return {
                    message = localize('$')..(count * card.ability.extra.money_per_card),
                    colour = G.C.MONEY
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_pirate',
    discovered = true,
    config = { extra = { money = 3 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_pirate',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'Flush' then
            ease_dollars(card.ability.extra.money)
            return {
                message = localize('$')..card.ability.extra.money,
                colour = G.C.MONEY
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_gladiator',
    discovered = true,
    config = { extra = { mult_per_card = 10 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_gladiator',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult_per_card } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = #G.hand.cards
            if count > 0 then
                return {
                    message = localize{type='variable', key='a_mult', vars={count * card.ability.extra.mult_per_card}},
                    mult_mod = count * card.ability.extra.mult_per_card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_musketeer',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_musketeer',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'Three of a Kind' then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_legionnaire',
    discovered = true,
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_legionnaire',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'Four of a Kind' then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_emperor',
    discovered = true,
    config = { extra = {} },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_emperor',
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and G.GAME.current_round.hands_played == 1 and not context.blueprint and not context.other_card then
            if #G.consumeables.cards < G.consumeables.config.card_limit then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, 'c_emperor', 'emperor')
                        _card:add_to_deck()
                        G.consumeables:emplace(_card)
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_tarot'),
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_high_priestess',
    discovered = true,
    config = { extra = {} },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_high_priestess',
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and G.GAME.current_round.discards_used == 0 and not context.blueprint and not context.other_card then
            if #G.consumeables.cards < G.consumeables.config.card_limit then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, 'c_high_priestess', 'high_priestess')
                        _card:add_to_deck()
                        G.consumeables:emplace(_card)
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_tarot'),
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_the_hermit',
    discovered = true,
    config = { extra = {} },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_the_hermit',
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and G.GAME.dollars == 0 and not context.blueprint and not context.other_card then
            if #G.consumeables.cards < G.consumeables.config.card_limit then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, 'c_hermit', 'hermit')
                        _card:add_to_deck()
                        G.consumeables:emplace(_card)
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_tarot'),
                    colour = G.C.PURPLE
                }
            end
        end
    end
})


SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_council_of_kings',
    discovered = true,
    config = { extra = { x_mult = 4, count_needed = 4, rank = 13 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_council_of_kings',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.count_needed } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == card.ability.extra.rank then
                    count = count + 1
                end
            end
            if count >= card.ability.extra.count_needed then
                return {
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                    x_mult = card.ability.extra.x_mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_harem',
    discovered = true,
    config = { extra = { x_mult = 4, count_needed = 4, rank = 12 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_harem',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.count_needed } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == card.ability.extra.rank then
                    count = count + 1
                end
            end
            if count >= card.ability.extra.count_needed then
                return {
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                    x_mult = card.ability.extra.x_mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_brotherhood',
    discovered = true,
    config = { extra = { x_mult = 4, count_needed = 4, rank = 11 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_brotherhood',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.count_needed } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == card.ability.extra.rank then
                    count = count + 1
                end
            end
            if count >= card.ability.extra.count_needed then
                return {
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                    x_mult = card.ability.extra.x_mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_mage_circle',
    discovered = true,
    config = { extra = { consumable_slots = 1 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_mage_circle',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.consumable_slots } }

    end,
    add_to_deck = function(self, card, from_debuff)
        G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra.consumable_slots
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.consumeables.config.card_limit = G.consumeables.config.card_limit - card.ability.extra.consumable_slots
    end,
    calculate = function(self, card, context)
        -- Passive effect for Tarot frequency handled in pool overrides
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_thieves_guild',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_thieves_guild',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.after_hand then
            ease_dollars(card.ability.extra.money)
            return {
                message = localize('$')..card.ability.extra.money,
                colour = G.C.MONEY
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_holy_order',
    discovered = true,
    config = { extra = { mult = 20 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_holy_order',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            for i = 1, #G.hand.cards do
                G.hand.cards[i].debuff = false
            end
            return {
                message = localize('k_active_ex'),
                colour = G.C.WHITE
            }
        end
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                mult_mod = card.ability.extra.mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_shadow_army',
    discovered = true,
    config = { extra = {} },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_shadow_army',
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and not context.blueprint then
            local cards_to_copy = {}
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:is_face() then
                    table.insert(cards_to_copy, context.scoring_hand[i])
                end
            end
            if #cards_to_copy > 0 then
                for _, face_card in ipairs(cards_to_copy) do
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            local _card = copy_card(face_card, nil)
                            _card:add_to_deck()
                            table.insert(G.playing_cards, _card)
                            G.deck:emplace(_card)
                            _card:juice_up()
                            return true
                        end
                    }))
                end
                return {
                    message = localize('k_plus_card'),
                    colour = G.C.BLUE
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_champion',
    discovered = true,
    config = { extra = { x_mult = 3, permanent_gain = 0.5 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_champion',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.permanent_gain } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
        if context.end_of_round and G.GAME.blind and G.GAME.blind.boss and not context.blueprint and not context.other_card then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.permanent_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_dark_lord',
    discovered = true,
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_dark_lord',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end,
    add_to_deck = function(self, card, from_debuff)
        if not from_debuff then
            local face_cards = {}
            for i = #G.playing_cards, 1, -1 do
                if G.playing_cards[i]:is_face() then
                    table.insert(face_cards, G.playing_cards[i])
                end
            end
            for _, face_card in ipairs(face_cards) do
                if not face_card.ability.eternal then face_card:start_dissolve() end
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_hero',
    discovered = true,
    config = { extra = { x_mult = 5, hands_needed = 1 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_hero',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.hands_needed } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_left == card.ability.extra.hands_needed then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end
})


SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_king_of_kings',
    discovered = true,
    config = { extra = { x_mult = 5 } },
    rarity = 4,
    cost = 20,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_king_of_kings',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    add_to_deck = function(self, card)
        G.GAME.odyssey_king_of_kings_active = (G.GAME.odyssey_king_of_kings_active or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_king_of_kings_active = (G.GAME.odyssey_king_of_kings_active or 0) - 1
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_god_of_war',
    discovered = true,
    config = { extra = { x_mult = 5, scaling = 1 } },
    rarity = 4,
    cost = 20,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_god_of_war',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.scaling } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
        if context.after_hand and not context.blueprint and not context.other_card then
            local count = #context.scoring_hand
            if count > 0 then
                card.ability.extra.x_mult = card.ability.extra.x_mult + (count * card.ability.extra.scaling)
                for i = 1, #context.scoring_hand do
                    context.scoring_hand[i]:start_dissolve()
                end
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT
                }
            end
        end
    end
})


----------------------------------------------
-- PROFESSIONS GROUP (COMMON)
----------------------------------------------

-- 501. Miner
SMODS.Joker({
    key = 'j_professions_miner',
    atlas = 'j_professions_miner',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { chance = 4 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context)
        if context.discard and not context.other_card then -- Trigger once per discard action
             if pseudorandom('miner') < G.GAME.probabilities.normal / card.ability.extra.chance then
                 G.E_MANAGER:add_event(Event({func = function()
                     local c = create_playing_card(pseudorandom_element(G.P_CARDS, pseudoseed('miner_card')), G.deck, nil, nil, nil)
                     c:set_ability(G.P_CENTERS.m_odyssey_emerald)
                     c:add_to_deck()
                     G.deck:emplace(c)
                     return true
                 end}))
                 return { message = localize('k_plus_stone'), colour = G.C.SECONDARY_SET.Enhanced }
             end
        end
    end
})

-- 502. Farmer
SMODS.Joker({
    key = 'j_professions_farmer',
    atlas = 'j_professions_farmer',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for k, v in pairs(G.playing_cards) do
                local id = v:get_id()
                if id >= 2 and id <= 5 then count = count + 1 end
            end
             return { mult_mod = count * card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={count * card.ability.extra.mult}} }
        end
    end
})

-- 503. Fisherman
SMODS.Joker({
    key = 'j_professions_fisherman',
    atlas = 'j_professions_fisherman',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { chance = 3 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
             if pseudorandom('fisherman') < G.GAME.probabilities.normal / card.ability.extra.chance then
                 G.E_MANAGER:add_event(Event({
                    trigger = 'before',
                    delay = 0.4,
                    func = function()
                        local card = create_card(nil, G.consumeables, nil, nil, nil, nil, nil, 'fish')
                        card:add_to_deck()
                        G.consumeables:emplace(card)
                        return true
                    end
                }))
                return { message = localize('k_plus_card'), colour = G.C.SECONDARY_SET.Tarot }
             end
        end
    end
})

-- 504. Chef
SMODS.Joker({
    key = 'j_professions_chef',
    atlas = 'j_professions_chef',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if #G.jokers.cards < G.jokers.config.card_limit then
                local food_jokers = { 'j_gros_michel', 'j_ice_cream', 'j_turtle_bean', 'j_popcorn', 'j_ramen', 'j_selzer' }
                local chosen_food = food_jokers[pseudorandom('chef', 1, #food_jokers)]
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local card = create_card('Joker', G.jokers, nil, nil, nil, nil, chosen_food, 'chef')
                        card:add_to_deck()
                        G.jokers:emplace(card)
                        return true
                    end
                }))
                return { message = localize('k_plus_joker'), colour = G.C.BLUE }
            end
        end
    end
})

-- 505. Doctor
SMODS.Joker({
    key = 'j_professions_doctor',
    atlas = 'j_professions_doctor',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = false,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.game_over and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                func = function()
                    G.hand_text_area.card_eval_status_text:ease_text(localize('k_saved_ex'), 0.5, 0.5, 0.5)
                    G.GAME.round_resets.hands = G.GAME.round_resets.hands + 1
                    if not card.ability.eternal then card:start_dissolve() end
                    return true
                end
            }))
            return { saved = true }
        end
    end
})

-- 506. Engineer
SMODS.Joker({
    key = 'j_professions_engineer',
    atlas = 'j_professions_engineer',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.current_round.hands_played == 1 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        G.jokers.config.card_limit = G.jokers.config.card_limit + 1
                        return true
                    end
                }))
                return { message = localize('k_plus_joker_slot'), colour = G.C.DARK_EDITION }
            end
        end
    end
})

-- 507. Architect
SMODS.Joker({
    key = 'j_professions_architect',
    atlas = 'j_professions_architect',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { hand_size = 1 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.hand_size } }

    end,
    add_to_deck = function(self, card) G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size end,
    remove_from_deck = function(self, card) G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 508. Astronomer
SMODS.Joker({
    key = 'j_professions_astronomer',
    atlas = 'j_professions_astronomer',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_astronomer_planets_free = (G.GAME.odyssey_astronomer_planets_free or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_astronomer_planets_free = (G.GAME.odyssey_astronomer_planets_free or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 509. Librarian
SMODS.Joker({
    key = 'j_professions_librarian',
    atlas = 'j_professions_librarian',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { chips = 10 } },
    loc_vars = function(self, info_queue, card)
        local views = G.GAME.odyssey_deck_clicks or 0
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).chips, views, ( (card and card.ability and card.ability.extra) or self.config.extra ).chips * views } }
    end,
    add_to_deck = function(self, card) G.GAME.odyssey_librarian_active = (G.GAME.odyssey_librarian_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_librarian_active = (G.GAME.odyssey_librarian_active or 0) - 1 end,
    calculate = function(self, card, context)
         if context.joker_main then
              local views = G.GAME.odyssey_deck_clicks or 0
              return { chip_mod = views * card.ability.extra.chips, message = localize{type='variable',key='a_chips',vars={views * card.ability.extra.chips}} }
        end
    end
})

-- 510. Mailman
SMODS.Joker({
    key = 'j_professions_mailman',
    atlas = 'j_professions_mailman',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { dollars = 1 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.discard and context.other_card and context.other_card:get_id() == 14 then
             ease_dollars(card.ability.extra.dollars)
             return { message = localize('$')..card.ability.extra.dollars, colour = G.C.MONEY }
        end
    end
})

-- 511. Firefighter
SMODS.Joker({
    config = { odyssey_immune = true },
    key = 'j_professions_firefighter',
    atlas = 'j_professions_firefighter',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_firefighter_active = (G.GAME.odyssey_firefighter_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_firefighter_active = (G.GAME.odyssey_firefighter_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 512. Police
SMODS.Joker({
    key = 'j_professions_police',
    atlas = 'j_professions_police',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { dollars = 5 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'High Card' then
             ease_dollars(card.ability.extra.dollars)
             return { message = localize('$')..card.ability.extra.dollars, colour = G.C.MONEY }
        end
    end
})

-- 513. Judge
SMODS.Joker({
    key = 'j_professions_judge',
    atlas = 'j_professions_judge',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 10 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and #context.scoring_hand == 5 then
             return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
        end
    end
})

-- 514. Lawyer
SMODS.Joker({
    key = 'j_professions_lawyer',
    atlas = 'j_professions_lawyer',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 15 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
        end
    end
})

-- 515. Teacher
SMODS.Joker({
    key = 'j_professions_teacher',
    atlas = 'j_professions_teacher',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult_gain = 2, mult = 0 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult_gain, extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'High Card' then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
            return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
        end
    end
})

-- 516. Student
SMODS.Joker({
    key = 'j_professions_student',
    atlas = 'j_professions_student',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 0, gain = 1, rounds = 0, graduated = false } },

    loc_vars = function(self, info_queue, card)
        -- Protección contra 'nil' si se ve desde la colección
        local mult = card and card.ability and card.ability.extra.mult or 0
        local rounds = card and card.ability.extra.rounds or 0
        local gain = card and card.ability.extra.gain or 1
        
        -- #1: Ganancia, #2: Mult Actual, #3: Rondas
        return { vars = { gain, mult, rounds } }
    end,

    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.rounds = card.ability.extra.rounds + 1
            
            -- Si llega a 10 rondas, se gradúa
            if card.ability.extra.rounds >= 10 then 
                card.ability.extra.graduated = true 
            end
            
            -- Si NO está graduado, sigue ganando Mult
            if not card.ability.extra.graduated then
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            elseif card.ability.extra.graduated and card.ability.extra.rounds == 10 then
                -- Mensaje único justo cuando se gradúa
                return {
                    message = "Graduated!",
                    colour = G.C.PURPLE,
                    card = card
                }
            end
        end

        if context.joker_main then
            if card.ability.extra.graduated then
                 return { 
                    x_mult = 2, 
                    message = localize{type='variable',key='a_xmult',vars={2}} 
                 }
            else
                 return { 
                    mult_mod = card.ability.extra.mult, 
                    message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} 
                 }
            end
        end
    end
})

-- 517. Scientist
SMODS.Joker({
    key = 'j_professions_scientist',
    atlas = 'j_professions_scientist',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { chance = 4 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
             if pseudorandom('scientist') < G.GAME.probabilities.normal / card.ability.extra.chance then
                local card_to_upgrade = pseudorandom_element(context.scoring_hand, pseudoseed('scientist_card'))
                local enhancements = { 'm_bonus', 'm_mult', 'm_wild', 'm_odyssey_ceramic', 'm_odyssey_platinum', 'm_odyssey_emerald', 'm_odyssey_plastic', 'm_lucky' }
                local enhancement = pseudorandom_element(enhancements, pseudoseed('scientist_enh'))
                card_to_upgrade:set_ability(G.P_CENTERS[enhancement])
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.CHIPS,
                    card = card_to_upgrade
                }
             end
        end
    end
})

-- 518. Artist
SMODS.Joker({
    key = 'j_professions_artist',
    atlas = 'j_professions_artist',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { chips = 10 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_face() then
                 return { chips = card.ability.extra.chips, card = card }
            end
        end
    end
})

-- 519. Musician
SMODS.Joker({
    key = 'j_professions_musician',
    atlas = 'j_professions_musician',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 10 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
         if context.joker_main and next(context.poker_hands['Straight']) then
              return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
        end
    end
})

-- 520. Actor
SMODS.Joker({
    key = 'j_professions_actor',
    atlas = 'j_professions_actor',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        local right_joker = nil
        for i = 1, #G.jokers.cards do
            if G.jokers.cards[i] == card then
                right_joker = G.jokers.cards[i+1]
                break
            end
        end
        if right_joker and right_joker ~= card then
            context.blueprint = (context.blueprint or 0) + 1
            context.blueprint_card = card
            local res = right_joker:calculate_joker(context)
            if res then
                res.card = card
                return res
            end
        end
    end
})



----------------------------------------------
-- PROFESSIONS GROUP (UNCOMMON)
----------------------------------------------

-- 521. Surgeon
SMODS.Joker({
    key = 'j_professions_surgeon',
    atlas = 'j_professions_surgeon',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.pre_discard and not context.blueprint and #context.full_hand == 2 then
            local card1 = context.full_hand[1]
            local card2 = context.full_hand[2]
            if card1.base.value == card2.base.value then
                local new_rank = card1.base.id + 1
                if new_rank > 14 then new_rank = 14 end
                
                -- Construct key: 10 -> T, 11 -> J, etc.
                local rank_suffix = tostring(new_rank)
                if new_rank == 10 then rank_suffix = 'T'
                elseif new_rank == 11 then rank_suffix = 'J'
                elseif new_rank == 12 then rank_suffix = 'Q'
                elseif new_rank == 13 then rank_suffix = 'K'
                elseif new_rank == 14 then rank_suffix = 'A'
                end
                local suit_prefix = card1.base.suit:sub(1,1)
                local target_key = suit_prefix..'_'..rank_suffix
                
                if G.P_CARDS[target_key] then
                    G.E_MANAGER:add_event(Event({
                        trigger = 'after',
                        delay = 0.2,
                        func = function()
                            local _card = create_playing_card({front = G.P_CARDS[target_key], center = G.P_CENTERS.c_base}, G.hand, nil, nil, {G.C.SECONDARY_SET.Enhanced})
                            _card:juice_up()
                            return true
                        end
                    }))
                    return {
                        message = localize('k_active_ex'),
                        card = card
                    }
                end
            end
        end
    end
})

-- 522. Chemist
SMODS.Joker({
    key = 'j_professions_chemist',
    atlas = 'j_professions_chemist',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local cards_to_change = {}
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i].config.center == G.P_CENTERS.m_odyssey_plastic then
                    cards_to_change[#cards_to_change+1] = context.scoring_hand[i]
                end
            end
            if #cards_to_change > 0 then
                for i=1, #cards_to_change do
                    cards_to_change[i]:set_ability(G.P_CENTERS.m_odyssey_platinum)
                    cards_to_change[i]:juice_up()
                end
                return {
                    message = localize('k_active_ex'),
                    colour = G.C.GOLD
                }
            end
        end
    end
})

-- 523. Geologist
SMODS.Joker({
    key = 'j_professions_geologist',
    atlas = 'j_professions_geologist',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { chips = 50 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_emerald then
                return { chips = card.ability.extra.chips, card = card }
            end
        end
    end
})

-- 524. Botanist
SMODS.Joker({
    key = 'j_professions_botanist',
    atlas = 'j_professions_botanist',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 1.5 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Clubs') then
                return { x_mult = card.ability.extra.x_mult, card = card }
            end
        end
    end
})

-- 525. Zoologist
SMODS.Joker({
    key = 'j_professions_zoologist',
    atlas = 'j_professions_zoologist',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
         if context.joker_main and next(context.poker_hands['Pair']) then
             return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
        end
    end
})

-- 526. Archaeologist
SMODS.Joker({
    key = 'j_professions_archaeologist',
    atlas = 'j_professions_archaeologist',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    add_to_deck = function(self, card) G.GAME.odyssey_archaeologist_active = (G.GAME.odyssey_archaeologist_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_archaeologist_active = (G.GAME.odyssey_archaeologist_active or 0) - 1 end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local is_old = false
            for i=1, math.min(10, #G.deck.cards) do
                if G.deck.cards[i] == context.other_card then is_old = true break end
            end
            if is_old then
                return {
                    x_mult = card.ability.extra.x_mult,
                    card = card
                }
            end
        end
    end
})

-- 527. Historian
SMODS.Joker({
    key = 'j_professions_historian',
    atlas = 'j_professions_historian',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
         if context.joker_main then
             local r = G.GAME.round or 0
             return { mult_mod = r, message = localize{type='variable',key='a_mult',vars={r}} }
        end
    end
})

-- 528. Futurist
SMODS.Joker({
    key = 'j_professions_futurist',
    atlas = 'j_professions_futurist',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 15 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
        end
    end
})

-- 529. Investor
SMODS.Joker({
    key = 'j_professions_investor',
    atlas = 'j_professions_investor',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.blueprint and not context.other_card then
            if G.GAME.dollars >= 50 then
                ease_dollars(5)
                return {
                    message = "$5",
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 530. Banker
SMODS.Joker({
    key = 'j_professions_banker',
    atlas = 'j_professions_banker',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_banker_active = (G.GAME.odyssey_banker_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_banker_active = (G.GAME.odyssey_banker_active or 0) - 1 end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.blueprint and not context.other_card then
            if G.GAME.odyssey_banker_money and G.GAME.odyssey_banker_money > 0 then
                ease_dollars(G.GAME.odyssey_banker_money)
                local m = G.GAME.odyssey_banker_money
                G.GAME.odyssey_banker_money = 0
                return {
                    message = "$" .. m,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 531. Cat Burglar
SMODS.Joker({
    key = 'j_professions_cat_burglar',
    atlas = 'j_professions_cat_burglar',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.buy_joker and not context.blueprint and not G.GAME.odyssey_cat_burglar_used then
             G.GAME.odyssey_cat_burglar_used = true
             ease_dollars(context.card.cost)
             return { message = "Stolen!", colour = G.C.MONEY }
        end
    end
})

-- 532. Spy
SMODS.Joker({
    key = 'j_professions_spy',
    atlas = 'j_professions_spy',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 10 } },
    loc_vars = function(self, info_queue, card)
        local next_card = (G.deck and G.deck.cards) and G.deck.cards[#G.deck.cards] or nil
        local display = "None"
        if next_card then
            display = next_card.base.value .. " of " .. next_card.base.suit
        end
        return { vars = { card.ability.extra.mult, display } }
    end,
    add_to_deck = function(self, card) G.GAME.odyssey_spy_active = (G.GAME.odyssey_spy_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_spy_active = (G.GAME.odyssey_spy_active or 0) - 1 end,
    calculate = function(self, card, context)
         if context.joker_main then
              return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
         end
    end
})

-- 533. Diplomat
SMODS.Joker({
    key = 'j_professions_diplomat',
    atlas = 'j_professions_diplomat',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_diplomat_active = (G.GAME.odyssey_diplomat_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_diplomat_active = (G.GAME.odyssey_diplomat_active or 0) - 1 end,
    calculate = function(self, card, context)
        -- Logic handled in Blind:set_blind override
    end
})

-- 534. General
SMODS.Joker({
    key = 'j_professions_general',
    atlas = 'j_professions_general',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { xmult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
         if context.joker_main and G.GAME.current_round.hands_played == 0 then
             return { x_mult = card.ability.extra.xmult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.xmult}} }
        end
    end
})

-- 535. Admiral
SMODS.Joker({
    key = 'j_professions_admiral',
    atlas = 'j_professions_admiral',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { xmult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
         if context.joker_main and G.GAME.current_round.hands_left == 0 then
             return { x_mult = card.ability.extra.xmult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.xmult}} }
        end
    end
})

-- 536. Astronaut
SMODS.Joker({
    key = 'j_professions_astronaut',
    atlas = 'j_professions_astronaut',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 20 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
         if context.joker_main then
              return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
         end
    end
})

-- 537. Diver
SMODS.Joker({
    key = 'j_professions_diver',
    atlas = 'j_professions_diver',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 20 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
         if context.joker_main then
            local black = true
            for k, v in ipairs(context.scoring_hand) do
                if v:is_suit('Hearts') or v:is_suit('Diamonds') then black = false end
            end
            if black then
                  return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
            end
         end
    end
})

-- 538. Pilot
SMODS.Joker({
    key = 'j_professions_pilot',
    atlas = 'j_professions_pilot',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + 1
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - 1
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - 1
    end,
    calculate = function(self, card, context)
        -- Passive
    end
})



----------------------------------------------
-- PROFESSIONS GROUP (RARE)
----------------------------------------------

-- 539. CEO
SMODS.Joker({
    key = 'j_professions_ceo',
    atlas = 'j_professions_ceo',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 3, money = 1 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            local dollars = #G.jokers.cards * card.ability.extra.money
            ease_dollars(dollars)
            return { message = localize('$')..dollars, colour = G.C.MONEY }
        end
    end
})

-- 540. President
SMODS.Joker({
    key = 'j_professions_president',
    atlas = 'j_professions_president',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 4, money = 10 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
             ease_dollars(card.ability.extra.money)
            return { message = localize('$')..card.ability.extra.money, colour = G.C.MONEY }
        end
    end
})

-- 541. Dictator
SMODS.Joker({
    key = 'j_professions_dictator',
    atlas = 'j_professions_dictator',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 5 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             -- Only works if playing the most played hand
             local most_played = 'High Card'
             local max_p = 0
             for k, v in pairs(G.GAME.hands) do
                 if v.played > max_p then
                     max_p = v.played
                     most_played = k
                 end
             end
             if context.scoring_name == most_played then
                return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
             end
        end
    end
})

-- 542. Revolutionary
SMODS.Joker({
    key = 'j_professions_revolutionary',
    atlas = 'j_professions_revolutionary',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.blueprint and not context.other_card then
            local most_expensive = nil
            local max_cost = -1
            for i=1, #G.jokers.cards do
                local j = G.jokers.cards[i]
                if j ~= card and j.cost > max_cost then
                    max_cost = j.cost
                    most_expensive = j
                end
            end
            if most_expensive then
                most_expensive:start_dissolve()
                G.GAME.odyssey_revolutionary_active = (G.GAME.odyssey_revolutionary_active or 0) + 1
                return {
                    message = "X3 Mult!",
                    colour = G.C.MULT
                }
            end
        end
        if context.joker_main and G.GAME.odyssey_revolutionary_active and G.GAME.odyssey_revolutionary_active > 0 then
             local total_x = 3 ^ G.GAME.odyssey_revolutionary_active
             return { x_mult = total_x, message = "X"..total_x }
        end
    end
})

-- 543. Prophet
SMODS.Joker({
    key = 'j_professions_prophet',
    atlas = 'j_professions_prophet',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    add_to_deck = function(self, card)
        G.GAME.modifiers.booster_view_all = true
    end,
    remove_from_deck = function(self, card)
        G.GAME.modifiers.booster_view_all = false
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
        end
    end
})

-- 544. Magician
SMODS.Joker({
    key = 'j_professions_magician',
    atlas = 'j_professions_magician',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_magician_active = (G.GAME.odyssey_magician_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_magician_active = (G.GAME.odyssey_magician_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 545. Illusionist
SMODS.Joker({
    key = 'j_professions_illusionist',
    atlas = 'j_professions_illusionist',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 3 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
        end
    end
})

-- 546. Hypnotist
SMODS.Joker({
    key = 'j_professions_hypnotist',
    atlas = 'j_professions_hypnotist',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 3 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'Straight' then
            local has_face = false
            for k, v in ipairs(context.scoring_hand) do
                if v:get_id() >= 11 and v:get_id() <= 13 then has_face = true break end
            end
            if has_face then
                return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
            end
        end
    end
})

-- 547. Beast Tamer
SMODS.Joker({
    key = 'j_professions_beast_tamer',
    atlas = 'j_professions_beast_tamer',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_wild then
                return { x_mult = card.ability.extra.x_mult, card = card }
            end
        end
    end
})

-- 548. Foreman
SMODS.Joker({
    key = 'j_professions_foreman',
    atlas = 'j_professions_foreman',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { rounds = 0 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.rounds } }

    end,
    calculate = function(self, card, context)
         if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.rounds = card.ability.extra.rounds + 1
            if card.ability.extra.rounds == 5 then
                 G.jokers.config.card_limit = G.jokers.config.card_limit + 1
                 return { left = true, message = localize('k_plus_joker_slot') }
            end
         end
    end
})



----------------------------------------------
-- PROFESSIONS GROUP (LEGENDARY)
----------------------------------------------

-- 549. Guild Master
SMODS.Joker({
    key = 'j_professions_guild_master',
    atlas = 'j_professions_guild_master',
    pos = { x = 0, y = 0 },
    rarity = 4,
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 3, gain = 0.5 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.gain } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.jokers and G.jokers.cards then
                for _, j in ipairs(G.jokers.cards) do
                    if j.config.center.key:find('professions') then
                        count = count + 1
                    end
                end
            end
            local total_xmult = card.ability.extra.x_mult + (count * card.ability.extra.gain)
            return { x_mult = total_xmult, message = localize{type='variable',key='a_xmult',vars={total_xmult}} }
        end
    end
})

-- 550. Tycoon
SMODS.Joker({
    key = 'j_professions_tycoon',
    atlas = 'j_professions_tycoon',
    pos = { x = 0, y = 0 },
    rarity = 4,
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 5, huge_mult = 10, threshold = 100 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.huge_mult, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local mult = card.ability.extra.x_mult
            if G.GAME.dollars >= card.ability.extra.threshold then
                mult = card.ability.extra.huge_mult
            end
             return { x_mult = mult, message = localize{type='variable',key='a_xmult',vars={mult}} }
        end
    end
})



-- ============================================
-- ECONOMY - Common (Jokers 551-570)
-- ============================================

-- 551: Piggy Bank
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_piggy_bank',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_piggy_bank',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local dollars = (G.GAME.current_round.hands_left or 0) * card.ability.extra.money
            if dollars > 0 then
                ease_dollars(dollars)
                return {
                    message = localize('$') .. dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 552: Angel Investor
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_angel_investor',
    discovered = true,
    config = { extra = { money = 2, gain = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_angel_investor',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money, extra.gain } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            ease_dollars(card.ability.extra.money)
            local ret = {
                message = localize('$') .. card.ability.extra.money,
                colour = G.C.MONEY
            }
            if not context.blueprint then
                card.ability.extra.money = card.ability.extra.money + card.ability.extra.gain
            end
            return ret
        end
    end
})

-- 553: Clearance Sale
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_clearance_sale',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_clearance_sale',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_clearance_sale = (G.GAME.odyssey_clearance_sale or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_clearance_sale = (G.GAME.odyssey_clearance_sale or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 554: Coupon
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_coupon',
    discovered = true,
    config = { extra = { active = true, last_ante = 0 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_coupon',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card) 
        return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra ).active and "Sim" or "Não") } } 
    end,
    calculate = function(self, card, context)
        -- Reset at new Ante
        if context.setting_blind and not context.blueprint then
            if (card.ability.extra.last_ante or 0) < G.GAME.round_resets.ante then
                card.ability.extra.last_ante = G.GAME.round_resets.ante
                card.ability.extra.active = true
            end
        end

        -- Consume when buying an item
        if (context.buying_card or context.buying_consumeable) and not context.blueprint and card.ability.extra.active then
            if not context.odyssey_coupon_consumed then
                card.ability.extra.active = false
                context.odyssey_coupon_consumed = true
                return {
                    message = "Livre!",
                    colour = G.C.GOLD
                }
            end
        end
    end
})

-- 555: Rebate
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_rebate',
    discovered = true,
    config = { extra = { money = 1, max = 5, current = 0 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_rebate',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money, extra.max, extra.current } }

    end,
    calculate = function(self, card, context)
        if context.discard and not context.other_card then
            if card.ability.extra.current < card.ability.extra.max then
                card.ability.extra.current = card.ability.extra.current + 1
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current = 0
        end
    end
})

-- 556: Service Fee
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_service_fee',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_service_fee',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            ease_dollars(card.ability.extra.money)
            return {
                message = localize('$') .. card.ability.extra.money,
                colour = G.C.MONEY
            }
        end
    end
})

-- 557: Tip Jar
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_tip_jar',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_tip_jar',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and #context.scoring_hand == 1 then
            ease_dollars(card.ability.extra.money)
            return {
                message = localize('$') .. card.ability.extra.money,
                colour = G.C.MONEY
            }
        end
    end
})

-- 558: Black Market
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_black_market',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_black_market',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card) G.GAME.odyssey_black_market_active = (G.GAME.odyssey_black_market_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_black_market_active = (G.GAME.odyssey_black_market_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 559: Loan Shark
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_loan_shark',
    discovered = true,
    config = { extra = { money = 20, loss = 2 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_loan_shark',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money, extra.loss } }

    end,
    add_to_deck = function(self, card)
        ease_dollars(card.ability.extra.money)
    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            ease_dollars(-card.ability.extra.loss)
            return {
                message = "-" .. localize('$') .. card.ability.extra.loss,
                colour = G.C.RED
            }
        end
    end
})

-- 560: Inheritance
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_inheritance',
    discovered = true,
    config = { extra = { money = 10 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_inheritance',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card and (G.GAME.dollars or 0) <= 0 then
            ease_dollars(card.ability.extra.money)
            return {
                message = localize('$') .. card.ability.extra.money,
                colour = G.C.MONEY
            }
        end
    end
})

-- 561: Tithe
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_tithe',
    discovered = true,
    config = { extra = { mult = 10, threshold = 20 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_tithe',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if (G.GAME.dollars or 0) > card.ability.extra.threshold then
                local fee = math.floor((G.GAME.dollars or 0) * 0.1)
                if fee > 0 then
                    ease_dollars(-fee)
                    return {
                        message = "-" .. localize('$') .. fee,
                        colour = G.C.RED
                    }
                end
            end
        end
        if context.joker_main and (G.GAME.dollars or 0) > card.ability.extra.threshold then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- 562: Inflation
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_inflation',
    discovered = true,
    config = { extra = { x_mult = 2, cost_inc = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_inflation',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.cost_inc } }

    end,
    add_to_deck = function(self, card) G.GAME.odyssey_inflation_active = (G.GAME.odyssey_inflation_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_inflation_active = (G.GAME.odyssey_inflation_active or 0) - 1 end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- 563: Deflation
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_deflation',
    discovered = true,
    config = { extra = { chips = 50, cost_dec = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_deflation',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.cost_dec } }

    end,
    add_to_deck = function(self, card) G.GAME.odyssey_deflation_active = (G.GAME.odyssey_deflation_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_deflation_active = (G.GAME.odyssey_deflation_active or 0) - 1 end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- 564: Pawn Shop
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_pawn_shop',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_pawn_shop',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card) G.GAME.odyssey_pawn_shop_active = (G.GAME.odyssey_pawn_shop_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_pawn_shop_active = (G.GAME.odyssey_pawn_shop_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 565: Treasure Hunt
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_treasure_hunt',
    discovered = true,
    config = { extra = { chance = 5, money = 5 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_treasure_hunt',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance, extra.money } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Diamonds') then
                if pseudorandom('treasure_hunt') < G.GAME.probabilities.normal / card.ability.extra.chance then
                    ease_dollars(card.ability.extra.money)
                    return {
                        message = localize('$') .. card.ability.extra.money,
                        colour = G.C.MONEY,
                        card = card
                    }
                end
            end
        end
    end
})

-- 566: Gold Mine
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_gold_mine',
    discovered = true,
    config = { extra = { money = 2 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_gold_mine',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_emerald then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 567: Unionizer
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_unionizer',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_unionizer',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local dollars = (#G.jokers.cards or 0) * card.ability.extra.money
            if dollars > 0 then
                ease_dollars(dollars)
                return {
                    message = localize('$') .. dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 568: Accountant
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_accountant',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_accountant',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local d = G.GAME.dollars or 0
            if d % 5 == 0 then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- 569: Auditor
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_auditor',
    discovered = true,
    config = { extra = { chips = 20, gain = 20 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_auditor',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.gain } }

    end,
    add_to_deck = function(self, card) G.GAME.odyssey_auditor_active = (G.GAME.odyssey_auditor_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_auditor_active = (G.GAME.odyssey_auditor_active or 0) - 1 end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
             if not G.GAME.odyssey_money_spent_in_shop then
                card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.CHIPS
                }
             end
             G.GAME.odyssey_money_spent_in_shop = (G.GAME.odyssey_money_spent_in_shop or 0) - 1
        end
    end
})

-- 570: Capitalist
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_capitalist',
    discovered = true,
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_capitalist',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    add_to_deck = function(self, card) G.GAME.odyssey_capitalist_active = (G.GAME.odyssey_capitalist_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_capitalist_active = (G.GAME.odyssey_capitalist_active or 0) - 1 end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})



-- ============================================
-- ECONOMY - Uncommon (Jokers 571-588)
-- ============================================

-- 571: Invisible Hand
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_invisible_hand',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_invisible_hand',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    config = { extra = { x_mult = 1.5 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and (G.GAME.dollars or 0) < 5 then
            return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
        end
    end
})

-- 572: Economic Bubble
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_economic_bubble',
    discovered = true,
    config = { extra = { money = 5, threshold = 50 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_economic_bubble',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if (G.GAME.dollars or 0) >= card.ability.extra.threshold then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        G.GAME.dollars = 0
                        if not card.ability.eternal then card:start_dissolve() end
                        return true
                    end
                }))
                return {
                    message = "POP!",
                    colour = G.C.RED
                }
            else
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 573: Cryptocurrency
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_cryptocurrency',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_cryptocurrency',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            -- The sell value of this Joker fluctuates randomly between $0 and $50 each round.
            local new_val = math.floor(pseudorandom('crypto') * 50)
            card.sell_cost = new_val
        end
    end
})

-- 574: Income Tax
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_income_tax',
    discovered = true,
    config = { extra = { xmult = 3, tax = 0.2 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_income_tax',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult, extra.tax * 100 } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local tax = math.floor((G.GAME.dollars or 0) * card.ability.extra.tax)
            if tax > 0 then
                ease_dollars(-tax)
            end
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 575: Money Laundering
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_money_laundering',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_money_laundering',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    config = { extra = { mult = 20 } },
    add_to_deck = function(self, card) G.GAME.odyssey_money_laundering_active = (G.GAME.odyssey_money_laundering_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_money_laundering_active = (G.GAME.odyssey_money_laundering_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_plastic then
                return { mult = card.ability.extra.mult, card = card }
            end
        end
    end
})

-- 576: Bribery
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_bribery',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_bribery',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card) G.GAME.odyssey_bribery_active = (G.GAME.odyssey_bribery_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_bribery_active = (G.GAME.odyssey_bribery_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 577: Hedge Fund
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_hedge_fund',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_hedge_fund',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local dollars = math.floor((G.GAME.dollars or 0) / 10)
            if dollars > 0 then
                ease_dollars(dollars)
                return {
                    message = localize('$') .. dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 578: Monopoly
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_monopoly',
    discovered = true,
    config = { extra = { money = 10 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_monopoly',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local gold_count = 0
            if G.hand and G.hand.cards then
                for k, v in ipairs(G.hand.cards) do
                    if v.config.center == G.P_CENTERS.m_odyssey_plastic then
                        gold_count = gold_count + 1
                    end
                end
            end
            if gold_count >= 3 then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 579: Recession
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_recession',
    discovered = true,
    config = { extra = { xmult = 4 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_recession',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and (G.GAME.dollars or 0) <= 0 then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 580: Stimulus Package
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_stimulus_package',
    discovered = true,
    config = { extra = { money = 10, threshold = 10 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_stimulus_package',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.entering_shop then
            if (G.GAME.dollars or 0) < card.ability.extra.threshold then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 581: Lottery
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_lottery',
    discovered = true,
    config = { extra = { chance = 100, money = 100 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_lottery',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance, extra.money } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if pseudorandom('lottery') < G.GAME.probabilities.normal / card.ability.extra.chance then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 582: Insurance
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_insurance',
    discovered = true,
    config = { extra = { money = 20 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_insurance',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_insurance_active = (G.GAME.odyssey_insurance_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_insurance_active = (G.GAME.odyssey_insurance_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 583: Retirement
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_retirement',
    discovered = true,
    config = { extra = { gain = 1 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_retirement',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.gain } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra_value = (card.ability.extra_value or 0) + card.ability.extra.gain
            card:set_cost()
            return {
                message = localize('k_val_up'),
                colour = G.C.MONEY
            }
        end
    end
})

-- 584: Venture Capital
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_venture_capital',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_venture_capital',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.dollars >= 10 then
                ease_dollars(-10)
                if pseudorandom('venture') < 0.5 then
                    ease_dollars(30)
                    return {
                        message = localize('$') .. "30",
                        colour = G.C.MONEY
                    }
                else
                    return {
                        message = "Fail!",
                        colour = G.C.RED
                    }
                end
            end
        end
    end
})

-- 585: Credit Card
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_credit_card_2',
    discovered = true,
    config = { extra = 20 },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_credit_card_2',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card) G.GAME.bankrupt_at = G.GAME.bankrupt_at - card.ability.extra end,
    remove_from_deck = function(self, card) G.GAME.bankrupt_at = G.GAME.bankrupt_at + card.ability.extra end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 586: Compound Interest
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_compound_interest',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_compound_interest',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            G.GAME.interest_cap = G.GAME.interest_cap + 5
            return {
                message = localize('k_val_up'),
                colour = G.C.MONEY
            }
        end
    end
})

-- 587: Day Trader
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_day_trader',
    discovered = true,
    config = { extra = 2 },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_day_trader',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_day_trader_active = (G.GAME.odyssey_day_trader_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_day_trader_active = (G.GAME.odyssey_day_trader_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 588: Oil Tycoon
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_oil_tycoon',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_oil_tycoon',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Spades') or context.other_card:is_suit('Clubs') then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})


-- ============================================
-- ECONOMY - Rare (Jokers 589-598)
-- ============================================

-- 589: The Great Depression
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_the_great_depression',
    discovered = true,
    config = { extra = { xmult = 1, lost = 0 } },
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_the_great_depression',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult, extra.lost } }

    end,
    add_to_deck = function(self, card)
        local loss = G.GAME.dollars or 0
        G.GAME.dollars = 0
        card.ability.extra.lost = loss
        card.ability.extra.xmult = 1 + math.floor(loss / 5)
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 590: Midas
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_midas',
    discovered = true,
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_midas',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.before then
            for k, v in ipairs(context.scoring_hand) do
                if v:is_face() then
                    v:set_ability(G.P_CENTERS.m_odyssey_plastic, nil, true)
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            v:juice_up()
                            return true
                        end
                    }))
                end
            end
        end
    end
})

-- 591: Philosopher's Stone
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_philosophers_stone',
    discovered = true,
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_philosophers_stone',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.discard and not context.other_card then
            -- Note: context.other_card is nil if multiple cards are discarded?
            -- Steamodded calls calculate for EACH card discarded if it's context.discard.
            -- Wait, if I want to target the card being discarded, I should check context.other_card.
        end
        if context.discard and context.other_card then
            context.other_card:set_ability(G.P_CENTERS.m_odyssey_plastic, nil, true)
            G.E_MANAGER:add_event(Event({
                func = function()
                    context.other_card:juice_up()
                    return true
                end
            }))
        end
    end
})

-- 592: Money Printer
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_money_printer',
    discovered = true,
    config = { extra = { chance = 3 } },
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_money_printer',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.blueprint then
            if pseudorandom('money_printer') < G.GAME.probabilities.normal / card.ability.extra.chance then
                local amt = G.GAME.odyssey_banker_money or 0
                if amt > 0 then
                    ease_dollars(amt)
                    return {
                        message = localize('$') .. amt,
                        colour = G.C.MONEY
                    }
                end
            end
        end
    end
})

-- 593: Central Bank
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_central_bank',
    discovered = true,
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_central_bank',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.interest_cap = 50
    end,
    remove_from_deck = function(self, card)
        G.GAME.interest_cap = 5
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 594: Mercenary
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_mercenary',
    discovered = true,
    config = { extra = { xmult = 5, cost = 1 } },
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_mercenary',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult, extra.cost } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local fee = card.ability.extra.cost * #context.scoring_hand
            if fee > 0 then
                ease_dollars(-fee)
            end
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 595: Make it Rain
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_make_it_rain',
    discovered = true,
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_make_it_rain',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.after and not context.blueprint then
             local hand_chips = G.GAME.hands[context.scoring_name].chips
             local hand_mult = G.GAME.hands[context.scoring_name].mult
             local excess_mult = math.floor(hand_mult - (G.GAME.blind.chips / hand_chips))
             if excess_mult > 0 then
                 ease_dollars(excess_mult)
                 return {
                     message = localize('$') .. excess_mult,
                     colour = G.C.MONEY
                 }
             end
        end
    end
})

-- 596: Blood Diamond
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_blood_diamond',
    discovered = true,
    config = { extra = { money = 50 } },
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_blood_diamond',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    add_to_deck = function(self, card)
        ease_dollars(card.ability.extra.money)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - 1
        ease_hands_played(-1)
    end,
    remove_from_deck = function(self, card)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + 1
        ease_hands_played(1)
    end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 597: Fool's Gold
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_fools_gold',
    discovered = true,
    config = { extra = { mult = 50 } },
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_fools_gold',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_fools_gold_active = (G.GAME.odyssey_fools_gold_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_fools_gold_active = (G.GAME.odyssey_fools_gold_active or 1) - 1 end,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_plastic then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 598: Utopia
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_utopia',
    discovered = true,
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_utopia',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_utopia_active = (G.GAME.odyssey_utopia_active or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_utopia_active = (G.GAME.odyssey_utopia_active or 1) - 1
    end,
    calculate = function(self, card, context)
        if context.buy_card and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                func = function()
                    card:start_dissolve()
                    return true
                end
            }))
            return {
                message = "Used!",
                colour = G.C.RED
            }
        end
    end
})


-- ============================================
-- ECONOMY - Legendary (Jokers 599-600)
-- ============================================

-- 599: Mammon
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_mammon',
    discovered = true,
    config = { extra = { xmult = 5 } },
    rarity = 4,
    cost = 20,
    atlas = 'j_economy_mammon',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            local bonus = G.GAME.dollars or 0
            if bonus > 0 then
                ease_dollars(bonus)
                return {
                    message = localize('$') .. bonus,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 600: The Market's Hand
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_markets_hand',
    discovered = true,
    rarity = 4,
    cost = 20,
    atlas = 'j_economy_markets_hand',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_market_hand_active = (G.GAME.odyssey_market_hand_active or 0) + 1
        G.E_MANAGER:add_event(Event({func = function()
            if G.shop then
                G.shop.config.card_limit = G.shop.config.card_limit + 5
            end
            return true
        end}))
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_market_hand_active = (G.GAME.odyssey_market_hand_active or 1) - 1
        G.E_MANAGER:add_event(Event({func = function()
            if G.shop then
                G.shop.config.card_limit = G.shop.config.card_limit - 5
            end
            return true
        end}))
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- ============================================
-- TIME & TURNS - Common (Jokers 601-620)
-- ============================================

-- 601: Hourglass
SMODS.Joker({
    unlocked = true,
    key = 'j_time_hourglass',
    discovered = true,
    config = { extra = { mult = 20, loss = 2, current_mult = 20 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_hourglass',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.loss, extra.current_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.current_mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.current_mult } }
            }
        end
        if context.after and not context.blueprint then
            card.ability.extra.current_mult = math.max(0, card.ability.extra.current_mult - card.ability.extra.loss)
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current_mult = card.ability.extra.mult
        end
    end
})

-- 602: Stopwatch
SMODS.Joker({
    unlocked = true,
    key = 'j_time_stopwatch',
    discovered = true,
    config = { extra = { chips = 30 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_stopwatch',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.current_round.hands_played == 0 then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    end
})

-- 603: Countdown
SMODS.Joker({
    unlocked = true,
    key = 'j_time_countdown',
    discovered = true,
    config = { extra = { start = 10, current = 10, reward = 50 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_countdown',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.start, extra.reward, extra.current } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current = card.ability.extra.current - 1
            if card.ability.extra.current <= 0 then
                ease_dollars(card.ability.extra.reward)
                card.ability.extra.current = card.ability.extra.start
                return {
                    message = localize('$') .. card.ability.extra.reward,
                    colour = G.C.MONEY
                }
            end
            return {
                message = card.ability.extra.current .. '',
                colour = G.C.FILTER
            }
        end
    end
})

-- 604: Patience
SMODS.Joker({
    unlocked = true,
    key = 'j_time_patience',
    discovered = true,
    config = { extra = { time = 30, mult = 20 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_patience',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.time, extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local current_time = G.TIMERS.REAL
            local last_time = G.GAME.last_hand_time or current_time
            if (current_time - last_time) >= card.ability.extra.time then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
        if context.after then
            G.GAME.last_hand_time = G.TIMERS.REAL
        end
    end
})

-- 605: Haste
SMODS.Joker({
    unlocked = true,
    key = 'j_time_haste',
    discovered = true,
    config = { extra = { time = 5, mult = 10 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_haste',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.time } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local current_time = G.TIMERS.REAL
            local last_time = G.GAME.last_hand_time or current_time
            if (current_time - last_time) <= card.ability.extra.time then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
        if context.after then
            G.GAME.last_hand_time = G.TIMERS.REAL
        end
    end
})

-- 606: Extra Turn
SMODS.Joker({
    unlocked = true,
    key = 'j_time_extra_turn',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_time_extra_turn',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + 1
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - 1
        ease_hands_played(1)
        ease_discard(-1)
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - 1
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + 1
        ease_hands_played(-1)
        ease_discard(1)
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 607: Rush Hour
SMODS.Joker({
    unlocked = true,
    key = 'j_time_rush_hour',
    discovered = true,
    config = { extra = { chips = 50 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_rush_hour',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and (G.GAME.current_round.discards_left or 0) == 0 then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- 608: Delay
SMODS.Joker({
    unlocked = true,
    key = 'j_time_delay',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_time_delay',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local bonus = G.GAME.current_round.last_hand_mult or 0
            if bonus > 0 then
                ease_dollars(bonus)
                return {
                    message = localize('$') .. bonus,
                    colour = G.C.MONEY
                }
            end
        end
        if context.joker_main then
            G.GAME.current_round.last_hand_mult = context.mult
        end
    end
})

-- 609: Cycle
SMODS.Joker({
    unlocked = true,
    key = 'j_time_cycle',
    discovered = true,
    config = { extra = { rounds = 4, current = 4 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_cycle',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.rounds, extra.current } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current = card.ability.extra.current - 1
            if card.ability.extra.current <= 0 then
                card.ability.extra.current = card.ability.extra.rounds
                G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()
                    local key = 'p_arcana_normal_' .. (math.random(1, 2))
                    local card = Card(G.play.T.x, G.play.T.y, G.CARD_W*1.27, G.CARD_H*1.27, G.P_CARDS.empty, G.P_CENTERS[key], {bypass_discovery_center = true, bypass_discovery_ui = true})
                    card:set_edition(nil, true, true)
                    card:draw_from_deck()
                    G.play:emplace(card)
                    G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()
                        card:use_booster_pack()
                        return true
                    end}))
                    return true
                end}))
                return {
                    message = "Cycle!",
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

-- 610: Seasons
SMODS.Joker({
    unlocked = true,
    key = 'j_time_seasons',
    discovered = true,
    config = { extra = { suit = 'Hearts', index = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_seasons',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        return { 
            vars = { localize(( (card and card.ability and card.ability.extra) or self.config.extra ).suit, 'suits_plural'), colours = { G.C.SUITS[( (card and card.ability and card.ability.extra) or self.config.extra ).suit] } }
        }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit(card.ability.extra.suit) then
                    count = count + 1
                end
            end
            if count > 0 then
                return {
                    mult_mod = count * 5,
                    chips_mod = count * 20,
                    message = localize { type = 'variable', key = 'a_mult', vars = { count * 5 } }
                }
            end
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            local suits = { 'Hearts', 'Spades', 'Diamonds', 'Clubs' }
            card.ability.extra.index = (card.ability.extra.index % 4) + 1
            card.ability.extra.suit = suits[card.ability.extra.index]
            return {
                message = localize(card.ability.extra.suit, 'suits_plural'),
                colour = G.C.FILTER
            }
        end
    end
})

-- 611: Day and Night
SMODS.Joker({
    unlocked = true,
    key = 'j_time_day_night',
    discovered = true,
    config = { extra = { chips = 50, mult = 10, state = 'day' } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_day_night',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.mult, extra.state } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if card.ability.extra.state == 'day' then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            else
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
        if context.after and not context.blueprint then
            card.ability.extra.state = (card.ability.extra.state == 'day') and 'night' or 'day'
        end
    end
})

-- 612: Sundial
SMODS.Joker({
    unlocked = true,
    key = 'j_time_sundial',
    discovered = true,
    config = { extra = { mult_per_card = 0.5 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_sundial',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local deck_count = (G.deck and G.deck.cards) and #G.deck.cards or 0
        local current_mult = deck_count * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_card
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_card, current_mult } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local deck_count = (G.deck and G.deck.cards) and #G.deck.cards or 0
            local current_mult = deck_count * card.ability.extra.mult_per_card
            return {
                mult_mod = current_mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { current_mult } }
            }
        end
    end
})

-- 613: Pendulum
SMODS.Joker({
    unlocked = true,
    key = 'j_time_pendulum',
    discovered = true,
    config = { extra = { xmult_low = 0.5, xmult_high = 2.0, state = 'low' } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_pendulum',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local current = (( (card and card.ability and card.ability.extra) or self.config.extra ).state == 'low') and ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_low or ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_high
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_low, ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_high, current } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local current = (card.ability.extra.state == 'low') and card.ability.extra.xmult_low or card.ability.extra.xmult_high
            return {
                x_mult = current,
                message = localize { type = 'variable', key = 'a_xmult', vars = { current } }
            }
        end
        if context.after and not context.blueprint then
            card.ability.extra.state = (card.ability.extra.state == 'low') and 'high' or 'low'
        end
    end
})

-- 614: Metronome
SMODS.Joker({
    unlocked = true,
    key = 'j_time_metronome',
    discovered = true,
    config = { extra = { mult = 20, last_count = nil } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_metronome',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.last_count or '?' } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if card.ability.extra.last_count and #context.full_hand == card.ability.extra.last_count then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
        if context.after and not context.blueprint then
            card.ability.extra.last_count = #context.full_hand
        end
    end
})

-- 615: Time Zone
SMODS.Joker({
    unlocked = true,
    key = 'j_time_zone',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_time_zone',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card:is_suit('Spades') or context.other_card:is_suit('Hearts') then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- 616: Ice Age
SMODS.Joker({
    unlocked = true,
    key = 'j_time_ice_age',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_time_ice_age',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card) G.GAME.odyssey_ice_age_active = (G.GAME.odyssey_ice_age_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_ice_age_active = (G.GAME.odyssey_ice_age_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 617: Stone Age
SMODS.Joker({
    unlocked = true,
    key = 'j_time_stone_age',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_time_stone_age',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local front_cards = {}
            for k, v in ipairs(G.playing_cards) do
                if not v.config.center_key or v.config.center_key == 'c_base' then
                    table.insert(front_cards, v)
                end
            end
            if #front_cards > 0 then
                local target = pseudorandom_element(front_cards, pseudoseed('stone_age'))
                target:set_ability(G.P_CENTERS.m_odyssey_emerald)
                return {
                    message = localize('k_stone'),
                    colour = G.C.GREY
                }
            end
        end
    end
})

-- 618: Bronze Age
SMODS.Joker({
    unlocked = true,
    key = 'j_time_bronze_age',
    discovered = true,
    config = { extra = { chips = 15 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_bronze_age',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local rank = context.other_card:get_id()
            if rank >= 2 and rank <= 10 then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
    end
})

-- 619: Iron Age
SMODS.Joker({
    unlocked = true,
    key = 'j_time_iron_age',
    discovered = true,
    config = { extra = { chips = 30 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_iron_age',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_platinum then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
    end
})

-- 620: Future
SMODS.Joker({
    unlocked = true,
    key = 'j_time_future',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_future',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end,
    update = function(self, card)
        if G.STAGE == G.STAGES.RUN and G.deck and G.deck.cards and #G.deck.cards > 0 and not G.GAME.blind.animating then
            local top_card = G.deck.cards[#G.deck.cards]
            if top_card.facing == 'back' then
                top_card.facing = 'front'
                top_card.sprite_facing = 'front'
            end
        end
    end
})


-- ============================================
-- TIME & TURNS - Uncommon (Jokers 621-638)
-- ============================================

-- 621: Time Machine
SMODS.Joker({
    unlocked = true,
    key = 'j_time_machine',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_machine',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.selling_self then
            G.GAME.chips = 0
            G.GAME.current_round.hands_played = 0
            G.GAME.current_round.discards_used = 0
            G.GAME.current_round.hands_left = G.GAME.round_resets.hands
            G.GAME.current_round.discards_left = G.GAME.round_resets.discards
            return {
                message = localize('k_reset'),
                colour = G.C.BLUE
            }
        end
    end
})

-- 622: Back to the Future
SMODS.Joker({
    unlocked = true,
    key = 'j_time_back_to_the_future',
    discovered = true,
    config = { extra = { xmult = 3 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_back_to_the_future',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if not G.GAME.odyssey_first_hand_ever then
                G.GAME.odyssey_first_hand_ever = context.poker_hand
            end
            if context.poker_hand == G.GAME.odyssey_first_hand_ever then
                return {
                    x_mult = card.ability.extra.xmult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
                }
            end
        end
    end
})

-- 623: Doppler Effect
SMODS.Joker({
    unlocked = true,
    key = 'j_time_doppler_effect',
    discovered = true,
    config = { extra = { mult = 5 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_doppler_effect',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local pos = 1
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i] == context.other_card then
                    pos = i
                    break
                end
            end
            local bonus = pos * card.ability.extra.mult
            return {
                mult = bonus,
                card = card
            }
        end
    end
})

-- 624: Relativity
SMODS.Joker({
    unlocked = true,
    key = 'j_time_relativity',
    discovered = true,
    config = { extra = { chips = 100, xmult = 1.5, threshold = 5 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_relativity',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.xmult, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local current_time = G.TIMERS.REAL
            local last_time = G.GAME.last_hand_time or current_time
            local diff = current_time - last_time
            if diff <= card.ability.extra.threshold then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            else
                return {
                    x_mult = card.ability.extra.xmult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
                }
            end
        end
        if context.after then
            G.GAME.last_hand_time = G.TIMERS.REAL
        end
    end
})

-- 625: Wormhole
SMODS.Joker({
    unlocked = true,
    key = 'j_time_wormhole',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_wormhole',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_wormhole_active = (G.GAME.odyssey_wormhole_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_wormhole_active = (G.GAME.odyssey_wormhole_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 626: Time Skip
SMODS.Joker({
    unlocked = true,
    key = 'j_time_skip',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_skip',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.blind.name == 'Small Blind' and G.GAME.current_round.hands_played == 1 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        G.GAME.blind:skip()
                        G.STATE = G.STATES.NEW_ROUND
                        return true
                    end
                }))
            end
        end
    end
})

-- 627: Time Freeze
SMODS.Joker({
    unlocked = true,
    key = 'j_time_freeze',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_freeze',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_time_freeze_active = (G.GAME.odyssey_time_freeze_active or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_time_freeze_active = (G.GAME.odyssey_time_freeze_active or 1) - 1
    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
             G.E_MANAGER:add_event(Event({func = function()
                 card:start_dissolve()
                 return true
             end}))
        end
    end
})

-- 628: Time Loop
SMODS.Joker({
    unlocked = true,
    key = 'j_time_loop',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_loop',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card == context.scoring_hand[1] then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 3,
                    card = card
                }
            end
        end
    end
})

-- 629: Grandfather Paradox
SMODS.Joker({
    unlocked = true,
    key = 'j_time_grandfather_paradox',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_grandfather_paradox',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        -- Logic is in G.FUNCS.die override in 03_vanilla_override.lua
    end
})

-- 630: Precognition
SMODS.Joker({
    unlocked = true,
    key = 'j_time_precognition',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_precognition',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_precognition = (G.GAME.odyssey_precognition or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_precognition = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 631: Deja Vu
SMODS.Joker({
    unlocked = true,
    key = 'j_time_deja_vu',
    discovered = true,
    config = { extra = { xmult = 2 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_deja_vu',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.last_poker_hand == context.poker_hand then
                return {
                    x_mult = card.ability.extra.xmult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
                }
            end
        end
        if context.after and not context.blueprint then
            G.GAME.last_poker_hand = context.poker_hand
        end
    end
})

-- 632: Eternity
SMODS.Joker({
    unlocked = true,
    key = 'j_time_eternity',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_eternity',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        for i = 1, #G.jokers.cards do
            local j = G.jokers.cards[i]
            if j.transient then
                j.transient = false
            end
        end
    end
})

-- 633: Ephemeral
SMODS.Joker({
    unlocked = true,
    key = 'j_time_ephemeral',
    discovered = true,
    config = { extra = { mult = 50, rounds = 3 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_ephemeral',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.rounds } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.rounds = card.ability.extra.rounds - 1
            if card.ability.extra.rounds <= 0 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        if not card.ability.eternal then card:start_dissolve() end
                        return true
                    end
                }))
                return {
                    message = localize('k_lost_ex'),
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 634: Chronokinesis
SMODS.Joker({
    unlocked = true,
    key = 'j_time_chronokinesis',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_chronokinesis',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card)
        G.GAME.odyssey_chronokinesis = (G.GAME.odyssey_chronokinesis or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_chronokinesis = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 635: Synchronicity
SMODS.Joker({
    unlocked = true,
    key = 'j_time_synchronicity',
    discovered = true,
    config = { extra = { xmult = 3 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_synchronicity',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local first_rank = context.scoring_hand[1]:get_id()
            local all_same = true
            for i = 2, #context.scoring_hand do
                if context.scoring_hand[i]:get_id() ~= first_rank then
                    all_same = false
                    break
                end
            end
            if all_same then
                return {
                    x_mult = card.ability.extra.xmult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
                }
            end
        end
    end
})

-- 636: Anachronism
SMODS.Joker({
    unlocked = true,
    key = 'j_time_anachronism',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_anachronism',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_anachronism = (G.GAME.odyssey_anachronism or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_anachronism = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 637: Lost Time
SMODS.Joker({
    unlocked = true,
    key = 'j_time_lost_time',
    discovered = true,
    config = { extra = { chips = 100 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_lost_time',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- 638: End Times
SMODS.Joker({
    unlocked = true,
    key = 'j_time_end_times',
    discovered = true,
    config = { extra = { xmult = 4 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_end_times',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.blind.boss and G.GAME.current_round.hands_left == 0 then
                return {
                    x_mult = card.ability.extra.xmult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
                }
            end
        end
    end
})


-- ============================================
-- TIME & TURNS - Rare (Jokers 639-648)
-- ============================================

-- 639: Time Lord
SMODS.Joker({
    unlocked = true,
    key = 'j_time_time_lord',
    discovered = true,
    config = { extra = { hands = 1, discards = 1, slots = 1 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_time_lord',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra.hands
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards
        G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.slots
        ease_hands_played(card.ability.extra.hands)
        ease_discard(card.ability.extra.discards)
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hands
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards
        G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.slots
        ease_hands_played(-card.ability.extra.hands)
        ease_discard(-card.ability.extra.discards)
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 640: The World
SMODS.Joker({
    unlocked = true,
    key = 'j_time_the_world',
    discovered = true,
    config = { extra = { xmult = 2 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_the_world',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 641: Aeon
SMODS.Joker({
    unlocked = true,
    key = 'j_time_aeon',
    discovered = true,
    config = { extra = { xmult = 1 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_aeon',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.xmult = card.ability.extra.xmult + 0.1
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
    end
})

-- 642: Kairos
SMODS.Joker({
    unlocked = true,
    key = 'j_time_kairos',
    discovered = true,
    config = { extra = { xmult = 5 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_kairos',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_left == 0 then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 643: Chronos
SMODS.Joker({
    unlocked = true,
    key = 'j_time_chronos',
    discovered = true,
    config = { extra = { dollars_per_hand = 2 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_chronos',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local bonus = G.GAME.current_round.hands_left * card.ability.extra.dollars_per_hand
            if bonus > 0 then
                ease_dollars(bonus)
                return {
                    message = localize('$') .. bonus,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 644: Ouroboros
SMODS.Joker({
    unlocked = true,
    key = 'j_time_ouroboros',
    discovered = true,
    rarity = 3,
    cost = 10,
    atlas = 'j_time_ouroboros',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_ouroboros = (G.GAME.odyssey_ouroboros or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_ouroboros = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 645: Reverse Entropy
SMODS.Joker({
    unlocked = true,
    key = 'j_time_reverse_entropy',
    discovered = true,
    rarity = 3,
    cost = 10,
    atlas = 'j_time_reverse_entropy',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_reverse_entropy = (G.GAME.odyssey_reverse_entropy or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_reverse_entropy = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 646: Big Crunch
SMODS.Joker({
    unlocked = true,
    key = 'j_time_big_crunch',
    discovered = true,
    config = { extra = { xmult = 10, hand_size = -7 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_big_crunch',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 647: Big Bang
SMODS.Joker({
    unlocked = true,
    key = 'j_time_big_bang',
    discovered = true,
    config = { extra = { mult_minus = 2, hand_size = 5 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_big_bang',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size
    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.hand then
            return {
                mult = -card.ability.extra.mult_minus,
                card = card
            }
        end
    end
})

-- 648: Sacred Timeline
SMODS.Joker({
    unlocked = true,
    key = 'j_time_sacred_timeline',
    discovered = true,
    rarity = 3,
    cost = 10,
    atlas = 'j_time_sacred_timeline',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_sacred_timeline = (G.GAME.odyssey_sacred_timeline or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_sacred_timeline = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- ============================================
-- TIME & TURNS - Legendary (Jokers 649-650)
-- ============================================

-- 649: Father Time
SMODS.Joker({
    unlocked = true,
    key = 'j_time_father_time',
    discovered = true,
    config = { extra = { xmult = 5 } },
    rarity = 4,
    cost = 20,
    atlas = 'j_time_father_time',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).xmult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 650: Guardian of Eternity
SMODS.Joker({
    unlocked = true,
    key = 'j_time_guardian_of_eternity',
    discovered = true,
    config = { extra = { xmult = 4 } },
    rarity = 4,
    cost = 20,
    atlas = 'j_time_guardian_of_eternity',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).xmult } } end,
    add_to_deck = function(self, card)
        G.GAME.odyssey_guardian_of_eternity = (G.GAME.odyssey_guardian_of_eternity or 0) + 1
        if G.jokers and G.jokers.cards then
            for _, v in ipairs(G.jokers.cards) do
                v.ability.eternal = true
            end
        end
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_guardian_of_eternity = nil
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})


-- ============================================
-- HAND AND DISCARD - Common (Jokers 651-670)
-- ============================================

-- 651. Extra Hand
SMODS.Joker({
    key = 'j_hand_and_discard_extra_hand',
    config = { extra = 1 },
    rarity = 1,
    atlas = 'j_hand_and_discard_extra_hand',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then
            G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra
        end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then
            G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 652. Extra Discard
SMODS.Joker({
    key = 'j_hand_and_discard_extra_discard',
    config = { extra = 1 },
    rarity = 1,
    atlas = 'j_hand_and_discard_extra_discard',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then
            G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra
        end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then
            G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 653. Recycling
SMODS.Joker({
    key = 'j_hand_and_discard_recycling',
    config = { extra = { hands_needed = 2, hands_played = 0 } },
    rarity = 1,
    atlas = 'j_hand_and_discard_recycling',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.after and not context.blueprint then
            card.ability.extra.hands_played = card.ability.extra.hands_played + 1
            if card.ability.extra.hands_played >= card.ability.extra.hands_needed then
                card.ability.extra.hands_played = 0
                G.GAME.current_round.discards_left = G.GAME.current_round.discards_left + 1
                return {
                    message = localize('k_plus_discard'),
                    colour = G.C.RED,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).hands_needed, (( (card and card.ability and card.ability.extra) or self.config.extra )).hands_played } } end
})

-- 654. Trash Can
SMODS.Joker({
    key = 'j_hand_and_discard_trash_can',
    config = { extra = 1 },
    rarity = 1,
    atlas = 'j_hand_and_discard_trash_can',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.discard and G.GAME.current_round.discards_left <= 0 then
            ease_dollars(card.ability.extra)
            return {
                message = localize('$')..card.ability.extra,
                colour = G.C.MONEY,
                card = card
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 655. Full Hand
SMODS.Joker({
    key = 'j_hand_and_discard_full_hand',
    config = { extra = 20 },
    rarity = 1,
    atlas = 'j_hand_and_discard_full_hand',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and #context.full_hand == 5 then
            return {
                message = localize{type='variable', key='a_chips', vars={card.ability.extra}},
                chip_mod = card.ability.extra,
                colour = G.C.CHIPS
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 656. Empty Hand
SMODS.Joker({
    key = 'j_hand_and_discard_empty_hand',
    config = { extra = 20 },
    rarity = 1,
    atlas = 'j_hand_and_discard_empty_hand',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and #context.full_hand <= 2 then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra}},
                mult_mod = card.ability.extra,
                colour = G.C.MULT
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 657. Juggler
SMODS.Joker({
    key = 'j_hand_and_discard_juggler',
    config = { extra = 1 },
    rarity = 1,
    atlas = 'j_hand_and_discard_juggler',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then
            G.hand:change_size(card.ability.extra)
        end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then
            G.hand:change_size(-card.ability.extra)
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 658. Street Magician
SMODS.Joker({
    key = 'j_hand_and_discard_street_magician',
    config = { extra = { odds = 5, money = 2 } },
    rarity = 1,
    atlas = 'j_hand_and_discard_street_magician',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.discard and not context.other_card then
            if pseudorandom('street_magician') < G.GAME.probabilities.normal / card.ability.extra.odds then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$')..card.ability.extra.money,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds, ( (card and card.ability and card.ability.extra) or self.config.extra ).money } } end
})

-- 659. Cards Up Sleeve
SMODS.Joker({
    key = 'j_hand_and_discard_cards_up_sleeve',
    config = { extra = { odds = 4 } },
    rarity = 1,
    atlas = 'j_hand_and_discard_cards_up_sleeve',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            if pseudorandom('cards_up_sleeve') < G.GAME.probabilities.normal / card.ability.extra.odds then
                G.E_MANAGER:add_event(Event({
                    trigger = 'before',
                    delay = 0.5,
                    func = function()
                        draw_card(G.deck, G.hand, 90, 'up', nil)
                        return true
                    end
                }))
                return {
                    message = "Extra Card!",
                    colour = G.C.BLUE,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } } end
})

-- 660. Dealer
SMODS.Joker({
    key = 'j_hand_and_discard_dealer',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_hand_and_discard_dealer',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra}},
                mult_mod = card.ability.extra,
                colour = G.C.MULT
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 661. Auto Shuffler
SMODS.Joker({
    key = 'j_hand_and_discard_auto_shuffler',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_hand_and_discard_auto_shuffler',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            G.E_MANAGER:add_event(Event({ func = function()
                table.sort(G.deck.cards, function(a, b) 
                    return (a.base.value or 0) > (b.base.value or 0) 
                end)
                return true
            end }))
            return { message = "Sorted!", colour = G.C.BLUE }
        end
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end
})

-- 662. Deck Cut
SMODS.Joker({
    key = 'j_hand_and_discard_deck_cut',
    config = { extra = { mult = 15, cards = 5 } },
    rarity = 1,
    atlas = 'j_hand_and_discard_deck_cut',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            G.E_MANAGER:add_event(Event({ func = function()
                for i=1, card.ability.extra.cards do
                    if G.deck.cards[1] then
                        local deleted_card = G.deck.cards[1]
                        draw_card(G.deck, G.discard, i*100/card.ability.extra.cards, 'down', false, deleted_card)
                    end
                end
                return true
            end }))
            return { message = "Cut!", colour = G.C.RED }
        end
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).cards, (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end
})

-- 663. Ghost Hand
SMODS.Joker({
    key = 'j_hand_and_discard_ghost_hand',
    config = { extra = 1, extra_hand_given = false },
    rarity = 1,
    atlas = 'j_hand_and_discard_ghost_hand',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.after and G.GAME.current_round.hands_left == 0 and not card.ability.extra_hand_given then
             G.GAME.current_round.hands_left = G.GAME.current_round.hands_left + 1
             card.ability.extra_hand_given = true
             G.GAME.odyssey_ghost_hand_active = true
             return {
                 message = "Ghost Hand!",
                 colour = G.C.FILTER
             }
        end
        if context.end_of_round and not context.other_card then 
            card.ability.extra_hand_given = false
            G.GAME.odyssey_ghost_hand_active = false
        end
        if context.after and card.ability.extra_hand_given then
            -- Reset after the hand plays
            G.E_MANAGER:add_event(Event({
                func = function()
                    G.GAME.odyssey_ghost_hand_active = false
                    return true
                end
            }))
        end
    end
})

-- 664. Tactical Discard
SMODS.Joker({
    key = 'j_hand_and_discard_tactical_discard',
    config = { extra = { mult = 10, active = false } },
    rarity = 1,
    atlas = 'j_hand_and_discard_tactical_discard',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and not context.other_card then
            if #context.full_hand == 1 then
                card.ability.extra.active = true
                return { 
                    message = "Tactical!",
                    colour = G.C.RED
                }
            end
        end
        if context.joker_main and card.ability.extra.active then
            card.ability.extra.active = false
            return { 
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end
})

-- 665. Steady Hand
SMODS.Joker({
    key = 'j_hand_and_discard_steady_hand',
    config = { extra = 1.5 },
    rarity = 1,
    atlas = 'j_hand_and_discard_steady_hand',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_used == 0 then
            return { x_mult = card.ability.extra }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 666. Shaky Hand
SMODS.Joker({
    key = 'j_hand_and_discard_shaky_hand',
    config = { extra = 50 },
    rarity = 1,
    atlas = 'j_hand_and_discard_shaky_hand',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_left == 0 then
            return { chip_mod = card.ability.extra }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 667. Boxing Glove
SMODS.Joker({
    key = 'j_hand_and_discard_boxing_glove',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_hand_and_discard_boxing_glove',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local hand_count = #G.hand.cards
            return { chip_mod = hand_count * card.ability.extra }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ), (G.hand and G.hand.cards and #G.hand.cards or 0) * ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 668. Silk Glove
SMODS.Joker({
    key = 'j_hand_and_discard_silk_glove',
    config = { extra = 5 },
    rarity = 1,
    atlas = 'j_hand_and_discard_silk_glove',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return { mult_mod = G.GAME.current_round.discards_left * card.ability.extra }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ), G.GAME.current_round.discards_left * ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 669. Gauntlet
SMODS.Joker({
    key = 'j_hand_and_discard_gauntlet',
    config = { extra = { chips = 50, discards = 1 } },
    rarity = 1,
    atlas = 'j_hand_and_discard_gauntlet',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards end
    end,
    calculate = function(self, card, context)
        if context.joker_main then return { chip_mod = card.ability.extra.chips } end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips, (( (card and card.ability and card.ability.extra) or self.config.extra )).discards } } end
})

-- 670. Magic Finger
SMODS.Joker({
    key = 'j_hand_and_discard_magic_finger',
    config = { extra = 1 },
    rarity = 1,
    atlas = 'j_hand_and_discard_magic_finger',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.play.config.card_limit = G.play.config.card_limit + 1 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.play.config.card_limit = G.play.config.card_limit - 1 end
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- ============================================
-- HAND AND DISCARD - Uncommon (Jokers 671-688)
-- ============================================

-- 671. Hand of Midas
SMODS.Joker({
    key = 'j_hand_and_discard_hand_of_midas',
    config = { extra = 10 },
    rarity = 2,
    atlas = 'j_hand_and_discard_hand_of_midas',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local gold_count = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center == G.P_CENTERS.m_odyssey_plastic then gold_count = gold_count + 1 end
            end
            if gold_count >= 5 then
                ease_dollars(card.ability.extra)
                return {
                    message = localize('$')..card.ability.extra,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 672. Iron Hand
SMODS.Joker({
    key = 'j_hand_and_discard_iron_hand',
    config = { extra = 100 },
    rarity = 2,
    atlas = 'j_hand_and_discard_iron_hand',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local steel_count = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center == G.P_CENTERS.m_odyssey_platinum then steel_count = steel_count + 1 end
            end
            if steel_count >= 5 then
                return {
                    mult_mod = card.ability.extra,
                    message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 673. Stone Hand
SMODS.Joker({
    key = 'j_hand_and_discard_stone_hand',
    config = { extra = 200 },
    rarity = 2,
    atlas = 'j_hand_and_discard_stone_hand',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local stone_count = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center == G.P_CENTERS.m_odyssey_emerald then stone_count = stone_count + 1 end
            end
            if stone_count >= 5 then
                return {
                    chip_mod = card.ability.extra,
                    message = localize{type = 'variable', key = 'a_chips', vars = {card.ability.extra}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 674. Glass Hand
SMODS.Joker({
    key = 'j_hand_and_discard_glass_hand',
    config = { extra = 4 },
    rarity = 2,
    atlas = 'j_hand_and_discard_glass_hand',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local glass_count = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center == G.P_CENTERS.m_odyssey_ceramic then glass_count = glass_count + 1 end
            end
            if glass_count >= 5 then
                for k, v in ipairs(context.scoring_hand) do
                    if v.config.center == G.P_CENTERS.m_odyssey_ceramic then
                        v:shatter()
                    end
                end
                return {
                    Xmult_mod = card.ability.extra,
                    message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 675. Helping Hand
SMODS.Joker({
    key = 'j_hand_and_discard_helping_hand',
    rarity = 2,
    atlas = 'j_hand_and_discard_helping_hand',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.before and context.scoring_name == "High Card" and not context.blueprint then
            level_up_hand(card, context.scoring_name, nil, 1)
            return {
                message = localize('k_level_up'),
                colour = G.C.PURPLE
            }
        end
    end
})

-- 676. Dead Hand
SMODS.Joker({
    key = 'j_hand_and_discard_dead_hand',
    config = { extra = 5 },
    rarity = 2,
    atlas = 'j_hand_and_discard_dead_hand',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.after and not context.blueprint and not context.repetition and not context.other_card then
            -- We check if the hand score was 0 (e.g. all debuffed)
            -- This is tricky in after context, so we'll check hand_chips and hand_mult
            if G.GAME.hands[context.scoring_name].chips == 0 or G.GAME.hands[context.scoring_name].mult == 0 then
                ease_dollars(card.ability.extra)
                return { message = localize('$')..card.ability.extra, colour = G.C.MONEY }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 677. Divine Hand
SMODS.Joker({
    key = 'j_hand_and_discard_divine_hand',
    config = { extra = 2 },
    rarity = 2,
    atlas = 'j_hand_and_discard_divine_hand',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played == 0 then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 678. Cursed Hand
SMODS.Joker({
    key = 'j_hand_and_discard_cursed_hand',
    config = { extra = 3 },
    rarity = 2,
    atlas = 'j_hand_and_discard_cursed_hand',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.round_resets.hands = G.GAME.round_resets.hands - 1; ease_hands_played(-1) end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.round_resets.hands = G.GAME.round_resets.hands + 1; ease_hands_played(1) end
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 679. Perfect Discard
SMODS.Joker({
    key = 'j_hand_and_discard_perfect_discard',
    config = { extra = 4 },
    rarity = 2,
    atlas = 'j_hand_and_discard_perfect_discard',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and #context.full_hand == 5 and not context.blueprint then
            local suit = context.full_hand[1].base.suit
            local all_same = true
            for i=2, 5 do if context.full_hand[i].base.suit ~= suit then all_same = false end end
            if all_same then
                ease_dollars(card.ability.extra)
                return { message = localize('$')..card.ability.extra, colour = G.C.MONEY, card = card }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 680. Strategic Discard
SMODS.Joker({
    key = 'j_hand_and_discard_strategic_discard',
    config = { extra = { mult = 20, active = false } },
    rarity = 2,
    atlas = 'j_hand_and_discard_strategic_discard',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and #context.full_hand >= 5 and not context.blueprint then
             local ranks = {}
             for k, v in ipairs(context.full_hand) do table.insert(ranks, v.base.id) end
             table.sort(ranks)
             local is_straight = true
             for i=1, #ranks-1 do
                if ranks[i+1] ~= ranks[i] + 1 then
                    -- Handle Ace low straight
                    if not (i == #ranks-1 and ranks[i] == 5 and ranks[i+1] == 14) then
                        is_straight = false
                        break
                    end
                end
             end
             if is_straight then
                card.ability.extra.active = true
                return { message = "Strategic!", colour = G.C.FILTER }
             end
        end
        if context.joker_main and card.ability.extra.active then
            card.ability.extra.active = false
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra.mult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end
})

-- 681. Gold Discard
SMODS.Joker({
    key = 'j_hand_and_discard_gold_discard',
    config = { extra = 4 },
    rarity = 2,
    atlas = 'j_hand_and_discard_gold_discard',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint and context.other_card.config.center == G.P_CENTERS.m_odyssey_plastic then
            ease_dollars(card.ability.extra)
            return { message = localize('$')..card.ability.extra, colour = G.C.MONEY, card = card }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 682. Steel Discard
SMODS.Joker({
    key = 'j_hand_and_discard_steel_discard',
    config = { extra = { mult = 0, gain = 5 } },
    rarity = 2,
    atlas = 'j_hand_and_discard_steel_discard',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint and context.other_card.config.center == G.P_CENTERS.m_odyssey_platinum then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
            return {
                message = "Up!",
                colour = G.C.MULT
            }
        end
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra.mult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).gain } } end
})

-- 683. Glass Discard

SMODS.Joker({
    key = 'j_hand_and_discard_glass_discard',
    config = { extra = 2 }, -- 1 in 2
    rarity = 2,
    atlas = 'j_hand_and_discard_glass_discard',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint and context.other_card.config.center == G.P_CENTERS.m_odyssey_ceramic then
            if pseudorandom('glass_discard') < G.GAME.probabilities.normal / card.ability.extra then
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.4,
                    func = function()
                        local _card = copy_card(context.other_card, nil, nil, G.hand.cards[1] and G.hand.cards[1].set or 'Default')
                        _card:add_to_deck()
                        G.hand:emplace(_card)
                        return true
                    end
                }))
                return { message = "New Ceramic!", colour = G.C.PALE_GREEN }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 684. Mirrored Hand
SMODS.Joker({
    key = 'j_hand_and_discard_mirrored_hand',
    config = { extra = 2 },
    rarity = 2,
    atlas = 'j_hand_and_discard_mirrored_hand',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 685. Shadow Hand
SMODS.Joker({
    key = 'j_hand_and_discard_shadow_hand',
    rarity = 2,
    atlas = 'j_hand_and_discard_shadow_hand',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.after and not context.blueprint and not card.ability.used_this_round then
            card.ability.used_this_round = true
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    for k, v in ipairs(context.scoring_hand) do
                        local _card = copy_card(v)
                        _card:add_to_deck()
                        G.hand:emplace(_card)
                    end
                    return true
                end
            }))
            return { message = "Shadow Recall!", colour = G.C.PURPLE }
        end
        if context.end_of_round and not context.other_card then card.ability.used_this_round = false end
    end
})

-- 686. Quick Hand
SMODS.Joker({
    key = 'j_hand_and_discard_quick_hand',
    rarity = 2,
    atlas = 'j_hand_and_discard_quick_hand',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + 2
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - 2
        ease_hands_played(2)
        ease_discard(-2)
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - 2
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + 2
        ease_hands_played(-2)
        ease_discard(2)
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 687. Slow Hand
SMODS.Joker({
    key = 'j_hand_and_discard_slow_hand',
    config = { extra = { mult = 10, current_mult = 0 } },
    rarity = 2,
    atlas = 'j_hand_and_discard_slow_hand',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            card.ability.extra.current_mult = card.ability.extra.current_mult + card.ability.extra.mult
            return { message = "+" .. card.ability.extra.mult, colour = G.C.MULT }
        end
        if context.joker_main and card.ability.extra.current_mult > 0 then
            local bonus = card.ability.extra.current_mult
            card.ability.extra.current_mult = 0
            return {
                mult_mod = bonus,
                message = localize{type = 'variable', key = 'a_mult', vars = {bonus}},
                colour = G.C.MULT
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).current_mult } } end
})

-- 688. Ambidextrous
SMODS.Joker({
    key = 'j_hand_and_discard_ambidextrous',
    config = { extra = 10 },
    rarity = 2,
    atlas = 'j_hand_and_discard_ambidextrous',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then
            G.play.config.card_limit = card.ability.extra
        end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then
            G.play.config.card_limit = 5
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})



-- ============================================
-- HAND AND DISCARD - Rare & Legendary (689-700)
-- ============================================

-- 689. Hand of God
SMODS.Joker({
    key = 'j_hand_and_discard_hand_of_god',
    config = { extra = { played = 0, xmult_gain = 0.2 } },
    rarity = 3,
    atlas = 'j_hand_and_discard_hand_of_god',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local current_xmult = 1 + (card.ability.extra.played * card.ability.extra.xmult_gain)
            return {
                Xmult_mod = current_xmult,
                message = localize{type = 'variable', key = 'a_xmult', vars = {current_xmult}}
            }
        end
        if context.buying_card and not context.blueprint then
            card.ability.extra.played = (card.ability.extra.played or 0) + 1
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_gain, ( (card and card.ability and card.ability.extra) or self.config.extra ).played, 1 + (( (card and card.ability and card.ability.extra) or self.config.extra ).played * ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_gain) } } end
})

-- 690. Devil's Hand
SMODS.Joker({
    key = 'j_hand_and_discard_devils_hand',
    config = { extra = 3 },
    rarity = 3,
    atlas = 'j_hand_and_discard_devils_hand',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local highest_card = nil
            local max_rank = -1
            for k, v in ipairs(G.hand.cards) do
                if v.base.id > max_rank then
                    max_rank = v.base.id
                    highest_card = v
                end
            end
            if highest_card then
                if not highest_card.ability.eternal then highest_card:start_dissolve() end
            end
        end
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 691. King's Hand
SMODS.Joker({
    key = 'j_hand_and_discard_kings_hand',
    rarity = 3,
    atlas = 'j_hand_and_discard_kings_hand',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.cardarea == G.play and context.repetition and not context.repetition_only then
            local has_king = false
            for k, v in ipairs(context.scoring_hand) do
                if v.base.value == 'King' then has_king = true break end
            end
            if has_king and (context.other_card.base.value == 'King' or context.other_card.base.value == 'Queen') then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- 692. Queen's Hand
SMODS.Joker({
    key = 'j_hand_and_discard_queens_hand',
    config = { extra = { money = 5, mult = 10 } },
    rarity = 3,
    atlas = 'j_hand_and_discard_queens_hand',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_queen = false
            for k, v in ipairs(context.scoring_hand) do
                if v.base.value == 'Queen' then has_queen = true break end
            end
            if has_queen then
                ease_dollars(card.ability.extra.money)
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra.mult}},
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end
})

-- 693. Jack's Hand
SMODS.Joker({
    key = 'j_hand_and_discard_jacks_hand',
    config = { extra = 50 },
    rarity = 3,
    atlas = 'j_hand_and_discard_jacks_hand',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_jack = false
            for k, v in ipairs(context.scoring_hand) do
                if v.base.value == 'Jack' then has_jack = true break end
            end
            if has_jack then
                local bonus = #context.scoring_hand * card.ability.extra
                return {
                    chip_mod = bonus,
                    message = localize{type = 'variable', key = 'a_chips', vars = {bonus}},
                    colour = G.C.CHIPS,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 694. Ace's Hand
SMODS.Joker({
    key = 'j_hand_and_discard_aces_hand',
    rarity = 3,
    atlas = 'j_hand_and_discard_aces_hand',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local has_ace = false
            for k, v in ipairs(context.scoring_hand) do
                if v.base.value == 'Ace' then has_ace = true break end
            end
            if has_ace then
                for k, v in ipairs(context.scoring_hand) do
                    if v.base.value ~= 'Ace' then
                        v:set_base(G.P_CARDS[v.base.suit..'_A'])
                    end
                end
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.CHIPS,
                    card = card
                }
            end
        end
    end
})

-- 695. Infinite Hand
SMODS.Joker({
    key = 'j_hand_and_discard_infinite_hand',
    rarity = 3,
    atlas = 'j_hand_and_discard_infinite_hand',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.after and not context.blueprint then
            local cards_to_return = {}
            for k, v in ipairs(context.scoring_hand) do
                table.insert(cards_to_return, v)
            end
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    for i = #cards_to_return, 1, -1 do
                        draw_card(G.play, G.deck, 90, 'up', nil, cards_to_return[i])
                    end
                    return true
                end
            }))
            return {
                message = "Refill!",
                colour = G.C.BLUE,
                card = card
            }
        end
    end
})

-- 696. Infinite Discard
SMODS.Joker({
    key = 'j_hand_and_discard_infinite_discard',
    config = { extra = 1 },
    rarity = 3,
    atlas = 'j_hand_and_discard_infinite_discard',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        -- We'll handle this in 03_vanilla_override.lua for the discard button press
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 697. Supreme Hand
SMODS.Joker({
    key = 'j_hand_and_discard_supreme_hand',
    rarity = 3,
    atlas = 'j_hand_and_discard_supreme_hand',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Royal Flush" then
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    G.GAME.chips = G.GAME.blind.chips
                    return true
                end
            }))
            return {
                message = "SUPREME!",
                colour = G.C.GOLD,
                card = card
            }
        end
    end
})

-- 698. Void Hand
SMODS.Joker({
    key = 'j_hand_and_discard_void_hand',
    config = { extra = 10 },
    rarity = 3,
    atlas = 'j_hand_and_discard_void_hand',
    pos = { x = 0, y = 0 },
    cost = 15,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and #context.scoring_hand == 1 and context.scoring_name == "High Card" then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}},
                card = card
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 699. The Creator
SMODS.Joker({
    key = 'j_hand_and_discard_the_creator',
    rarity = 4,
    atlas = 'j_hand_and_discard_the_creator',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then
            G.hand.config.card_limit = G.hand.config.card_limit + 3
            G.GAME.round_resets.hands = G.GAME.round_resets.hands + 2
            G.GAME.round_resets.discards = G.GAME.round_resets.discards + 2
            ease_hands_played(2)
            ease_discard(2)
        end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then
            G.hand.config.card_limit = G.hand.config.card_limit - 3
            G.GAME.round_resets.hands = G.GAME.round_resets.hands - 2
            G.GAME.round_resets.discards = G.GAME.round_resets.discards - 2
            ease_hands_played(-2)
            ease_discard(-2)
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { 3, 2, 2 } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 700. The Destroyer
SMODS.Joker({
    key = 'j_hand_and_discard_the_destroyer',
    config = { extra = 6 },
    rarity = 4,
    atlas = 'j_hand_and_discard_the_destroyer',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.hand.config.card_limit = G.hand.config.card_limit - 2 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.hand.config.card_limit = G.hand.config.card_limit + 2 end
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}},
                card = card
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ), 2 } } end
})



-- ============================================
-- PROBABILITY AND LUCK - Common (701-720)
-- ============================================

-- 701. Four Leaf Clover
SMODS.Joker({
    key = 'j_luck_and_probability_four_leaf_clover',
    config = { extra = 0.1 },
    rarity = 1,
    atlas = 'j_luck_and_probability_four_leaf_clover',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal + card.ability.extra end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal - card.ability.extra end
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 702. Rabbit's Foot
SMODS.Joker({
    key = 'j_luck_and_probability_rabbit_s_foot',
    config = { extra = { mult = 5, odds = 2 } },
    rarity = 1,
    atlas = 'j_luck_and_probability_rabbit_s_foot',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('rabbit_s_foot') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra.mult}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds, ( (card and card.ability and card.ability.extra) or self.config.extra ).mult } } end
})

-- 703. Horseshoe
SMODS.Joker({
    key = 'j_luck_and_probability_horseshoe',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_luck_and_probability_horseshoe',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.deck and G.deck.cards then
                for k, v in ipairs(G.deck.cards) do
                    if v.config.center == G.P_CENTERS.m_lucky then count = count + 1 end
                end
            end
            if count > 0 then
                local bonus = count * card.ability.extra
                return {
                    chip_mod = bonus,
                    message = localize{type = 'variable', key = 'a_chips', vars = {bonus}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 704. D6 Die
SMODS.Joker({
    key = 'j_luck_and_probability_d6_die',
    rarity = 1,
    atlas = 'j_luck_and_probability_d6_die',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local total_mult = 0
            local dice_sides = (G.GAME.odyssey_dice_master and G.GAME.odyssey_dice_master > 0) and 12 or 6
            local sides = {}
            for i=1, dice_sides do table.insert(sides, i) end
            
            for i=1, #context.scoring_hand do
                total_mult = total_mult + pseudorandom_element(sides, pseudoseed('d6'))
            end
            return {
                mult_mod = total_mult,
                message = "Roll: " .. total_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 705. D20 Die
SMODS.Joker({
    key = 'j_luck_and_probability_d20_die',
    rarity = 1,
    atlas = 'j_luck_and_probability_d20_die',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local total_chips = 0
            local dice_sides = (G.GAME.odyssey_dice_master and G.GAME.odyssey_dice_master > 0) and 40 or 20
            local sides = {}
            for i=1, dice_sides do table.insert(sides, i) end
            
            for i=1, #context.scoring_hand do
                total_chips = total_chips + pseudorandom_element(sides, pseudoseed('d20'))
            end
            return {
                chip_mod = total_chips,
                message = "Crit: " .. total_chips,
                colour = G.C.CHIPS
            }
        end
    end
})

-- 706. Coin Flip
SMODS.Joker({
    key = 'j_luck_and_probability_coin_flip',
    config = { extra = 2 },
    rarity = 1,
    atlas = 'j_luck_and_probability_coin_flip',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('coin_flip') < G.GAME.probabilities.normal / 2 then
                return {
                    Xmult_mod = card.ability.extra,
                    message = "Heads!"
                }
            else
                return { message = "Tails...", colour = G.C.GREY }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, 2, ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 707. Safe Bet
SMODS.Joker({
    key = 'j_luck_and_probability_safe_bet',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_luck_and_probability_safe_bet',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 708. Risky Bet
SMODS.Joker({
    key = 'j_luck_and_probability_risky_bet',
    config = { extra = { mult = 40, odds = 4 } },
    rarity = 1,
    atlas = 'j_luck_and_probability_risky_bet',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('risky_bet') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = "Jackpot!"
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds, ( (card and card.ability and card.ability.extra) or self.config.extra ).mult } } end
})

-- 709. Raffle
SMODS.Joker({
    key = 'j_luck_and_probability_raffle',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_luck_and_probability_raffle',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.blueprint then
            if pseudorandom('raffle') < G.GAME.probabilities.normal / card.ability.extra then
                if #G.jokers.cards < G.jokers.config.card_limit then -- Check capacity
                    local card = create_card('Joker', G.jokers, nil, 0, nil, nil, nil, 'raffle')
                    card:add_to_deck()
                    G.jokers:emplace(card)
                    return { message = localize('k_plus_joker'), colour = G.C.BLUE }
                end
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 710. Bingo
SMODS.Joker({
    key = 'j_luck_and_probability_bingo',
    config = { extra = 5 },
    rarity = 1,
    atlas = 'j_luck_and_probability_bingo',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Straight" then
            ease_dollars(card.ability.extra)
            return { message = localize('$')..card.ability.extra, colour = G.C.MONEY }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 711. Jackpot
SMODS.Joker({
    key = 'j_luck_and_probability_jackpot',
    config = { extra = 20 },
    rarity = 1,
    atlas = 'j_luck_and_probability_jackpot',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local count_7 = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.base.value == '7' then count_7 = count_7 + 1 end
            end
            if count_7 >= 3 then
                ease_dollars(card.ability.extra)
                return { message = localize('$')..card.ability.extra, colour = G.C.MONEY }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 712. Slot Machine
SMODS.Joker({
    key = 'j_luck_and_probability_slot_machine',
    config = { extra = 15 },
    rarity = 1,
    atlas = 'j_luck_and_probability_slot_machine',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Three of a Kind" then
            return {
                mult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 713. Sports Betting
SMODS.Joker({
    key = 'j_luck_and_probability_sports_betting',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_luck_and_probability_sports_betting',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.blueprint then
            if G.GAME.current_round.hands_played == 2 then
                ease_dollars(card.ability.extra)
                return { message = localize('$')..card.ability.extra, colour = G.C.MONEY, card = card }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 714. Scratch Card
SMODS.Joker({
    key = 'j_luck_and_probability_scratch_card',
    rarity = 1,
    atlas = 'j_luck_and_probability_scratch_card',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.selling_self then
            local amount = pseudorandom_element({0,5,10,15,20}, pseudoseed('scratch'))
            ease_dollars(amount)
        end
    end
})

-- 715. Fortune Cookie
SMODS.Joker({
    key = 'j_luck_and_probability_fortune_cookie',
    config = { extra = { mult = 5, odds = 4 } },
    rarity = 1,
    atlas = 'j_luck_and_probability_fortune_cookie',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra.mult}}
            }
        end
        if context.using_consumeable and context.consumeable.ability.set == 'Tarot' and not context.blueprint then
            if pseudorandom('fortune_cookie') < G.GAME.probabilities.normal / card.ability.extra.odds then
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    func = function()
                        if #G.consumeables.cards < G.consumeables.config.card_limit then
                            local card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, nil, 'fort')
                            card:add_to_deck()
                            G.consumeables:emplace(card)
                        end
                        return true
                    end
                }))
                return { message = "Fortune!", colour = G.C.SECONDARY_SET.Spectral }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult, G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } } end
})

-- 716. Amulet
SMODS.Joker({
    key = 'j_luck_and_probability_amulet',
    rarity = 1,
    atlas = 'j_luck_and_probability_amulet',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_glass_protection = (G.GAME.odyssey_glass_protection or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_glass_protection = (G.GAME.odyssey_glass_protection or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 717. Talisman
SMODS.Joker({
    key = 'j_luck_and_probability_talisman',
    rarity = 1,
    atlas = 'j_luck_and_probability_talisman',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_lucky_double = (G.GAME.odyssey_lucky_double or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_lucky_double = (G.GAME.odyssey_lucky_double or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 718. Gargoyle
SMODS.Joker({
    key = 'j_luck_and_probability_gargoyle',
    config = { extra = 100 },
    rarity = 1,
    atlas = 'j_luck_and_probability_gargoyle',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_stone = false
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center == G.P_CENTERS.m_odyssey_emerald then has_stone = true break end
            end
            if has_stone then return { chips = card.ability.extra } end
        end
    end
})

-- 719. Evil Eye
SMODS.Joker({
    key = 'j_luck_and_probability_evil_eye',
    rarity = 1,
    atlas = 'j_luck_and_probability_evil_eye',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_evil_eye = (G.GAME.modifiers.odyssey_evil_eye or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_evil_eye = (G.GAME.modifiers.odyssey_evil_eye or 0) - 1
    end,
    calculate = function(self, card, context)
        -- Protection core is in Card:set_debuff override in utils.lua
    end
})

-- 720. Figa
SMODS.Joker({
    key = 'j_luck_and_probability_figa',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_luck_and_probability_figa',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_left == 0 then
            return { mult = card.ability.extra }
        end
    end
})


-- ============================================
-- PROBABILITY AND LUCK - Uncommon (721-738)
-- ============================================

-- 721. Luck Manipulator
SMODS.Joker({
    key = 'j_luck_and_probability_luck_manipulator',
    rarity = 2,
    atlas = 'j_luck_and_probability_luck_manipulator',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    -- Simplified: same as Four Leaf Clover but stronger
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal + 1 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal - 1 end
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 722. Dice Master
SMODS.Joker({
    key = 'j_luck_and_probability_dice_master',
    rarity = 2,
    atlas = 'j_luck_and_probability_dice_master',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_dice_master = (G.GAME.odyssey_dice_master or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_dice_master = (G.GAME.odyssey_dice_master or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 723. Lady Luck
SMODS.Joker({
    key = 'j_luck_and_probability_lady_luck',
    rarity = 2,
    atlas = 'j_luck_and_probability_lady_luck',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.cardarea == G.play and context.repetition and not context.repetition_only then
            if context.other_card.config.center == G.P_CENTERS.m_lucky then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- 724. Underdog
SMODS.Joker({
    key = 'j_luck_and_probability_underdog',
    config = { extra = 3 },
    rarity = 2,
    atlas = 'j_luck_and_probability_underdog',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.chips < G.GAME.blind.chips * 0.1 then
                return {
                    Xmult_mod = card.ability.extra,
                    message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 725. Black Cat
SMODS.Joker({
    key = 'j_luck_and_probability_black_cat',
    config = { extra = 2 },
    rarity = 2,
    atlas = 'j_luck_and_probability_black_cat',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 726. Broken Mirror
SMODS.Joker({
    key = 'j_luck_and_probability_broken_mirror',
    config = { extra = 2 },
    rarity = 2,
    atlas = 'j_luck_and_probability_broken_mirror',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.playing_cards then
                for k, v in ipairs(G.playing_cards) do
                    if v.config.center == G.P_CENTERS.m_odyssey_ceramic then count = count + 1 end
                end
            end
            if count > 0 then
                local bonus = 1 + (count * card.ability.extra)
                return {
                    Xmult_mod = bonus,
                    message = localize{type = 'variable', key = 'a_xmult', vars = {bonus}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 727. Three Leaf Clover
SMODS.Joker({
    key = 'j_luck_and_probability_three_leaf_clover',
    config = { extra = 30 },
    rarity = 2,
    atlas = 'j_luck_and_probability_three_leaf_clover',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal - 0.5 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal + 0.5 end
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 728. Sorte de Principiante (Beginner's Luck)
SMODS.Joker({
    key = 'j_luck_and_probability_beginner_s_luck',
    config = { extra = 2 },
    rarity = 2,
    atlas = 'j_luck_and_probability_beginner_s_luck',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.round_resets.ante <= 1 then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 729. Destino (Destiny)
SMODS.Joker({
    key = 'j_luck_and_probability_destiny',
    rarity = 2,
    atlas = 'j_luck_and_probability_destiny',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                func = function()
                    if #G.consumeables.cards < G.consumeables.config.card_limit then
                        local card = create_card('Consumeable', G.consumeables, nil, nil, nil, nil, nil, 'dest')
                        card:add_to_deck()
                        G.consumeables:emplace(card)
                    end
                    return true
                end
            }))
            return { message = "+Consumeable!", colour = G.C.PURPLE }
        end
    end
})

-- 730. Karma (Karma)
SMODS.Joker({
    key = 'j_luck_and_probability_karma',
    config = { extra = { mult = 0, gain = 5 } },
    rarity = 2,
    atlas = 'j_luck_and_probability_karma',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local lucky_count = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center == G.P_CENTERS.m_lucky then lucky_count = lucky_count + 1 end
            end
            if lucky_count > 0 then
                card.ability.extra.mult = card.ability.extra.mult + (lucky_count * card.ability.extra.gain)
                return { message = "Karma Up!", colour = G.C.MULT }
            end
            if card.ability.extra.mult > 0 then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra.mult}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).gain, (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end
})

-- 731. Roda do Destino (Wheel of Fate)
SMODS.Joker({
    key = 'j_luck_and_probability_wheel_of_fate',
    config = { extra = 4 },
    rarity = 2,
    atlas = 'j_luck_and_probability_wheel_of_fate',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.blueprint then
            if pseudorandom('wheel_fate') < G.GAME.probabilities.normal / card.ability.extra then
                local eligible_jokers = {}
                for k, v in ipairs(G.jokers.cards) do
                    if v ~= card and not v.edition then table.insert(eligible_jokers, v) end
                end
                if #eligible_jokers > 0 then
                    local target = pseudorandom_element(eligible_jokers, pseudoseed('wheel_fate_target'))
                    target:set_edition({polychrome = true})
                    return { message = "Polychrome!", colour = G.C.DARK_EDITION }
                end
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 732. Oráculo (Oracle)
SMODS.Joker({
    key = 'j_luck_and_probability_oracle',
    rarity = 2,
    atlas = 'j_luck_and_probability_oracle',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    loc_vars = function(self, info_queue, card)
        local top_cards = {}
        if G.deck and G.deck.cards then
            -- Balatro draws from the end of the cards table
            for i = 0, 2 do
                local c = G.deck.cards[#G.deck.cards - i]
                if c then
                    -- Get the display name of the card
                    local rank = c.base.value
                    local suit = localize(c.base.suit, 'suits_singular')
                    table.insert(top_cards, rank .. " de " .. suit)
                else
                    table.insert(top_cards, "---")
                end
            end
        end
        return { vars = { top_cards[1] or "---", top_cards[2] or "---", top_cards[3] or "---" } }
    end,
    calculate = function(self, card, context)
        -- Purely informational joker
    end
})

-- 733. Profecia (Prophecy)
SMODS.Joker({
    key = 'j_luck_and_probability_prophecy',
    rarity = 2,
    atlas = 'j_luck_and_probability_prophecy',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
             if G.GAME.round_resets.ante >= 8 then
                 local card = create_card('Joker', G.jokers, nil, 0.99, nil, nil, nil, 'prop')
                 card:set_edition({negative = true})
                 card:add_to_deck()
                 G.jokers:emplace(card)
                 return { message = "Fulfillment!", colour = G.C.PURPLE }
             end
        end
    end
})

-- 734. Sorte Cega (Blind Luck)
SMODS.Joker({
    key = 'j_luck_and_probability_blind_luck',
    rarity = 2,
    atlas = 'j_luck_and_probability_blind_luck',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_blind_luck = (G.GAME.odyssey_blind_luck or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_blind_luck = (G.GAME.odyssey_blind_luck or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 735. Acaso (Chance)
SMODS.Joker({
    key = 'j_luck_and_probability_chance',
    config = { extra = { xmult = 2.5, odds = 10 } },
    rarity = 2,
    atlas = 'j_luck_and_probability_chance',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('chance') < G.GAME.probabilities.normal / card.ability.extra.odds then
                if not card.ability.eternal then card:start_dissolve() end
                return { message = "Lost!", colour = G.C.GREY }
            end
            return {
                Xmult_mod = card.ability.extra.xmult,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra.xmult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult, G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } } end
})

-- 736. Serendipidade (Serendipity)
SMODS.Joker({
    key = 'j_luck_and_probability_serendipity',
    rarity = 2,
    atlas = 'j_luck_and_probability_serendipity',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_serendipity = (G.GAME.odyssey_serendipity or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_serendipity = (G.GAME.odyssey_serendipity or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 737. Milagre (Miracle)
SMODS.Joker({
    key = 'j_luck_and_probability_miracle',
    config = { extra = 1000 },
    rarity = 2,
    atlas = 'j_luck_and_probability_miracle',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('miracle') < G.GAME.probabilities.normal / card.ability.extra then
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    func = function()
                        G.GAME.chips = G.GAME.blind.chips + 1
                        return true
                    end
                }))
                return { message = "MIRACLE!", colour = G.C.GOLD }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 738. Divindade (Divinity)
SMODS.Joker({
    key = 'j_luck_and_probability_divinity',
    config = { extra = 20 },
    rarity = 2,
    atlas = 'j_luck_and_probability_divinity',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_lucky then
                -- Lucky card trigger check is internal to Card:calculate_joker
                -- We'll just give a flat bonus if it's a lucky card scoring
                return {
                    mult = card.ability.extra,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})


-- ============================================
-- PROBABILITY AND LUCK - Rare & Legendary (739-750)
-- ============================================

-- 739. Goddess of Fortune
SMODS.Joker({
    key = 'j_luck_and_probability_goddess_of_fortune',
    rarity = 3,
    atlas = 'j_luck_and_probability_goddess_of_fortune',
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal + 10 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal - 10 end
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 740. Controlled Chaos
SMODS.Joker({
    key = 'j_luck_and_probability_controlled_chaos',
    rarity = 3,
    atlas = 'j_luck_and_probability_controlled_chaos',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal + 2 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal - 2 end
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 741. Infinite Luck
SMODS.Joker({
    key = 'j_luck_and_probability_infinite_luck',
    config = { extra = { money = 20, mult = 20 } },
    rarity = 3,
    atlas = 'j_luck_and_probability_infinite_luck',
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_force_success = (G.GAME.odyssey_force_success or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_force_success = (G.GAME.odyssey_force_success or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 742. Improbability
SMODS.Joker({
    key = 'j_luck_and_probability_improbability',
    config = { extra = { xmult = 3, odds = 100 } },
    rarity = 3,
    atlas = 'j_luck_and_probability_improbability',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('improb') < G.GAME.probabilities.normal / card.ability.extra.odds then
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    func = function()
                        for k, v in ipairs(G.jokers.cards) do v:start_dissolve() end
                        return true
                    end
                }))
                return { message = "IMPROBABLE!", colour = G.C.BLACK }
            end
            return {
                Xmult_mod = card.ability.extra.xmult,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra.xmult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult, G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } } end
})

-- 743. Zero Entropy
SMODS.Joker({
    key = 'j_luck_and_probability_zero_entropy',
    config = { extra = { money = 1000, odds = 1000 } },
    rarity = 3,
    atlas = 'j_luck_and_probability_zero_entropy',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.blueprint then
            if pseudorandom('entropy') < G.GAME.probabilities.normal / card.ability.extra.odds then
                ease_dollars(card.ability.extra.money)
                return { message = "JACKPOT!", colour = G.C.GOLD }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds, ( (card and card.ability and card.ability.extra) or self.config.extra ).money } } end
})

-- 744. The Chosen One
SMODS.Joker({
    key = 'j_luck_and_probability_the_chosen_one',
    config = { extra = 5 },
    rarity = 3,
    atlas = 'j_luck_and_probability_the_chosen_one',
    pos = { x = 0, y = 0 },
    cost = 15,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_glass_protection = (G.GAME.odyssey_glass_protection or 0) + 1
        G.GAME.odyssey_force_success = (G.GAME.odyssey_force_success or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_glass_protection = (G.GAME.odyssey_glass_protection or 0) - 1
        G.GAME.odyssey_force_success = (G.GAME.odyssey_force_success or 0) - 1
    end,
    calculate = function(self, card, context)
        if context.joker_main then return { Xmult = card.ability.extra } end
    end
})

-- 745. Holy Grail
SMODS.Joker({
    key = 'j_luck_and_probability_holy_grail',
    config = { extra = { xmult = 3, money = 10 } },
    rarity = 3,
    atlas = 'j_luck_and_probability_holy_grail',
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra.xmult,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra.xmult}}
            }
        end
        if context.end_of_round and not context.other_card and not context.blueprint then
            ease_dollars(card.ability.extra.money)
            return { message = localize('$')..card.ability.extra.money, colour = G.C.MONEY }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).xmult, (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end
})

-- 746. Golden Midas Hand
SMODS.Joker({
    key = 'j_luck_and_probability_golden_midas_hand',
    rarity = 3,
    atlas = 'j_luck_and_probability_golden_midas_hand',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                v:set_ability(G.P_CENTERS.m_odyssey_plastic, nil, true)
                v:juice_up()
            end
            return { message = "Gold!", colour = G.C.GOLD }
        end
    end
})

-- 747. Cosmic Clover
SMODS.Joker({
    key = 'j_luck_and_probability_cosmic_clover',
    config = { extra = 100 },
    rarity = 3,
    atlas = 'j_luck_and_probability_cosmic_clover',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.playing_cards then
                for k, v in ipairs(G.playing_cards) do
                    if v.base.value == '7' then count = count + 1 end
                end
            end
            if count > 0 then
                local bonus = count * card.ability.extra
                return {
                    chip_mod = bonus,
                    message = localize{type = 'variable', key = 'a_chips', vars = {bonus}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 748. 777
SMODS.Joker({
    key = 'j_luck_and_probability_777',
    config = { extra = { money = 77, xmult = 7 } },
    rarity = 3,
    atlas = 'j_luck_and_probability_777',
    pos = { x = 0, y = 0 },
    cost = 21,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local sevens = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.base.value == '7' then sevens = sevens + 1 end
            end
            if sevens >= 3 then
                ease_dollars(card.ability.extra.money)
                return {
                    Xmult_mod = card.ability.extra.xmult,
                    message = "777!",
                    colour = G.C.GOLD
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).xmult, (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end
})

-- 749. Fortuna
SMODS.Joker({
    key = 'j_luck_and_probability_fortuna',
    config = { extra = 5 },
    rarity = 4,
    atlas = 'j_luck_and_probability_fortuna',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.round_resets.reroll_cost = 0 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.round_resets.reroll_cost = 2 end
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 750. Manifest Destiny
SMODS.Joker({
    key = 'j_luck_and_probability_manifest_destiny',
    config = { extra = 10 },
    rarity = 4,
    atlas = 'j_luck_and_probability_manifest_destiny',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_force_success = (G.GAME.odyssey_force_success or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_force_success = (G.GAME.odyssey_force_success or 0) - 1
    end,
    calculate = function(self, card, context)
        if context.joker_main then
             return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})


----------------------------------------------
-- TRANSFORMATIONS (COMMON) J751-J770
----------------------------------------------

-- J751 Chameleon
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_chameleon',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_chameleon',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = false,
    calculate = function(self, card, context)
        -- Hand suit copying logic usually implemented in Card:is_suit or similar
    end
})

-- J752 Mimic
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_mimic',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_mimic',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = false,
    calculate = function(self, card, context)
        -- Hand rank copying logic usually implemented in Card:get_id or similar
    end
})

-- J753 Shapeshifter
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_shapeshifter',
    config = { extra = { mult = 10, suit = 'Hearts' } },
    rarity = 1,
    atlas = 'j_transformations_shapeshifter',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.suit } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.before and not context.blueprint then
            local suits = {'Hearts', 'Diamonds', 'Spades', 'Clubs'}
            card.ability.extra.suit = suits[math.random(#suits)]
        end
    end
})

-- J754 Doppelganger
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_doppelganger',
    config = { extra = { chips = 20 } },
    rarity = 1,
    atlas = 'j_transformations_doppelganger',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local prev_card = nil
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i] == context.other_card then
                    if i > 1 then prev_card = context.scoring_hand[i-1] end
                    break
                end
            end
            if prev_card and prev_card.base.value == context.other_card.base.value then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
    end
})

-- J755 Magic Mirror
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_magic_mirror',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_magic_mirror',
    pos = { x = 0, y = 0 },
    cost = 5,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_magic_mirror = (G.GAME.modifiers.odyssey_magic_mirror or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_magic_mirror = (G.GAME.modifiers.odyssey_magic_mirror or 0) - 1
    end,
    calculate = function(self, card, context)
        -- Protection core is in Card:get_id override in utils.lua
    end
})

-- J756 Prism
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_prism',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_prism',
    pos = { x = 0, y = 0 },
    cost = 4,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                v:set_edition({polychrome = true}, true, true)
            end
        end
    end
})

-- J757 Catalyst
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_catalyst',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_catalyst',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.joker_main then
            -- This is usually implemented as a global hook in vanilla_override
            -- but we can try to find scaling jokers and double their gain here
        end
    end
})

-- J758 Evolution
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_evolution',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_evolution',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local is_seq = true
            if #context.scoring_hand < 3 then is_seq = false end
            if is_seq then
                table.sort(context.scoring_hand, function(a, b) return a:get_id() < b:get_id() end)
                for i = 1, #context.scoring_hand - 1 do
                    if context.scoring_hand[i+1]:get_id() ~= context.scoring_hand[i]:get_id() + 1 then
                        is_seq = false
                        break
                    end
                end
            end
            if is_seq then
                for _, v in ipairs(context.scoring_hand) do
                    if v:get_id() < 14 then -- Not Ace (can't go higher than Ace easily)
                        v:set_base(G.P_CARDS[v.config.card_key:sub(1,1)..(string.format("%X", v:get_id()+1))])
                    end
                end
                return {
                    message = "Evolve!",
                    colour = G.C.RED
                }
            end
        end
    end
})

-- J759 Devolution
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_devolution',
    config = { extra = { mult = 20 } },
    rarity = 1,
    atlas = 'j_transformations_devolution',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local is_seq = true
            if #context.scoring_hand < 3 then is_seq = false end
            if is_seq then
                table.sort(context.scoring_hand, function(a, b) return a:get_id() < b:get_id() end)
                for i = 1, #context.scoring_hand - 1 do
                    if context.scoring_hand[i+1]:get_id() ~= context.scoring_hand[i]:get_id() + 1 then
                        is_seq = false
                        break
                    end
                end
            end
            if is_seq then
                for _, v in ipairs(context.scoring_hand) do
                    if v:get_id() > 2 then
                        v:set_base(G.P_CARDS[v.config.card_key:sub(1,1)..(string.format("%X", v:get_id()-1))])
                    end
                end
                card.ability.extra.triggered = true
            end
        end
        if context.joker_main and card.ability.extra.triggered then
            card.ability.extra.triggered = false
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J760 Transmuter
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_transmuter',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_transmuter',
    pos = { x = 0, y = 0 },
    cost = 4,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                if v:is_suit('Diamonds') then
                    v:change_suit('Hearts')
                end
            end
        end
    end
})

-- J761 Converter
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_converter',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_converter',
    pos = { x = 0, y = 0 },
    cost = 4,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                if v:is_suit('Spades') then
                    v:change_suit('Clubs')
                end
            end
        end
    end
})

-- J762 Basic Alchemy
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_basic_alchemy',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_basic_alchemy',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            for k, v in ipairs(context.full_hand) do
                if v:get_id() >= 2 and v:get_id() <= 4 then
                    v:set_ability(G.P_CENTERS.m_odyssey_plastic)
                end
            end
        end
    end
})

-- J763 Polymorph
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_polymorph',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_polymorph',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local triggered = false
            for k, v in ipairs(context.scoring_hand) do
                if v:is_face() then
                    local rank = pseudorandom_element({'2','3','4','5','6','7','8','9','10'}, pseudorandom('polymorph'))
                    local suit = v.base.suit:sub(1,1)
                    v:set_base(G.P_CARDS[suit..'_'..rank])
                    triggered = true
                end
            end
            if triggered then 
                return {
                    message = "Polymorph!",
                    colour = G.C.FILTER
                }
            end
        end
    end
})

-- J764 Mask
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_mask',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_mask',
    pos = { x = 0, y = 0 },
    cost = 5,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_mask = (G.GAME.modifiers.odyssey_mask or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_mask = (G.GAME.modifiers.odyssey_mask or 0) - 1
    end,
    calculate = function(self, card, context)
        -- Logic handled in Card:is_suit override
    end
})

-- J765 Disguise
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_disguise',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_disguise',
    pos = { x = 0, y = 0 },
    cost = 5,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_disguise = (G.GAME.modifiers.odyssey_disguise or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_disguise = (G.GAME.modifiers.odyssey_disguise or 0) - 1
    end,
    calculate = function(self, card, context)
        -- Logic handled in Card:is_face override
    end
})

-- J766 Costume
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_costume',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_transformations_costume',
    pos = { x = 0, y = 0 },
    cost = 4,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J767 Makeup
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_makeup',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_makeup',
    pos = { x = 0, y = 0 },
    cost = 5,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_makeup = (G.GAME.modifiers.odyssey_makeup or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_makeup = (G.GAME.modifiers.odyssey_makeup or 0) - 1
    end,
    calculate = function(self, card, context)
        -- Logic handled in Card:is_suit override
    end
})

-- J768 Wig
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_wig',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_wig',
    pos = { x = 0, y = 0 },
    cost = 4,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_wig = (G.GAME.modifiers.odyssey_wig or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_wig = (G.GAME.modifiers.odyssey_wig or 0) - 1
    end,
    calculate = function(self, card, context)
        -- Logic handled in Card:get_id override
    end
})

-- J769 Fake Beard
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_fake_beard',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_fake_beard',
    pos = { x = 0, y = 0 },
    cost = 4,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_fake_beard = (G.GAME.modifiers.odyssey_fake_beard or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_fake_beard = (G.GAME.modifiers.odyssey_fake_beard or 0) - 1
    end,
    calculate = function(self, card, context)
        -- Logic handled in Card:get_id override
    end
})

-- J770 Shadow
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_shadow',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_shadow',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            if G.GAME.last_played_cards and #G.GAME.last_played_cards > 0 then
                local last_card = G.GAME.last_played_cards[1]
                local phantom = copy_card(last_card)
                phantom:set_edition({negative = true})
                phantom.ability.perishable = true
                phantom.ability.perish_tally = 1
                phantom:add_to_deck()
                G.hand:emplace(phantom)
                return {
                    message = "Shadow!",
                    colour = G.C.PURPLE
                }
            end
        end
    end
})


----------------------------------------------
-- TRANSFORMATIONS (UNCOMMON) J771-J788
----------------------------------------------

-- J771 Vampire (Steamodded already has a Vampire, but we add our own or override)
-- We use a prefix to avoid conflict
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_vampire',
    config = { extra = { x_mult = 1, x_mult_mod = 0.2 } },
    rarity = 2,
    atlas = 'j_transformations_vampire',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.x_mult_mod } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
        if context.before and not context.blueprint then
            local enhanced_found = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center ~= G.P_CENTERS.c_base then
                    v:set_ability(G.P_CENTERS.c_base)
                    enhanced_found = enhanced_found + 1
                end
            end
            if enhanced_found > 0 then
                card.ability.extra.x_mult = card.ability.extra.x_mult + (enhanced_found * card.ability.extra.x_mult_mod)
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- J772 Werewolf
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_werewolf',
    config = { extra = { chips = 50 } },
    rarity = 2,
    atlas = 'j_transformations_werewolf',
    pos = { x = 0, y = 0 },
    cost = 6,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_face() then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
    end
})

-- J773 Frankenstein
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_frankenstein',
    config = {},
    rarity = 2,
    atlas = 'j_transformations_frankenstein',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.discard and not context.other_card and not context.blueprint then
            -- We wait for the discard to finish
            if #context.full_hand >= 2 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Suit', G.hand, nil, nil, nil, nil, nil, 'frank')
                        new_card:add_to_deck()
                        G.hand:emplace(new_card)
                        return true
                    end
                }))
                return {
                    message = "It's Alive!",
                    colour = G.C.GREEN
                }
            end
        end
    end
})

-- J774 Zombie
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_zombie',
    config = { extra = { odds = 4 } },
    rarity = 2,
    atlas = 'j_transformations_zombie',
    pos = { x = 0, y = 0 },
    cost = 6,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal or 1, extra.odds } }

    end,
    calculate = function(self, card, context)
        if context.discard and context.other_card and not context.blueprint then
            if pseudorandom('zombie') < G.GAME.probabilities.normal / card.ability.extra.odds then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Default', G.hand, nil, nil, nil, nil, 'm_odyssey_undead', 'zombie')
                        new_card:add_to_deck()
                        G.hand:emplace(new_card)
                        new_card:start_materialize()
                        return true
                    end
                }))
                return {
                    message = "Undead!",
                    colour = G.C.RED
                }
            end
        end
    end
})

-- J775 Phantom of the Opera
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_phantom_of_the_opera',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_transformations_phantom_of_the_opera',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.joker_main then
            local faces = 0
            for k, v in ipairs(context.scoring_hand) do
                if v:is_face() then faces = faces + 1 end
            end
            if faces == 1 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J776 Jekyll & Hyde
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_jekyll_hyde',
    config = { extra = { active = false, x_mult_a = 0.5, x_mult_b = 4 } },
    rarity = 2,
    atlas = 'j_transformations_jekyll_hyde',
    pos = { x = 0, y = 0 },
    cost = 6,
    loc_vars = function(self, info_queue, card)
        local current_x = ( (card and card.ability and card.ability.extra) or self.config.extra ).active and ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_b or ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_a
        return { vars = { current_x } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local val = card.ability.extra.active and card.ability.extra.x_mult_b or card.ability.extra.x_mult_a
            return {
                x_mult = val,
                message = localize { type = 'variable', key = 'a_xmult', vars = { val } }
            }
        end
        if context.after and not context.blueprint then
            card.ability.extra.active = not card.ability.extra.active
        end
    end
})

-- J777 Mutant
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_mutant',
    config = { extra = { mult = 10 } },
    rarity = 2,
    atlas = 'j_transformations_mutant',
    pos = { x = 0, y = 0 },
    cost = 6,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J778 Hybrid
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_hybrid',
    config = {},
    rarity = 2,
    atlas = 'j_transformations_hybrid',
    pos = { x = 0, y = 0 },
    cost = 7,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_hybrid = (G.GAME.modifiers.odyssey_hybrid or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_hybrid = (G.GAME.modifiers.odyssey_hybrid or 0) - 1
    end,
    calculate = function(self, card, context)
        -- Logic handled in Card:is_suit override
    end
})

-- J779 Chimera
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_chimera',
    config = { extra = { mult = 10, chips = 50, money = 1, x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_transformations_chimera',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_face() then
                if context.other_card:is_suit('Hearts') then
                    return { mult = card.ability.extra.mult, card = card }
                elseif context.other_card:is_suit('Spades') then
                    return { chips = card.ability.extra.chips, card = card }
                elseif context.other_card:is_suit('Diamonds') then
                    return { dollars = card.ability.extra.money, card = card }
                elseif context.other_card:is_suit('Clubs') then
                    return { x_mult = card.ability.extra.x_mult, card = card }
                end
            end
        end
    end
})

-- J780 Hydra
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_hydra',
    config = {},
    rarity = 2,
    atlas = 'j_transformations_hydra',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.1,
                func = function()
                    G.FUNCS.draw_from_deck_to_hand(2)
                    return true
                end
            }))
        end
    end
})

-- J781 Dark Phoenix
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_dark_phoenix',
    config = {},
    rarity = 2,
    atlas = 'j_transformations_dark_phoenix',
    pos = { x = 0, y = 0 },
    cost = 7,
    loc_vars = function(self, info_queue, card)
        info_queue[#info_queue+1] = G.P_CENTERS.m_odyssey_platinum
        return { vars = {} }
    end,
    calculate = function(self, card, context)
        if context.after and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        v:start_dissolve()
                        local new_card = create_card('Suit', G.deck, nil, nil, nil, nil, nil, 'dark_phoenix')
                        new_card:set_ability(G.P_CENTERS.m_odyssey_platinum)
                        new_card:add_to_deck()
                        G.deck:emplace(new_card)
                        return true
                    end
                }))
            end
            return {
                message = "Reborn!",
                colour = G.C.RED
            }
        end
    end
})

-- J782 Basilisk
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_basilisk',
    config = {},
    rarity = 2,
    atlas = 'j_transformations_basilisk',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.after and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                v:set_ability(G.P_CENTERS.m_odyssey_emerald)
            end
        end
    end
})

-- J783 Medusa
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_medusa',
    config = { extra = { mult = 50 } },
    rarity = 2,
    atlas = 'j_transformations_medusa',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.before and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                if v:is_face() and not (v.config.center == G.P_CENTERS.m_odyssey_emerald) then
                    v:set_ability(G.P_CENTERS.m_odyssey_emerald)
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            v:juice_up()
                            return true
                        end
                    }))
                end
            end
        end
    end
})

-- J784 Siren
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_siren',
    config = {},
    rarity = 2,
    atlas = 'j_transformations_siren',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.first_hand_drawn then
            -- This is hard to implement with just calculate hooks without more complex logic
            -- Better to make it give a bonus to a specific suit that changes?
            -- Let's stick to a simpler interpretation for now:
            -- Better draw power?
        end
        if context.joker_main then
            -- Let's give it +10 chips for every card of the same suit as the first card in hand
            local first_card = G.hand.cards[1]
            if first_card then
                local first_suit = first_card.base.suit
                local count = 0
                for k, v in ipairs(context.scoring_hand) do
                    if v.base.suit == first_suit then
                        count = count + 1
                    end
                end
                if count > 0 then
                    return {
                        chips = count * 20,
                        message = localize { type = 'variable', key = 'a_chips', vars = { count * 20 } }
                    }
                end
            end
        end
    end
})

-- J785 Griffin
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_griffin',
    config = { extra = { chips = 0, chip_gain = 10 } },
    rarity = 2,
    atlas = 'j_transformations_griffin',
    pos = { x = 0, y = 0 },
    cost = 7,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.chip_gain } }

    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            if context.scoring_name == 'Pair' or context.scoring_name == 'Two Pair' or context.scoring_name == 'Three of a Kind' or context.scoring_name == 'Full House' or context.scoring_name == 'Four of a Kind' or context.scoring_name == 'Five of a Kind' then
                card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chip_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.CHIPS
                }
            end
        end
        if context.joker_main then
            return {
                chips = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- J786 Dragon
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_dragon',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_transformations_dragon',
    pos = { x = 0, y = 0 },
    cost = 8,
    calculate = function(self, card, context)
        if context.joker_main then
            local flush = true
            local gold = false
            local first_suit = context.scoring_hand[1].base.suit
            for k, v in ipairs(context.scoring_hand) do
                if v.base.suit ~= first_suit then flush = false end
                if v.ability.name == 'Gold Card' then gold = true end
            end
            if flush and gold then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J787 Unicorn
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_unicorn',
    config = { extra = { x_mult = 2.5 } },
    rarity = 2,
    atlas = 'j_transformations_unicorn',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            for k, v in ipairs(context.scoring_hand) do
                suits[v.base.suit] = true
            end
            local count = 0
            for _ in pairs(suits) do count = count + 1 end
            if count >= 4 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J788 Centaur
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_centaur',
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_transformations_centaur',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.joker_main then
            local face = false
            local common = false
            for k, v in ipairs(context.scoring_hand) do
                if v:is_face() then face = true end
                if not v:is_face() and v.base.value ~= 'Ace' then common = true end
            end
            if face and common then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})


----------------------------------------------
-- TRANSFORMATIONS (RARE) J789-J798
----------------------------------------------

-- J789 Metamorphosis
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_metamorphosis',
    config = {},
    rarity = 3,
    atlas = 'j_transformations_metamorphosis',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.blueprint and not context.other_card then
            local area = card.area
            local rarity = card.config.center.rarity
            local key = nil
            while not key or key == 'j_transformations_metamorphosis' do
                key = SMODS.poll_joker({rarity = rarity}).key
            end
            G.E_MANAGER:add_event(Event({
                func = function()
                    card:remove()
                    local new_card = create_card('Joker', area, nil, nil, nil, nil, key)
                    new_card:add_to_deck()
                    area:emplace(new_card)
                    return true
                end
            }))
            return {
                message = "Metamorphosis!",
                colour = G.C.BLUE
            }
        end
    end
})

-- J790 Transcendence
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_transcendence',
    config = {},
    rarity = 3,
    atlas = 'j_transformations_transcendence',
    pos = { x = 0, y = 0 },
    cost = 8,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        if context.selling_self and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                func = function()
                    local to_replace = {}
                    for i = 1, #G.jokers.cards do
                        local v = G.jokers.cards[i]
                        if v.config.center.rarity == 1 and v ~= card then
                            table.insert(to_replace, v)
                        end
                    end
                    for _, v in ipairs(to_replace) do
                        local new_card = create_card('Joker', G.jokers, nil, 0.8, nil, nil, nil, 'transcendence')
                        v:remove()
                        new_card:add_to_deck()
                        G.jokers:emplace(new_card)
                        new_card:start_materialize()
                    end
                    return true
                end
            }))
            return { message = "Transcended!", colour = G.C.BLUE }
        end
    end
})

-- J791 Ascension
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_ascension',
    config = {},
    rarity = 3,
    atlas = 'j_transformations_ascension',
    pos = { x = 0, y = 0 },
    cost = 8,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        if context.selling_self and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                func = function()
                    local to_replace = {}
                    for i = 1, #G.jokers.cards do
                        local v = G.jokers.cards[i]
                        if v.config.center.rarity == 2 and v ~= card then
                            table.insert(to_replace, v)
                        end
                    end
                    for _, v in ipairs(to_replace) do
                        local new_card = create_card('Joker', G.jokers, nil, 0.95, nil, nil, nil, 'ascension')
                        v:remove()
                        new_card:add_to_deck()
                        G.jokers:emplace(new_card)
                        new_card:start_materialize()
                    end
                    return true
                end
            }))
            return { message = "Ascended!", colour = G.C.ORANGE }
        end
    end
})

-- J792 Apotheosis
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_apotheosis',
    config = {},
    rarity = 3,
    atlas = 'j_transformations_apotheosis',
    pos = { x = 0, y = 0 },
    cost = 10,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        if context.selling_self and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                func = function()
                    local rank = pseudorandom_element({'2','3','4','5','6','7','8','9','10','J','Q','K','A'}, pseudorandom('apotheosis_rank'))
                    local suit = pseudorandom_element({'S','H','C','D'}, pseudorandom('apotheosis_suit'))
                    local center = G.P_CARDS[suit..'_'..rank]
                    for _, v in ipairs(G.playing_cards) do
                        v:set_base(center)
                    end
                    return true
                end
            }))
            return { message = "Apotheosis!", colour = G.C.GOLD }
        end
    end
})

-- J793 Singularity
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_singularity',
    config = {},
    rarity = 3,
    atlas = 'j_transformations_singularity',
    pos = { x = 0, y = 0 },
    cost = 10,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        if context.selling_self and not context.blueprint then
             -- Singularity: Simplification - Gives a random Legendary Joker instead of merging (too complex)
             G.E_MANAGER:add_event(Event({
                func = function()
                    local new_card = create_card('Joker', G.jokers, true, 4, nil, nil, nil, 'singularity')
                    new_card:add_to_deck()
                    G.jokers:emplace(new_card)
                    new_card:start_materialize()
                    return true
                end
            }))
            return { message = "Singularity!", colour = G.C.BLACK }
        end
    end
})

-- J794 Big Bang
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_big_bang',
    config = {},
    rarity = 3,
    atlas = 'j_transformations_big_bang',
    pos = { x = 0, y = 0 },
    cost = 10,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        if context.selling_self and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                func = function()
                    for i = #G.playing_cards, 1, -1 do
                        G.playing_cards[i]:remove()
                    end
                    G.playing_cards = {}
                    for i = 1, 52 do
                        local new_card = create_card('Default', G.deck, nil, nil, nil, nil, nil, 'big_bang')
                        new_card:add_to_deck()
                        G.deck:emplace(new_card)
                        table.insert(G.playing_cards, new_card)
                    end
                    return true
                end
            }))
            return { message = "Big Bang!", colour = G.C.WHITE }
        end
    end
})

-- J795 Reincarnation
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_reincarnation',
    config = { extra = { x_mult = 1.2 } },
    rarity = 3,
    atlas = 'j_transformations_reincarnation',
    pos = { x = 0, y = 0 },
    cost = 8,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        if context.selling_self and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                func = function()
                    local new_card = create_card('Joker', G.shop_jokers, nil, nil, nil, nil, 'j_transformations_reincarnation', 'reincarnation')
                    new_card.ability.extra.x_mult = (card.ability.extra.x_mult or 1.2) + 0.2
                    new_card:add_to_deck()
                    if G.shop_jokers then G.shop_jokers:emplace(new_card) end
                    return true
                end
            }))
            return { message = "Reincarnated!", colour = G.C.RED }
        end
    end
})

-- J796 Evolution Final
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_final_evolution',
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    atlas = 'j_transformations_final_evolution',
    pos = { x = 0, y = 0 },
    cost = 9,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local evolved_count = 0
            for _, v in ipairs(G.jokers.cards) do
                if v.edition and v.edition.key and v.edition.key:find('odyssey_lunar') then
                    evolved_count = evolved_count + 1
                end
            end
            if evolved_count >= 5 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- J797 Perfect Form
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_perfect_form',
    config = { extra = { x_mult = 4, odyssey_immune = true } },
    rarity = 3,
    atlas = 'j_transformations_perfect_form',
    pos = { x = 0, y = 0 },
    cost = 10,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- J798 Primal Chaos
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_primal_chaos',
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    atlas = 'j_transformations_primal_chaos',
    pos = { x = 0, y = 0 },
    cost = 10,
    calculate = function(self, card, context)
        if context.end_of_round and not context.blueprint and not context.repetition and not context.other_card then
            G.E_MANAGER:add_event(Event({
                func = function()
                    for _, v in ipairs(G.playing_cards) do
                        local rank = pseudorandom_element({'2','3','4','5','6','7','8','9','10','J','Q','K','A'}, pseudorandom('primal_chaos_rank'))
                        local suit = pseudorandom_element({'S','H','C','D'}, pseudorandom('primal_chaos_suit'))
                        v:set_base(G.P_CARDS[suit..'_'..rank])
                    end
                    return true
                end
            }))
            return {
                message = "Chaotic!",
                colour = G.C.PURPLE
            }
        end
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})


----------------------------------------------
-- TRANSFORMATIONS (LEGENDARY) J799-J800
----------------------------------------------

-- J799 The Changeling
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_the_changeling',
    config = { extra = { copied_key = nil } },
    rarity = 4,
    atlas = 'j_transformations_the_changeling',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.copied_key or 'None' } }

    end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            local legendary_keys = {}
            for k, v in pairs(G.P_CENTERS) do
                if v.set == 'Joker' and v.rarity == 4 and k ~= 'j_transformations_the_changeling' then
                    table.insert(legendary_keys, k)
                end
            end
            card.ability.extra.copied_key = legendary_keys[math.random(#legendary_keys)]
            return {
                message = "Copied " .. card.ability.extra.copied_key,
                colour = G.C.PURPLE
            }
        end

        if card.ability.extra.copied_key then
            local other_joker = G.P_CENTERS[card.ability.extra.copied_key]
            if other_joker and other_joker.calculate then
                return other_joker:calculate(card, context)
            end
        end
    end
})

-- J800 Proteus
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_proteus',
    config = { extra = { x_mult = 1, hand_types = {} } },
    rarity = 4,
    atlas = 'j_transformations_proteus',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, #extra.hand_types } }

    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local hand_type = context.scoring_name
            if hand_type and not card.ability.extra.hand_types[hand_type] then
                card.ability.extra.hand_types[hand_type] = true
                card.ability.extra.x_mult = card.ability.extra.x_mult + 0.5
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.RED
                }
            end
        end
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})


----------------------------------------------
-- SOCIAL & META (COMMON) J801-J820
----------------------------------------------

-- J801 Audience
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_audience',
    config = { extra = { mult_per = 4 } },
    rarity = 1,
    atlas = 'j_social_audience',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult_per, (G.GAME and G.GAME.current_round.hands_played or 0) * extra.mult_per } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local mult = (G.GAME.current_round.hands_played or 0) * card.ability.extra.mult_per
            if mult > 0 then
                return {
                    mult_mod = mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { mult } }
                }
            end
        end
    end
})

-- J802 Critic
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_critic',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_social_critic',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.chips < G.GAME.blind.chips * 0.2 then
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "Lixo!", colour = G.C.RED})
            end
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J803 Fan
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_fan',
    config = { extra = { mult = 5 } },
    rarity = 1,
    atlas = 'j_social_fan',
    pos = { x = 0, y = 0 },
    cost = 3,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.end_of_round and G.GAME.chips >= G.GAME.blind.chips and not context.repetition and not context.other_card then
            card_eval_status_text(card, 'extra', nil, nil, nil, {message = "Bom trabalho!", colour = G.C.GREEN})
        end
    end
})

-- J804 Hater
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_hater',
    config = { extra = { mult = 20 } },
    rarity = 1,
    atlas = 'j_social_hater',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('hater') < 0.2 then
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "Vai perder!", colour = G.C.RED})
            end
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J805 Streamer (Simulated. $1 per blind entered)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_streamer',
    config = { extra = { dollars = 2 } },
    rarity = 1,
    atlas = 'j_social_streamer',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            ease_dollars(card.ability.extra.dollars)
            return {
                message = localize('$')..card.ability.extra.dollars,
                colour = G.C.MONEY,
                card = card
            }
        end
    end
})

-- J806 Chat
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_chat',
    config = { extra = { chips = 10 } },
    rarity = 1,
    atlas = 'j_social_chat',
    pos = { x = 0, y = 0 },
    cost = 2,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local messages = {"KAPPA", "LUL", "POG", "RIGGED", "777"}
            if pseudorandom('chat') < 0.3 then
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = messages[math.floor(pseudorandom('chat_msg')*#messages)+1], colour = G.C.BLUE})
            end
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- J807 Moderator (Prevents playing if < 2 discards left? No, "prevents bad hands")
-- Let's say: High Card is disabled.
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_moderator',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_social_moderator',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J808 Troll
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_troll',
    config = { extra = { mult = 30, chance = 10 } },
    rarity = 1,
    atlas = 'j_social_troll',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('troll') < G.GAME.probabilities.normal / card.ability.extra.chance then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        for i = 1, #G.hand.cards do
                            G.hand.cards[i]:start_dissolve()
                        end
                        return true
                    end
                }))
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "Problem?!", colour = G.C.FILTER})
            end
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J809 Lurker
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_lurker',
    config = { extra = { rounds = 0, req = 10, x_mult = 3 } },
    rarity = 1,
    atlas = 'j_social_lurker',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.rounds, extra.req, extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
            card.ability.extra.rounds = card.ability.extra.rounds + 1
            if card.ability.extra.rounds == card.ability.extra.req then
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "Ativado!", colour = G.C.PURPLE})
            end
        end
        if context.joker_main and card.ability.extra.rounds >= card.ability.extra.req then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- J810 Subscriber
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_subscriber',
    config = { extra = { rounds = 0, dollars = 5, every = 4 } },
    rarity = 1,
    atlas = 'j_social_subscriber',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.rounds, extra.every, extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
            card.ability.extra.rounds = card.ability.extra.rounds + 1
            if card.ability.extra.rounds % card.ability.extra.every == 0 then
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- J811 Sponsor
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_sponsor',
    config = { extra = { dollars = 10 } },
    rarity = 1,
    atlas = 'j_social_sponsor',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            if G.GAME.round_resets.ante > (card.ability.extra.last_ante or 0) then
                card.ability.extra.last_ante = G.GAME.round_resets.ante
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- J812 Ad (Simpler: $5 end of round, blocks view of played hand score)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_ad',
    config = { extra = { dollars = 5 } },
    rarity = 1,
    atlas = 'j_social_ad',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
             ease_dollars(card.ability.extra.dollars)
             return {
                message = localize('$')..card.ability.extra.dollars,
                colour = G.C.MONEY
            }
        end
        if context.joker_main then
            card_eval_status_text(card, 'extra', nil, nil, nil, {message = "PROPAGANDA", colour = G.C.RED})
        end
    end
})

-- J813 Clickbait
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_clickbait',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_social_clickbait',
    pos = { x = 0, y = 0 },
    cost = 2,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J814 Viral
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_viral',
    config = { extra = { dollars = 10, threshold = 10000 } },
    rarity = 1,
    atlas = 'j_social_viral',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and not context.blueprint then
             if G.GAME.chips > card.ability.extra.threshold then
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = "VIRAL! "..localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
             end
        end
    end
})

-- J815 Meme
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_meme',
    config = { extra = { chips = 69 } },
    rarity = 1,
    atlas = 'j_social_meme',
    pos = { x = 0, y = 0 },
    cost = 3,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_6 = false
            local has_9 = false
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:get_id() == 6 then has_6 = true end
                if context.scoring_hand[i]:get_id() == 9 then has_9 = true end
            end
            if has_6 and has_9 then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = "Nice.",
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- J816 Emoji
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_emoji',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_social_emoji',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "😂",
                colour = G.C.MULT
            }
        end
    end
})

-- J817 Hashtag
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_hashtag',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_social_hashtag',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "#Balatro",
                colour = G.C.MULT
            }
        end
    end
})

-- J818 Trending
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_trending',
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    atlas = 'j_social_trending',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, G.GAME.odyssey_last_suit or 'N/A' } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local is_suit = false
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit(G.GAME.odyssey_last_suit or 'Spades') then
                    is_suit = true
                    break
                end
            end
            if is_suit then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            -- Logic to update odyssey_last_suit will be in vanilla_override
        end
    end
})

-- J819 Canceled
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_canceled',
    config = { extra = { face_card = 'King' } },
    rarity = 1,
    atlas = 'j_social_canceled',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.face_card } }

    end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            local faces = {'Jack', 'Queen', 'King'}
            card.ability.extra.face_card = faces[math.floor(pseudorandom('cancel')*#faces)+1]
        end
    end
})

-- J820 Influencer
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_influencer',
    config = { extra = { mult_per = 2 } },
    rarity = 1,
    atlas = 'j_social_influencer',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = (G.jokers and G.jokers.cards) and #G.jokers.cards or 1
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per, (count - 1) * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local mult = (#G.jokers.cards - 1) * card.ability.extra.mult_per
            if mult > 0 then
                return {
                    mult_mod = mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { mult } }
                }
            end
        end
    end
})


----------------------------------------------
-- SOCIAL & META (UNCOMMON) J821-J838
----------------------------------------------

-- J821 Fourth Wall
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_fourth_wall',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_social_fourth_wall',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.CONTROLLER.cursor_hovering == card then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- J822 Developer
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_developer',
    config = { extra = { chips = 50 } },
    rarity = 2,
    atlas = 'j_social_developer',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = "DEBUG: "..card.ability.extra.chips,
                colour = G.C.BLUE
            }
        end
    end
})

-- J823 Beta Tester
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_beta_tester',
    config = { extra = { chips = 40, mult = 10 } },
    rarity = 2,
    atlas = 'j_social_beta_tester',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('beta') < 0.5 then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = "BUG FOUND!",
                    colour = G.C.BLUE
                }
            else
                return {
                    mult_mod = card.ability.extra.mult,
                    message = "PATCHED!",
                    colour = G.C.RED
                }
            end
        end
    end
})

-- J824 Speedrunner
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_speedrunner',
    config = { extra = { mult = 30, limit = 120 } },
    rarity = 2,
    atlas = 'j_social_speedrunner',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.limit, G.GAME.round_resets.hands_played } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if (G.GAME.round_resets.hands_played or 0) < 3 then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = "FAST!",
                    colour = G.C.ORANGE
                }
            end
        end
    end
})

-- J825 Completionist
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_completionist',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_social_completionist',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.GAME and G.GAME.hands then
            for k, v in pairs(G.GAME.hands) do
                if v.played > 0 then count = count + 1 end
            end
        end
        return { vars = { card.ability.extra.x_mult, count } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local all_played = true
            for k, v in pairs(G.GAME.hands) do
                if v.played == 0 and v.visible then all_played = false break end
            end
            if all_played then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J826 Lore Master
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_lore_master',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_social_lore_master',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "LORE!",
                colour = G.C.MULT
            }
        end
    end
})

-- J827 Min-Maxer
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_min_maxer',
    config = { extra = { x_mult = 3, limit = 40 } },
    rarity = 2,
    atlas = 'j_social_min_maxer',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.limit } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and #G.deck.cards < card.ability.extra.limit then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- J828 Casual
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_casual',
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_social_casual',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if (G.GAME.round_resets.hands_played or 0) > 5 then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = "RELAX...",
                    colour = G.C.GREEN
                }
            end
        end
    end
})

-- J829 Tryhard
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_tryhard',
    config = { extra = { mult = 30 } },
    rarity = 2,
    atlas = 'j_social_tryhard',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            G.E_MANAGER:add_event(Event({
                func = function()
                    if G.ROOM and G.ROOM.jiggle then
                        G.ROOM.jiggle = G.ROOM.jiggle + 0.7
                    end
                    return true
                end
            }))
            return {
                mult_mod = card.ability.extra.mult,
                message = "TRYHARD!",
                colour = G.C.RED
            }
        end
    end
})

-- J830 Rage Quit
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_rage_quit',
    config = { extra = { active = true } },
    rarity = 2,
    atlas = 'j_social_rage_quit',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            G.GAME.odyssey_rage_quit_active = true
        end
    end
})

-- J831 Save Scummer
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_save_scummer',
    config = { extra = { uses = 1 } },
    rarity = 2,
    atlas = 'j_social_save_scummer',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.selling_self and not context.blueprint then
             G.GAME.chips = 0
             G.GAME.hands_played = 0
             G.GAME.discards_used = 0
             card_eval_status_text(card, 'extra', nil, nil, nil, {message = "SAVE LOADED", colour = G.C.BLUE})
        end
    end
})

-- J832 Modder
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_modder',
    config = { extra = { mult = 10 } },
    rarity = 2,
    atlas = 'j_social_modder',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J833 Pirate
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_pirate',
    config = { extra = { x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_social_pirate',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = "PIRACY!",
                colour = G.C.BLACK
            }
        end
    end
})

-- J834 DRM
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_drm',
    config = { extra = { mult = 40 } },
    rarity = 2,
    atlas = 'j_social_drm',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "DRM PROTECTED",
                colour = G.C.MULT
            }
        end
    end
})

-- J835 Microtransaction
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_microtransaction',
    config = { extra = { mult = 5, cost = 1 } },
    rarity = 2,
    atlas = 'j_social_microtransaction',
    pos = { x = 0, y = 0 },
    cost = 1,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.cost } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.dollars >= card.ability.extra.cost then
             ease_dollars(-card.ability.extra.cost)
             return {
                 mult_mod = card.ability.extra.mult,
                 message = "-$1 MULT!",
                 colour = G.C.MONEY
             }
        end
    end
})

-- J836 DLC
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_dlc',
    config = { extra = { chips = 20 } },
    rarity = 2,
    atlas = 'j_social_dlc',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = "DLC ACTIVE",
                colour = G.C.CHIPS
            }
        end
    end
})

-- J837 Patch Notes
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_patch_notes',
    config = { extra = { mult = 10 } },
    rarity = 2,
    atlas = 'j_social_patch_notes',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "v1.0."..G.GAME.round_resets.ante,
                colour = G.C.MULT
            }
        end
    end
})

-- J838 Easter Egg
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_easter_egg',
    config = { extra = { clicks = 0, req = 10, dollars = 10 } },
    rarity = 2,
    atlas = 'j_social_easter_egg',
    pos = { x = 0, y = 0 },
    cost = 1,
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card)
        local extra = (card and card.ability and card.ability.extra) or self.config.extra
        return { vars = { extra.dollars, extra.req } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
             card.ability.extra.clicks = card.ability.extra.clicks + 1
             if card.ability.extra.clicks >= card.ability.extra.req then
                ease_dollars(card.ability.extra.dollars)
                card.ability.extra.clicks = 0
                return {
                    message = "EASTER EGG! "..localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
             end
        end
    end
})


----------------------------------------------
-- SOCIAL & META (RARE) J839-J848
----------------------------------------------

-- J839 Game Master
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_game_master',
    config = { extra = { used = false } },
    rarity = 3,
    atlas = 'j_social_game_master',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint and G.GAME.blind.boss then
            G.GAME.blind:set_blind(nil, true, nil)
            card_eval_status_text(card, 'extra', nil, nil, nil, {message = "REGRAS ALTERADAS", colour = G.C.PURPLE})
        end
    end
})

-- J840 Admin
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_admin',
    config = {},
    rarity = 3,
    atlas = 'j_social_admin',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.selling_self and not context.blueprint then
            ease_dollars(20)
            local tag = Tag('tag_double')
            add_tag(tag)
            add_tag(Tag('tag_double'))
            -- Simplified: $20 and 2 Double Tags
        end
    end
})

-- J841 God Mode
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_god_mode',
    config = { extra = { rounds = 1 } },
    rarity = 3,
    atlas = 'j_social_god_mode',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            G.GAME.odyssey_god_mode = true
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            G.GAME.odyssey_god_mode = false
        end
    end
})

-- J842 Noclip
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_noclip',
    config = { extra = { x_mult = 2 } },
    rarity = 3,
    atlas = 'j_social_noclip',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = "NOCLIP",
                colour = G.C.PURPLE
            }
        end
        if context.setting_blind then
            G.GAME.odyssey_noclip = true
        end
    end
})

-- J843 Infinite Ammo
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_infinite_ammo',
    config = { extra = { discards = 5 } },
    rarity = 3,
    atlas = 'j_social_infinite_ammo',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.discards } }

    end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            ease_discard(card.ability.extra.discards)
        end
    end
})

-- J844 Aimbot
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_aimbot',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_social_aimbot',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             local count = 0
             local suit = nil
             for i=1, #context.scoring_hand do
                if not suit then suit = context.scoring_hand[i].base.suit end
                if context.scoring_hand[i]:is_suit(suit) then count = count + 1 end
             end
             if count >= 4 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = "HEADSHOT!",
                    colour = G.C.RED
                }
             end
        end
    end
})

-- J845 Wallhack
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_wallhack',
    config = { extra = { chips = 150 } },
    rarity = 3,
    atlas = 'j_social_wallhack',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local next_cards = "???, ???, ???"
        if G.deck and G.deck.cards then
            next_cards = ""
            for i=1, 3 do
                local c = G.deck.cards[#G.deck.cards - i + 1]
                if c then
                    next_cards = next_cards .. (i > 1 and ", " or "") .. localize(c.base.value, 'ranks') .. " " .. localize(c.base.suit, 'suits_plural')
                end
            end
        end
        return { vars = { card.ability.extra.chips, next_cards } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- J846 Lag Switch
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_lag_switch',
    config = { extra = { chips = 100, x_mult = 1.5 } },
    rarity = 3,
    atlas = 'j_social_lag_switch',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                x_mult = card.ability.extra.x_mult,
                message = "LAGGING...",
                colour = G.C.CHIPS
            }
        end
    end
})

-- J847 Ban Hammer
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_ban_hammer',
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    atlas = 'j_social_ban_hammer',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local my_pos = nil
            for i=1, #G.jokers.cards do
                if G.jokers.cards[i] == card then my_pos = i break end
            end
            if my_pos and G.jokers.cards[my_pos + 1] then
                local target = G.jokers.cards[my_pos + 1]
                if not target.ability.eternal then
                    target:start_dissolve()
                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = "BANNED!", colour = G.C.RED})
                    return {
                        x_mult = card.ability.extra.x_mult,
                        message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                    }
                end
            end
        end
    end
})

-- J848 Credits
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_credits',
    config = { extra = { x_mult = 1 } },
    rarity = 3,
    atlas = 'j_social_credits',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult + (G.GAME.round_resets.ante or 0) } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local bonus = G.GAME.round_resets.ante or 0
            return {
                x_mult = card.ability.extra.x_mult + bonus,
                message = "THANKS FOR PLAYING!",
                colour = G.C.GOLD
            }
        end
        if context.selling_self and G.GAME.round_resets.ante >= 8 then
            -- Win game logic (hard to trigger directly, maybe just massive money)
            ease_dollars(100)
        end
    end
})


----------------------------------------------
-- SOCIAL & META (LEGENDARY) J849-J850
----------------------------------------------

-- J849 The Player
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_the_player',
    config = { extra = { x_mult = 5, mode = 1 } },
    rarity = 4,
    atlas = 'j_social_the_player',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local modes = {"X5 Mult", "+500 Chips", "+100 Mult", "$5 per hand"}
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult, modes[( (card and card.ability and card.ability.extra) or self.config.extra ).mode] } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if card.ability.extra.mode == 1 then
                return { x_mult = 5, message = "X5" }
            elseif card.ability.extra.mode == 2 then
                return { chip_mod = 500, message = "+500" }
            elseif card.ability.extra.mode == 3 then
                return { mult_mod = 100, message = "+100" }
            elseif card.ability.extra.mode == 4 then
                 ease_dollars(5)
                 return { message = "$$$", colour = G.C.MONEY }
            end
        end
        if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
            card.ability.extra.mode = (card.ability.extra.mode % 4) + 1
            card_eval_status_text(card, 'extra', nil, nil, nil, {message = "SWITCH!", colour = G.C.PURPLE})
        end
    end
})

-- J850 LocalThunk
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_localthunk',
    config = { extra = { x_mult = 10 } },
    rarity = 4,
    atlas = 'j_social_localthunk',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if not context.blueprint then
                for k, v in ipairs(G.jokers.cards) do
                    if v ~= card and not v.edition then
                         v:set_edition({polychrome = true}, true)
                    end
                end
            end
            return {
                x_mult = card.ability.extra.x_mult,
                message = "THANKS!",
                colour = G.C.GOLD
            }
        end
    end
})


----------------------------------------------
-- POSITIONING & ADJACENCY (COMMON) J851-J870
----------------------------------------------

-- J851 Left Neighbor
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_left_neighbor',
    config = {},
    rarity = 1,
    atlas = 'j_pos_left_neighbor',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    calculate = function(self, card, context)
        local other_joker = get_joker_neighbor(card, 'left')
        if other_joker and other_joker ~= card and other_joker.config.center.blueprint_compat then
            context.blueprint = (context.blueprint and (context.blueprint + 1)) or 1
            context.blueprint_card = context.blueprint_card or card
            if context.blueprint > #G.jokers.cards + 1 then return end
            local other_joker_ret = other_joker:calculate_joker(context)
            if other_joker_ret then
                other_joker_ret.card = context.blueprint_card or card
                return other_joker_ret
            end
        end
    end
})

-- J852 Right Neighbor
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_right_neighbor',
    config = {},
    rarity = 1,
    atlas = 'j_pos_right_neighbor',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    calculate = function(self, card, context)
        local other_joker = get_joker_neighbor(card, 'right')
        if other_joker and other_joker ~= card and other_joker.config.center.blueprint_compat then
            context.blueprint = (context.blueprint and (context.blueprint + 1)) or 1
            context.blueprint_card = context.blueprint_card or card
            if context.blueprint > #G.jokers.cards + 1 then return end
            local other_joker_ret = other_joker:calculate_joker(context)
            if other_joker_ret then
                other_joker_ret.card = context.blueprint_card or card
                return other_joker_ret
            end
        end
    end
})

-- J853 Bodyguard
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_bodyguard',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_pos_bodyguard',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        -- Protection logic is in 03_vanilla_override
    end
})

-- J854 Leader
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_leader',
    config = { extra = { mult_per = 5 } },
    rarity = 1,
    atlas = 'j_pos_leader',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            local found = false
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then found = true
                elseif found then count = count + 1 end
            end
            return {
                mult_mod = count * card.ability.extra.mult_per,
                message = localize { type = 'variable', key = 'a_mult', vars = { count * card.ability.extra.mult_per } }
            }
        end
    end
})

-- J855 Follower
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_follower',
    config = { extra = { mult_per = 5 } },
    rarity = 1,
    atlas = 'j_pos_follower',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then break end
                count = count + 1
            end
            return {
                mult_mod = count * card.ability.extra.mult_per,
                message = localize { type = 'variable', key = 'a_mult', vars = { count * card.ability.extra.mult_per } }
            }
        end
    end
})

-- J856 Center Stage
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_center_stage',
    config = { extra = { mult = 20 } },
    rarity = 1,
    atlas = 'j_pos_center_stage',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            if idx == math.ceil(#G.jokers.cards / 2) then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- J857 Outsider
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_outsider',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_pos_outsider',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            if idx == 1 or idx == #G.jokers.cards then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- J858 Pair
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_pair',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_pos_pair',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            local is_pair = false
            if idx > 1 and G.jokers.cards[idx-1].config.center.key == card.config.center.key then is_pair = true end
            if idx < #G.jokers.cards and G.jokers.cards[idx+1].config.center.key == card.config.center.key then is_pair = true end
            if is_pair then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J859 Trio
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_trio',
    config = { extra = { x_mult = 3 } },
    rarity = 1,
    atlas = 'j_pos_trio',
    pos = { x = 0, y = 0 },
    cost = 8,
    calculate = function(self, card, context)
        if context.joker_main then
             local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            local count = 1
            -- Check left
            local l = idx - 1
            while l >= 1 and G.jokers.cards[l].config.center.key == card.config.center.key do
                count = count + 1
                l = l - 1
            end
            -- Check right
            local r = idx + 1
            while r <= #G.jokers.cards and G.jokers.cards[r].config.center.key == card.config.center.key do
                count = count + 1
                r = r + 1
            end
            if count >= 3 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J860 Chain
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_chain',
    config = { extra = { mult_per = 5 } },
    rarity = 1,
    atlas = 'j_pos_chain',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            local neighbors = 0
            if idx > 1 and G.jokers.cards[idx-1].config.center.key == card.config.center.key then neighbors = neighbors + 1 end
            if idx < #G.jokers.cards and G.jokers.cards[idx+1].config.center.key == card.config.center.key then neighbors = neighbors + 1 end
            return {
                mult_mod = neighbors * card.ability.extra.mult_per,
                message = localize { type = 'variable', key = 'a_mult', vars = { neighbors * card.ability.extra.mult_per } }
            }
        end
    end
})

-- J861 Magnet
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_magnet',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_pos_magnet',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i=1, #G.hand.cards do
                if G.hand.cards[i].config.center.key == 'm_odyssey_platinum' then count = count + 1 end
            end
            if count > 0 then
                return {
                    mult_mod = card.ability.extra.mult * count,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult * count } }
                }
            end
        end
    end
})

-- J862 Repulsor
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_repulsor',
    config = { extra = { chips = 100 } },
    rarity = 1,
    atlas = 'j_pos_repulsor',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local my_pos = nil
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then my_pos = i break end
            end
            if my_pos == 1 or my_pos == #G.jokers.cards then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    end
})

-- J863 Mirror
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_mirror',
    config = {},
    rarity = 1,
    atlas = 'j_pos_mirror',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    calculate = function(self, card, context)
        local my_pos = nil
        for i=1, #G.jokers.cards do if G.jokers.cards[i] == card then my_pos = i break end end
        if my_pos then
            local target_pos = #G.jokers.cards - my_pos + 1
            if target_pos ~= my_pos and G.jokers.cards[target_pos] then
                local other_joker = G.jokers.cards[target_pos]
                if other_joker.config.center.blueprint_compat then
                    context.blueprint = (context.blueprint and (context.blueprint + 1)) or 1
                    context.blueprint_card = context.blueprint_card or card
                    if context.blueprint > #G.jokers.cards + 1 then return end
                    local other_joker_ret = other_joker:calculate_joker(context)
                    if other_joker_ret then
                        other_joker_ret.card = context.blueprint_card or card
                        return other_joker_ret
                    end
                end
            end
        end
    end
})

-- J864 Prism
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_prism',
    config = {},
    rarity = 1,
    atlas = 'j_pos_prism',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = false,
    -- This one should probably be handled in vanilla_override or a global context
    -- Let's make it simpler for now: Copies left joker for every joker slot? No.
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J865 Lens
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_lens',
    config = { extra = { mult = 0 } },
    rarity = 1,
    atlas = 'j_pos_lens',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J866 Amplifier
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_amplifier',
    config = { extra = { factor = 1.5 } },
    rarity = 1,
    atlas = 'j_pos_amplifier',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.factor } }

    end,
    calculate = function(self, card, context)
        local other_joker = get_joker_neighbor(card, 'right')
        if other_joker and other_joker ~= card and other_joker.config.center.blueprint_compat then
            context.blueprint = (context.blueprint and (context.blueprint + 1)) or 1
            context.blueprint_card = context.blueprint_card or card
            if context.blueprint > #G.jokers.cards + 1 then return end
            local other_joker_ret = other_joker:calculate_joker(context)
            if other_joker_ret then
                if other_joker_ret.mult_mod then other_joker_ret.mult_mod = other_joker_ret.mult_mod * (card.ability.extra.factor - 1) end
                if other_joker_ret.chip_mod then other_joker_ret.chip_mod = other_joker_ret.chip_mod * (card.ability.extra.factor - 1) end
                if other_joker_ret.x_mult then 
                    other_joker_ret.x_mult = card.ability.extra.factor - (card.ability.extra.factor - 1) / other_joker_ret.x_mult
                end
                other_joker_ret.card = card
                return other_joker_ret
            end
        end
    end
})

-- J867 Silencer
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_silencer',
    config = { extra = { x_mult = 3 } },
    rarity = 1,
    atlas = 'j_pos_silencer',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- J868 Battery
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_battery',
    config = {},
    rarity = 1,
    atlas = 'j_pos_battery',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    calculate = function(self, card, context)
        local other_joker = get_joker_neighbor(card, 'right')
        if other_joker and other_joker ~= card and other_joker.config.center.blueprint_compat then
            context.repetition = (context.repetition or 0) + 1
            if context.repetition > 1 then return end
            local other_joker_ret = other_joker:calculate_joker(context)
            if other_joker_ret then
                 other_joker_ret.message = "RECHARGE!"
                 return other_joker_ret
            end
        end
    end
})

-- J869 Ground Wire
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_ground_wire',
    config = { extra = { chips = 100 } },
    rarity = 1,
    atlas = 'j_pos_ground_wire',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- J870 Connector
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_connector',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_pos_connector',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "BRIDGE",
                colour = G.C.MULT
            }
        end
    end
})


----------------------------------------------
-- POSITIONING & ADJACENCY (UNCOMMON) J871-J888
----------------------------------------------

-- J871 Battle Formation
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_battle_formation',
    config = { extra = { mult = 15, chips = 50 } },
    rarity = 2,
    atlas = 'j_pos_battle_formation',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            if idx == 1 or idx == #G.jokers.cards then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            else
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    end
})

-- J872 Frontline
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_frontline',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_pos_frontline',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            if idx <= 2 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J873 Backline
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_backline',
    config = { extra = { chips = 100 } },
    rarity = 2,
    atlas = 'j_pos_backline',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.joker_main then
             local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            if idx >= #G.jokers.cards - 1 then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    end
})

-- J874 Flank
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_flank',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_pos_flank',
    pos = { x = 0, y = 0 },
    cost = 8,
    calculate = function(self, card, context)
        if context.joker_main then
            if #G.jokers.cards >= 2 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J875 Siege
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_siege',
    config = { extra = { mult = 50 } },
    rarity = 2,
    atlas = 'j_pos_siege',
    pos = { x = 0, y = 0 },
    cost = 8,
    calculate = function(self, card, context)
        if context.joker_main then
            if #G.jokers.cards >= G.jokers.config.card_limit then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- J876 Isolation
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_isolation',
    config = { extra = { x_mult = 2.5 } },
    rarity = 2,
    atlas = 'j_pos_isolation',
    pos = { x = 0, y = 0 },
    cost = 9,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            local isolated = true
            -- Simplified check: usually jokers are always adjacent in the UI
            -- but maybe we can check if they are "separated" by something
            if isolated then
                 return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J877 Clumping
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_clumping',
    config = { extra = { mult = 30 } },
    rarity = 2,
    atlas = 'j_pos_clumping',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.joker_main then
             if #G.jokers.cards >= 3 then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- J878 Musical Chairs
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_musical_chairs',
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_pos_musical_chairs',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.end_of_round and not context.blueprint and not context.other_card then
            -- Randomize positions
            G.E_MANAGER:add_event(Event({
                func = function()
                    G.jokers:shuffle()
                    return true
                end
            }))
        end
        if context.joker_main then
             return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J879 Carousel
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_carousel',
    config = { extra = { mult = 10 } },
    rarity = 2,
    atlas = 'j_pos_carousel',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.first_hand_column and not context.blueprint then
             -- Shift right
             G.E_MANAGER:add_event(Event({
                func = function()
                    local last = G.jokers.cards[#G.jokers.cards]
                    table.remove(G.jokers.cards, #G.jokers.cards)
                    table.insert(G.jokers.cards, 1, last)
                    return true
                end
             }))
        end
    end
})

-- J880 Rook
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_rook',
    config = { extra = { mult = 25 } },
    rarity = 2,
    atlas = 'j_pos_rook',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local king_present = false
            if G.jokers then
                for _, v in ipairs(G.jokers.cards) do
                    if v.config.center.key == 'j_odyssey_j_pos_king' then
                        king_present = true
                        break
                    end
                end
            end

            if king_present then
                return {
                    x_mult = 2,
                    message = "PROTECTED!",
                    colour = G.C.BLUE
                }
            else
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- J881 Bishop
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_bishop',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_pos_bishop',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local my_pos = nil
            for i=1, #G.jokers.cards do if G.jokers.cards[i] == card then my_pos = i break end end
            if my_pos and my_pos % 2 == 1 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J882 Knight
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_knight',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_pos_knight',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J883 King
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_king',
    config = { extra = { x_mult = 2.5 } },
    rarity = 2,
    atlas = 'j_pos_king',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             local my_pos = nil
             for i=1, #G.jokers.cards do if G.jokers.cards[i] == card then my_pos = i break end end
             local neighbors = 0
             if my_pos > 1 then neighbors = neighbors + 1 end
             if my_pos < #G.jokers.cards then neighbors = neighbors + 1 end
             if neighbors == 2 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
             end
        end
    end
})

-- J884 Queen
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_queen',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_pos_queen',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- J885 Pawn
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_pawn',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_pos_pawn',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            if idx == #G.jokers.cards then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = "QUEENED!",
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

-- J886 Castling
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_castling',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_pos_castling',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J887 Check
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_check',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_pos_check',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.blind.boss then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = "CHECK!",
                    colour = G.C.RED
                }
            end
        end
    end
})

-- J888 Checkmate
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_checkmate',
    config = { extra = { x_mult = 10 } },
    rarity = 2,
    atlas = 'j_pos_checkmate',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.chips >= G.GAME.blind.chips * 0.9 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = "CHECKMATE!",
                colour = G.C.GOLD
            }
        end
    end
})


----------------------------------------------
-- POSITIONING & ADJACENCY (RARE) J889-J898
----------------------------------------------

-- J889 Pentagram
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_pentagram',
    config = { extra = { x_mult = 6.66 } },
    rarity = 3,
    atlas = 'j_pos_pentagram',
    pos = { x = 0, y = 0 },
    cost = 13,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and #G.jokers.cards == 5 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = "THE BEAST",
                colour = G.C.RED
            }
        end
    end
})

-- J890 Alignment
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_alignment',
    config = { extra = { x_mult = 4 } },
    rarity = 3,
    atlas = 'j_pos_alignment',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local same = true
            local first_rarity = G.jokers.cards[1].config.rarity
            for i = 2, #G.jokers.cards do
                if G.jokers.cards[i].config.rarity ~= first_rarity then same = false; break end
            end
            if same and #G.jokers.cards > 1 then
                 return {
                    x_mult = card.ability.extra.x_mult,
                    message = "ALIGNED",
                    colour = G.C.BLUE
                }
            end
        end
    end
})

-- J891 Disorder
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_disorder',
    config = { extra = { x_mult = 4 } },
    rarity = 3,
    atlas = 'j_pos_disorder',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local seen = {}
            local unique = true
            for i = 1, #G.jokers.cards do
                local r = G.jokers.cards[i].config.rarity
                if seen[r] then unique = false; break end
                seen[r] = true
            end
            if unique and #G.jokers.cards > 1 then
                 return {
                    x_mult = card.ability.extra.x_mult,
                    message = "DISORDER",
                    colour = G.C.ORANGE
                }
            end
        end
    end
})

-- J892 Symmetry
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_symmetry',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_pos_symmetry',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local is_symmetric = true
            for i = 1, math.floor(#G.jokers.cards / 2) do
                if G.jokers.cards[i].config.rarity ~= G.jokers.cards[#G.jokers.cards - i + 1].config.rarity then
                    is_symmetric = false
                    break
                end
            end
            if is_symmetric and #G.jokers.cards > 1 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = "SYMMETRY",
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

-- J893 Positional Chaos
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_positional_chaos',
    config = { extra = { mult = 40 } },
    rarity = 3,
    atlas = 'j_pos_positional_chaos',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "CHAOS!",
                colour = G.C.FILTER
            }
        end
    end
})

-- J894 Black Hole
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_black_hole',
    config = { extra = { x_mult = 4 } },
    rarity = 3,
    atlas = 'j_pos_black_hole',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local my_pos = nil
            for i=1, #G.jokers.cards do if G.jokers.cards[i] == card then my_pos = i break end end
            if my_pos == math.ceil(#G.jokers.cards / 2) and #G.jokers.cards % 2 ~= 0 then -- True center
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = "SINGULARITY!",
                    colour = G.C.BLACK
                }
            end
        end
    end
})

-- J895 Supernova
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_supernova',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_pos_supernova',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local my_pos = nil
            for i=1, #G.jokers.cards do if G.jokers.cards[i] == card then my_pos = i break end end
            if my_pos == 1 or my_pos == #G.jokers.cards then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = "EXPLOSION!",
                    colour = G.C.ORANGE
                }
            end
        end
    end
})

-- J896 Galaxy
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_galaxy',
    config = { extra = { x_mult_mod = 1.2 } },
    rarity = 3,
    atlas = 'j_pos_galaxy',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = (G.jokers and G.jokers.cards) and #G.jokers.cards or 0
        local total_xmult = ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_mod ^ count
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_mod, total_xmult } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local total_xmult = card.ability.extra.x_mult_mod ^ #G.jokers.cards
            return {
                x_mult = total_xmult,
                message = "ORBITAL",
                colour = G.C.BLUE
            }
        end
    end
})

-- J897 Universe
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_universe',
    config = { extra = { slots = 4 } },
    rarity = 3,
    atlas = 'j_pos_universe',
    pos = { x = 0, y = 0 },
    cost = 12,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.slots } }

    end,
    add_to_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.slots
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.slots
    end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J898 Multiverse
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_multiverse',
    config = { extra = { x_mult = 2 } },
    rarity = 3,
    atlas = 'j_pos_multiverse',
    pos = { x = 0, y = 0 },
    cost = 12,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.GAME and G.GAME.probabilities then
            for k, v in pairs(G.GAME.probabilities) do count = count + 1 end
        end
        return { vars = { 1 + (count * 0.1) } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
             local count = 0
             for k, v in pairs(G.GAME.probabilities) do count = count + 1 end
             return {
                x_mult = 1 + (count * 0.1),
                message = "MULTIVERSE",
                colour = G.C.PURPLE
             }
        end
    end
})


----------------------------------------------
-- POSITIONING & ADJACENCY (LEGENDARY) J899-J900
----------------------------------------------

-- J899 The Architect
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_the_architect',
    config = { extra = { slots = 5 } },
    rarity = 4,
    atlas = 'j_pos_the_architect',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.slots } }

    end,
    add_to_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.slots
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.slots
    end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J900 The Conductor
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_the_conductor',
    config = { extra = { x_mult = 5, step = 0.2 } },
    rarity = 4,
    atlas = 'j_pos_the_conductor',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.step } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local my_pos = nil
            for i=1, #G.jokers.cards do if G.jokers.cards[i] == card then my_pos = i break end end
            local bonus = (my_pos - 1) * card.ability.extra.step
            return {
                x_mult = card.ability.extra.x_mult + bonus,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult + bonus } },
                colour = G.C.RED
            }
        end
        -- Also buff others when they calculate?
        -- Actually, it's easier to just have the Conductor provide the cumulative bonus itself based on its own position.
        -- But the description says "All Jokers trigger in sequence with cumulative multiplier".
        -- Let's make it a global hook in other_joker context.
        if context.other_joker and context.other_joker ~= card then
             local other_pos = nil
             for i=1, #G.jokers.cards do if G.jokers.cards[i] == context.other_joker then other_pos = i break end end
             if other_pos then
                return {
                    x_mult = 1 + (other_pos * card.ability.extra.step),
                    message = "VIVO!",
                    colour = G.C.GOLD
                }
             end
        end
    end
})


-- J901-920: Conditions & Logic (Common)

-- Hair Trigger (J901)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_hair_trigger',
    config = { extra = { mult = 2 } },
    rarity = 1,
    atlas = 'j_cond_hair_trigger',
    pos = { x = 0, y = 0 },
    cost = 2,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.cardarea == G.play and not context.repetition then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                card = card
            }
        end
    end
})

-- Heavy Trigger (J902)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_heavy_trigger',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_cond_heavy_trigger',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and context.full_hand and #context.full_hand == 5 then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Conditional (J903)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_conditional',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_cond_conditional',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_left == 0 then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- If (J904)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_if',
    config = { extra = { mult = 20 } },
    rarity = 1,
    atlas = 'j_cond_if',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.dollars == 0 then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Else (J905)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_else',
    config = { extra = { mult = 5 } },
    rarity = 1,
    atlas = 'j_cond_else',
    pos = { x = 0, y = 0 },
    cost = 3,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.dollars ~= 0 then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- While (J906)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_while',
    config = { extra = { chips = 10 } },
    rarity = 1,
    atlas = 'j_cond_while',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_left > 0 then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- For Loop (J907)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_for_loop',
    config = { extra = { mult = 2 } },
    rarity = 1,
    atlas = 'j_cond_for_loop',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = #G.hand.cards
            return {
                mult_mod = card.ability.extra.mult * count,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult * count } }
            }
        end
    end
})

-- Switch (J908)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_switch',
    config = { extra = { mult = 10, chips = 50, money = 2 } },
    rarity = 1,
    atlas = 'j_cond_switch',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Hearts') then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            elseif context.other_card:is_suit('Spades') then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            elseif context.other_card:is_suit('Diamonds') then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$')..card.ability.extra.money,
                    colour = G.C.MONEY,
                    card = card
                }
            elseif context.other_card:is_suit('Clubs') then
                return {
                    extra = { focus = card, message = localize('k_again_ex'), func = function() return true end },
                    card = card
                }
            end
        end
    end
})

-- Break (J909)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_break',
    rarity = 1,
    atlas = 'j_cond_break',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.chips + (G.GAME.current_round.current_hand and G.GAME.current_round.current_hand.chips or 0) >= G.GAME.blind.chips then
            -- Note: We can't easily "stop" scoring in many ways without complex hooks, 
            -- but we can signal it. For now, it's a flavor/utility card that might need custom hooks.
            return {
                message = "BREAK!",
                colour = G.C.FILTER
            }
        end
    end
})

-- Continue (J910)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_continue',
    rarity = 1,
    atlas = 'j_cond_continue',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            -- This is tricky. Repetitions normally happen card by card.
            -- This joker would need to track "next card" which is hard in calculate.
            return {
                message = "CONTINUE!",
                repetitions = 1,
                card = card
            }
        end
    end
})

-- Return (J911)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_return',
    rarity = 1,
    atlas = 'j_cond_return',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.1,
                func = function()
                    draw_card(G.play, G.hand, 100, 'up', true, context.other_card)
                    return true
                end
            }))
            return {
                message = "RETURN!",
                colour = G.C.BLUE,
                card = card
            }
        end
    end
})

-- Print (J912)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_print',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_cond_print',
    pos = { x = 0, y = 0 },
    cost = 2,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "Hello World!",
                colour = G.C.WHITE
            }
        end
    end
})

-- Input (J913)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_input',
    rarity = 1,
    atlas = 'j_cond_input',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            -- In Balatro, we don't have "click to activate" easily in calculate.
            -- Using a probability or simple mult for now.
            return {
                mult_mod = 10,
                message = "INPUT RECEIVED"
            }
        end
    end
})

-- Output (J914)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_output',
    config = { extra = { money = 5 } },
    rarity = 1,
    atlas = 'j_cond_output',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end,
    calc_dollar_bonus = function(self, card)
        return card.ability.extra.money
    end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- Variable (J915)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_variable',
    config = { extra = { mult = 0 } },
    rarity = 1,
    atlas = 'j_cond_variable',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.end_of_round and not context.other_card and not context.repetition and not context.blueprint then
            card.ability.extra.mult = card.ability.extra.mult + 1
            return {
                message = "++Var",
                colour = G.C.MULT
            }
        end
    end
})

-- Constant (J916)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_constant',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_cond_constant',
    pos = { x = 0, y = 0 },
    cost = 3,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Function (J917)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_function',
    rarity = 1,
    atlas = 'j_cond_function',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.jokers then
            local my_pos = nil
            for i=1, #G.jokers.cards do
                if G.jokers.cards[i] == card then my_pos = i; break end
            end
            if my_pos and my_pos > 1 and G.jokers.cards[my_pos-1] == context.other_joker then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- Class (J918)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_class',
    config = { extra = { mult = 4 } },
    rarity = 1,
    atlas = 'j_cond_class',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.other_joker and context.other_joker.config.rarity == 1 and context.other_joker ~= card then
            if context.joker_main then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- Object (J919)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_object',
    rarity = 1,
    atlas = 'j_cond_object',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.selling_self then
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.1,
                func = function()
                    local _card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'obj')
                    _card:add_to_deck()
                    G.consumeables:emplace(_card)
                    return true
                end
            }))
        end
    end
})

-- Array (J920)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_array',
    config = { extra = { mult = 5 } },
    rarity = 1,
    atlas = 'j_cond_array',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = #G.jokers.cards
            return {
                mult_mod = card.ability.extra.mult * count,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult * count } }
            }
        end
    end
})


-- J921-938: Conditions & Logic (Uncommon)

-- Boolean (J921)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_boolean',
    config = { extra = { x_mult_true = 2, x_mult_false = 0.5 } },
    rarity = 2,
    atlas = 'j_cond_boolean',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult_true, (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult_false } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local cond = (pseudorandom('boolean') > 0.5)
            local mod = cond and card.ability.extra.x_mult_true or card.ability.extra.x_mult_false
            return {
                x_mult = mod,
                message = cond and "TRUE!" or "FALSE!",
                colour = cond and G.C.GREEN or G.C.RED
            }
        end
    end
})

-- Integer (J922)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_integer',
    rarity = 2,
    atlas = 'j_cond_integer',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            -- This would need to run after all other mults.
            -- In Balatro's calculate loop, we don't have a clean "post-process" hook for just one joker.
            -- But we can simulate it by being high index or just floor/ceil.
            return {
                message = "INT",
                colour = G.C.FILTER
            }
        end
    end
})

-- Float (J923)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_float',
    rarity = 2,
    atlas = 'j_cond_float',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    calculate = function(self, card, context)
        -- Balatro already allows floats, so this is flavor/enabler.
        if context.joker_main then
            return {
                mult_mod = 0.5,
                message = "+0.5"
            }
        end
    end
})

-- String (J924)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_string',
    config = { extra = { mult = 10 } },
    rarity = 2,
    atlas = 'j_cond_string',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local msgs = {"YOU CAN DO IT", "STAY FOCUSED", "BIG BLIND AHEAD", "LUA IS BEST"}
            local msg = msgs[math.random(#msgs)]
            return {
                mult_mod = card.ability.extra.mult,
                message = msg,
                colour = G.C.MULT
            }
        end
    end
})

-- Char (J925)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_char',
    rarity = 2,
    atlas = 'j_cond_char',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name then
            local char = string.sub(context.scoring_name, 1, 1)
            -- Different bonus per first char
            local bonus = 5
            if char == 'S' or char == 'F' then bonus = 15 end -- Straight, Flush, Full House
            return {
                mult_mod = bonus,
                message = char .. "!"
            }
        end
    end
})

-- Null (J926)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_null',
    rarity = 2,
    atlas = 'j_cond_null',
    pos = { x = 0, y = 0 },
    cost = 1,
    blueprint_compat = true,
    calculate = function(self, card, context)
        -- Literally does nothing.
    end
})

-- Undefined (J927)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_undefined',
    rarity = 2,
    atlas = 'j_cond_undefined',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local r = math.random()
            if r < 0.25 then return { mult = 10 }
            elseif r < 0.5 then return { chips = 50 }
            elseif r < 0.75 then return { x_mult = 1.5 }
            else return { message = "UNDEFINED", colour = G.C.FILTER } end
        end
    end
})

-- NaN (J928)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_nan',
    config = { extra = { mult = 11 } },
    rarity = 2,
    atlas = 'j_cond_nan',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "N/A/N",
                colour = G.C.BLACK
            }
        end
    end
})

-- Infinity (J929)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_infinity',
    rarity = 2,
    atlas = 'j_cond_infinity',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = 5,
                message = "INF",
                colour = G.C.MULT
            }
        end
    end
})

-- Exception (J930)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_exception',
    config = { extra = { money = 10 } },
    rarity = 2,
    atlas = 'j_cond_exception',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end,
    calculate = function(self, card, context)
        -- Triggered if something "fails" (like a 1 in X chance)
        if context.joker_main and G.GAME.probabilities.normal > 100 then -- fake cond
            ease_dollars(card.ability.extra.money)
            return {
                message = "EXC!",
                colour = G.C.MONEY
            }
        end
    end
})

-- Try Catch (J931)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_try_catch',
    config = { extra = { money = 5 } },
    rarity = 2,
    atlas = 'j_cond_try_catch',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            -- Tries to activate a random joker
            local other = G.jokers.cards[math.random(#G.jokers.cards)]
            if other and other ~= card then
                return other:calculate_joker(context)
            else
                ease_dollars(card.ability.extra.money)
                return {
                    message = "CATCH!",
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- Async (J932)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_async',
    rarity = 2,
    atlas = 'j_cond_async',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.after then
            return {
                mult = 20,
                message = "ASYNC"
            }
        end
    end
})

-- Await (J933)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_await',
    rarity = 2,
    atlas = 'j_cond_await',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.blind.boss then
            return {
                x_mult = 3,
                message = "AWAIT DONE"
            }
        end
    end
})

-- Promise (J934)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_promise',
    config = { extra = { rounds = 3, x_mult = 3 } },
    rarity = 2,
    atlas = 'j_cond_promise',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).rounds } } end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.repetition and not context.blueprint then
            card.ability.extra.rounds = card.ability.extra.rounds - 1
            if card.ability.extra.rounds <= 0 then
                card:juice_up()
                return {
                    message = "FULFILLED!",
                    colour = G.C.GOLD
                }
            end
        end
        if context.joker_main and card.ability.extra.rounds <= 0 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = "PROMISED"
            }
        end
    end
})

-- Callback (J935)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_callback',
    rarity = 2,
    atlas = 'j_cond_callback',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local target = G.jokers.cards[math.random(#G.jokers.cards)]
            if target and target ~= card then
                return target:calculate_joker(context)
            end
        end
    end
})

-- Recursion (J936)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_recursion',
    rarity = 2,
    atlas = 'j_cond_recursion',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.jokers and context.other_joker == card then
            -- Note: recursive repetition needs a limit to avoid lock
            if (context.recursion_count or 0) < 2 then
                context.recursion_count = (context.recursion_count or 0) + 1
                return {
                    message = "REC",
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- Stack (J937)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_stack',
    config = { extra = { mult = 0 } },
    rarity = 2,
    atlas = 'j_cond_stack',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.selling_card and not context.blueprint then
            card.ability.extra.mult = card.ability.extra.mult + 2
            return {
                message = "STACK+",
                colour = G.C.MULT
            }
        end
    end
})

-- Heap (J938)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_heap',
    config = { extra = { money = 1 } },
    rarity = 2,
    atlas = 'j_cond_heap',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end,
    calc_dollar_bonus = function(self, card)
        return (G.jokers and G.jokers.cards and #G.jokers.cards or 0) * card.ability.extra.money
    end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- J939-948: Conditions & Logic (Rare)

-- Algorithm (J939)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_algorithm',
    config = { extra = { mult = 15 } },
    rarity = 3,
    atlas = 'j_cond_algorithm',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.first_hand_drawn then
            G.hand:sort()
            return {
                message = "SORTED",
                colour = G.C.BLUE
            }
        end
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- AI (J940)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_ai',
    config = { extra = { x_mult = 1 } },
    rarity = 3,
    atlas = 'j_cond_ai',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
        if context.before and not context.blueprint then
            card.ability.extra.x_mult = card.ability.extra.x_mult + 0.1
            return {
                message = "LEARNING...",
                colour = G.C.FILTER
            }
        end
    end
})

-- Neural Net (J941)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_neural_net',
    rarity = 3,
    atlas = 'j_cond_neural_net',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local target = G.jokers.cards[math.random(#G.jokers.cards)]
            if target and target ~= card then
                return target:calculate_joker(context)
            end
        end
    end
})

-- Deep Learning (J942)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_deep_learning',
    config = { extra = { x_mult = 1, gain = 0.5 } },
    rarity = 3,
    atlas = 'j_cond_deep_learning',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).gain } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
        if context.end_of_round and not context.other_card and G.GAME.blind.boss and not context.repetition and not context.blueprint then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.gain
            return {
                message = "DEEPENED!",
                colour = G.C.MULT
            }
        end
    end
})

-- Machine Learning (J943)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_machine_learning',
    config = { extra = { last_hand = nil, count = 0 } },
    rarity = 3,
    atlas = 'j_cond_machine_learning',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.before then
            if context.scoring_name == card.ability.extra.last_hand then
                card.ability.extra.played = card.ability.extra.played + 1
            else
                card.ability.extra.last_hand = context.scoring_name
                card.ability.extra.played = 1
            end
            
            if card.ability.extra.played >= 3 then
                card.ability.extra.played = 0
                update_hand_stats(context.scoring_name, 1)
                return {
                    message = "LEVEL UP!",
                    colour = G.C.ATTENTION
                }
            end
        end
    end
})

-- Big Data (J944)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_big_data',
    rarity = 3,
    atlas = 'j_cond_big_data',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { (G.playing_cards and #G.playing_cards or 52) } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = #G.playing_cards
            return {
                mult_mod = count,
                message = localize{ type = 'variable', key = 'a_mult', vars = { count } }
            }
        end
    end
})

-- Blockchain (J945)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_blockchain',
    config = { extra = { gain = 2 } },
    rarity = 3,
    atlas = 'j_cond_blockchain',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).gain } } end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.repetition then
            card.ability.sell_cost = card.ability.sell_cost + card.ability.extra.gain
            return {
                message = "MINED!",
                colour = G.C.GOLD
            }
        end
    end
})

-- NFT (J946)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_nft',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_cond_nft',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    add_to_deck = function(self, card)
        card.ability.eternal = true
        card.ability.sell_cost = 0
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Metaverse (J947)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_metaverse',
    rarity = 3,
    atlas = 'j_cond_metaverse',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.first_hand_drawn then
            local target = G.jokers.cards[math.random(#G.jokers.cards)]
            if target and target ~= card then
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        local _card = copy_card(target)
                        _card:add_to_deck()
                        G.jokers:emplace(_card)
                        _card.ability.eternal = true -- temporary hack
                        -- We need a way to remove it later, maybe tag it
                        _card.meta_temporary = true
                        return true
                    end
                }))
                return {
                    message = "VIRTUAL CLONE",
                    colour = G.C.PURPLE
                }
            end
        end
        if context.end_of_round and not context.other_card then
             for i = #G.jokers.cards, 1, -1 do
                 if G.jokers.cards[i].meta_temporary then
                     G.jokers.cards[i]:remove()
                 end
             end
        end
    end
})

-- Web 3.0 (J948)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_web3',
    rarity = 3,
    atlas = 'j_cond_web3',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.jokers.config.card_limit = G.jokers.config.card_limit + 1
        G.consumeables.config.card_limit = G.consumeables.config.card_limit - 1
    end,
    remove_from_deck = function(self, card)
        G.jokers.config.card_limit = G.jokers.config.card_limit - 1
        G.consumeables.config.card_limit = G.consumeables.config.card_limit + 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- J949-950: Conditions & Logic (Legendary)

-- Turing Complete (J949)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_turing_complete',
    rarity = 4,
    atlas = 'j_cond_turing_complete',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            -- True simulation: Copy a random Joker from the entire pool
            if not card.ability.simulated_key or context.before then
                local keys = {}
                for k, v in pairs(G.P_CENTERS) do
                    if v.set == 'Joker' and k ~= card.config.center.key then
                        table.insert(keys, k)
                    end
                end
                card.ability.simulated_key = keys[math.random(#keys)]
            end
            
            local target = G.P_CENTERS[card.ability.simulated_key]
            if target and target.calculate then
                local res = target:calculate(card, context)
                if res then 
                    res.message = "SIMULATING: " .. target.name
                    return res
                end
            end
            
            return {
                x_mult = 5,
                message = "SIMULATED",
                colour = G.C.GOLD
            }
        end
    end
})

-- Tech Singularity (J950)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_tech_singularity',
    rarity = 4,
    atlas = 'j_cond_tech_singularity',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.first_hand_drawn then
            -- Automatic victory simulation
            -- In real game, this might be too much, but for 1000 jokers, let's make it epic
            G.GAME.chips = G.GAME.blind.chips + 1
            if G.GAME.current_round.current_hand then
                G.GAME.current_round.current_hand.chips = 0
            end
            
            return {
                message = "SINGULARITY!",
                colour = G.C.BLACK
            }
        end
    end
})


-- J951-970: Final & Specials (Common)

-- The End (J951)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_the_end',
    config = { extra = { mult = 20, x_mult = 4 } },
    rarity = 1,
    atlas = 'j_final_the_end',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.current_round.hands_left == 0 and G.GAME.round_resets.ante >= 8 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            else
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- The Beginning (J952)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_the_beginning',
    config = { extra = { mult = 20, chips = 100 } },
    rarity = 1,
    atlas = 'j_final_the_beginning',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).chips } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played < 3 then
            return {
                mult_mod = card.ability.extra.mult,
                chip_mod = card.ability.extra.chips,
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- The Middle (J953)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_the_middle',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_final_the_middle',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_left == 3 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Prologue (J954)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_prologue',
    config = { extra = { mult = 10, last_ante = -1 } },
    rarity = 1,
    atlas = 'j_final_prologue',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint and card.ability.extra.last_ante < G.GAME.round_resets.ante then
            card.ability.extra.last_ante = G.GAME.round_resets.ante
            local tag = Tag(get_next_tag_key('joker_prologue'))
            add_tag(tag)
            return {
                message = "TAG!",
                colour = G.C.FILTER
            }
        end
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Epilogue (J955)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_epilogue',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_final_epilogue',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.blueprint and not context.repetition and not context.other_card then
            local overkill = G.GAME.chips - G.GAME.blind.chips
            if overkill > 0 then
                local dollars = math.min(10, math.floor(overkill / 100))
                if dollars > 0 then
                    ease_dollars(dollars)
                    return {
                        message = localize{type='variable', key='a_money', vars={dollars}},
                        colour = G.C.MONEY
                    }
                end
            end
        end
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Chapter 1 (J956)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_chapter1',
    config = { extra = { mult_per_hand = 5 } },
    rarity = 1,
    atlas = 'j_final_chapter1',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) 
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_hand, (G.GAME.current_round.hands_played or 0) * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_hand } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local mult = (G.GAME.current_round.hands_played or 0) * card.ability.extra.mult_per_hand
            if mult > 0 then
                return {
                    mult_mod = mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } }
                }
            end
        end
    end
})

-- Chapter 2 (J957)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_chapter2',
    config = { extra = { mult_per_discard = 5 } },
    rarity = 1,
    atlas = 'j_final_chapter2',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) 
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_discard, (G.GAME.current_round.discards_used or 0) * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_discard } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local mult = (G.GAME.current_round.discards_used or 0) * card.ability.extra.mult_per_discard
            if mult > 0 then
                return {
                    mult_mod = mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } }
                }
            end
        end
    end
})

-- Chapter 3 (J958)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_chapter3',
    config = { extra = { mult_per_card = 5 } },
    rarity = 1,
    atlas = 'j_final_chapter3',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult_per_card } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            return {
                mult = card.ability.extra.mult_per_card,
                card = card
            }
        end
    end
})

-- Climax (J959)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_climax',
    config = { extra = { x_mult = 3 } },
    rarity = 1,
    atlas = 'j_final_climax',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            if (G.GAME.last_hand_sampling.flush or G.GAME.last_hand_sampling.straight) then
                local has_face = false
                for k, v in ipairs(context.scoring_hand) do
                    if v:is_face() then has_face = true; break end
                end
                if has_face then
                    return {
                        x_mult = card.ability.extra.x_mult,
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                    }
                end
            end
        end
    end
})

-- Plot Twist (J960)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_plot_twist',
    config = { extra = { mult = 20 } },
    rarity = 1,
    atlas = 'j_final_plot_twist',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('plot_twist') < G.GAME.probabilities.normal / 4 and not context.blueprint then
                card.ability.extra.mult = card.ability.extra.mult * 2
                return {
                    mult_mod = card.ability.extra.mult,
                    message = "TWIST! X2",
                    colour = G.C.MULT
                }
            end
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Hero (J961)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_hero',
    config = { extra = { x_mult = 3 } },
    rarity = 1,
    atlas = 'j_final_hero',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and #G.jokers.cards <= 1 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Villain (J962)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_villain',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_final_villain',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    add_to_deck = function(self, card)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - 1
        ease_hands_left(-1)
    end,
    remove_from_deck = function(self, card)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + 1
        ease_hands_left(1)
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Sidekick (J963)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_sidekick',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_final_sidekick',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) 
        local count = (G.jokers and G.jokers.cards) and #G.jokers.cards or 1
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult, (count - 1) * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = #G.jokers.cards - 1
            if count > 0 then
                return {
                    mult_mod = count * card.ability.extra.mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { count * card.ability.extra.mult } }
                }
            end
        end
    end
})

-- Mentor (J964)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_mentor',
    config = { extra = { mult = 5 } },
    rarity = 1,
    atlas = 'j_final_mentor',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) 
        local levels = 0
        for k, v in pairs(G.GAME.hands) do
            if v.played > 0 then levels = levels + v.level end
        end
        return { vars = { card.ability.extra.mult, levels * card.ability.extra.mult } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local levels = 0
            for k, v in pairs(G.GAME.hands) do
                if v.played > 0 then levels = levels + v.level end
            end
            if levels > 0 then
                return {
                    mult_mod = levels * card.ability.extra.mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { levels * card.ability.extra.mult } }
                }
            end
        end
    end
})

-- Rival (J965)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_rival',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_final_rival',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.chips < G.GAME.blind.chips then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Love (J966)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_love',
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    atlas = 'j_final_love',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Hearts') then
                return {
                    x_mult = card.ability.extra.x_mult,
                    card = card
                }
            end
        end
    end
})

-- Hate (J967)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_hate',
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    atlas = 'j_final_hate',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Spades') then
                return {
                    x_mult = card.ability.extra.x_mult,
                    card = card
                }
            end
        end
    end
})

-- Peace (J968)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_peace',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_final_peace',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_used == 0 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- War (J969)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_war',
    config = { extra = { mult = 0, mult_per_dest = 2 } },
    rarity = 1,
    atlas = 'j_final_war',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult_per_dest, (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        -- Need global hook for destruction, but we can simulate with selling cards or specific effects
    end
})

-- Death (J970)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_death',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_final_death',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            if #G.hand.cards > 0 and not context.blueprint then
                local destroyed_card = G.hand.cards[math.random(#G.hand.cards)]
                destroyed_card:start_dissolve()
            end
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})


-- J971-988: Final & Specials (Uncommon)

-- Rebirth (J971)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_rebirth',
    rarity = 2,
    atlas = 'j_final_rebirth',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and G.GAME.chips < G.GAME.blind.chips and not context.blueprint and not context.repetition and not context.other_card then
            if G.GAME.current_round.hands_left == 0 then
                G.GAME.chips = G.GAME.blind.chips
                if not card.ability.eternal then card:start_dissolve() end
                return {
                    message = "REBIRTH!",
                    colour = G.C.GOLD
                }
            end
        end
    end
})

-- Karma (J972)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_karma',
    config = { extra = { x_mult = 1.5, per_boss = 0.2, penalty = 0.5 } },
    rarity = 2,
    atlas = 'j_final_karma',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult, ( (card and card.ability and card.ability.extra) or self.config.extra ).per_boss, ( (card and card.ability and card.ability.extra) or self.config.extra ).penalty } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
        if context.end_of_round and G.GAME.blind.boss and not context.blueprint and not context.repetition and not context.other_card then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.per_boss
        end
        if context.selling_card and context.card.ability.set == 'Joker' and not context.blueprint then
            card.ability.extra.x_mult = math.max(1, card.ability.extra.x_mult - card.ability.extra.penalty)
        end
    end
})

-- Dharma (J973)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_dharma',
    config = { extra = { mult = 20, tri_mult = 60 } },
    rarity = 2,
    atlas = 'j_final_dharma',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).tri_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local most_played = nil
            local max_plays = -1
            for k, v in pairs(G.GAME.hands) do
                if v.played > max_plays then
                    max_plays = v.played
                    most_played = k
                end
            end
            
            if context.scoring_name == most_played then
                return {
                    mult_mod = card.ability.extra.tri_mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.tri_mult } }
                }
            else
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- Nirvana (J974)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_nirvana',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_final_nirvana',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and #G.hand.cards == 0 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Samsara (J975)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_samsara',
    rarity = 2,
    atlas = 'j_final_samsara',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    calculate = function(self, card, context)
        -- Hooking into card destruction is hard without global overrides, but we can check context.destroying_card if available
        -- For now, let's make it add a copy on discard to simulate cycle
        if context.discard and not context.blueprint then
            if pseudorandom('samsara') < G.GAME.probabilities.normal / 5 then
                local _card = copy_card(context.other_card)
                _card:set_edition({negative = true})
                _card:add_to_deck()
                G.deck:emplace(_card)
                return {
                    message = "SAMSARA",
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

-- Zen (J976)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_zen',
    config = { extra = { mult = 30, timer = 10, last_hand_time = G.TIMERS.REAL } },
    rarity = 2,
    atlas = 'j_final_zen',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).timer } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local now = G.TIMERS.REAL
            if now - card.ability.extra.last_hand_time >= card.ability.extra.timer then
                card.ability.extra.last_hand_time = now
                return {
                    mult_mod = card.ability.extra.mult,
                    message = "ZEN",
                    colour = G.C.MULT
                }
            end
            card.ability.extra.last_hand_time = now
        end
    end
})

-- Tao (J977)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_tao',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_final_tao',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local reds = 0
            local blacks = 0
            for k, v in ipairs(G.playing_cards) do
                if v:is_suit('Hearts') or v:is_suit('Diamonds') then reds = reds + 1
                else blacks = blacks + 1 end
            end
            if reds == blacks then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- Yin (J978)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_yin',
    config = { extra = { mult = 20, x_mult = 2 } },
    rarity = 2,
    atlas = 'j_final_yin',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_yang = false
            for k, v in ipairs(G.jokers.cards) do
                if v.config.center.key == 'j_odyssey_j_final_yang' then has_yang = true; break end
            end
            
            local spades_clubs = 0
            for k, v in ipairs(context.scoring_hand) do
                if v:is_suit('Spades') or v:is_suit('Clubs') then spades_clubs = spades_clubs + 1 end
            end
            
            if spades_clubs > 0 then
                local ret = { mult_mod = spades_clubs * card.ability.extra.mult }
                if has_yang then
                    ret.x_mult = card.ability.extra.x_mult
                end
                return ret
            end
        end
    end
})

-- Yang (J979)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_yang',
    config = { extra = { mult = 20, x_mult = 2 } },
    rarity = 2,
    atlas = 'j_final_yang',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_yin = false
            for k, v in ipairs(G.jokers.cards) do
                if v.config.center.key == 'j_odyssey_j_final_yin' then has_yin = true; break end
            end
            
            local hearts_diamonds = 0
            for k, v in ipairs(context.scoring_hand) do
                if v:is_suit('Hearts') or v:is_suit('Diamonds') then hearts_diamonds = hearts_diamonds + 1 end
            end
            
            if hearts_diamonds > 0 then
                local ret = { mult_mod = hearts_diamonds * card.ability.extra.mult }
                if has_yin then
                    ret.x_mult = card.ability.extra.x_mult
                end
                return ret
            end
        end
    end
})

-- Chi (J980)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_chi',
    config = { extra = { chips = 50, per_hand = 10 } },
    rarity = 2,
    atlas = 'j_final_chi',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips, (( (card and card.ability and card.ability.extra) or self.config.extra )).per_hand } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
        if context.end_of_round and not context.blueprint and not context.repetition and not context.other_card then
            local bonus = G.GAME.current_round.hands_left * card.ability.extra.per_hand
            if bonus > 0 then
                card.ability.extra.chips = card.ability.extra.chips + bonus
                return {
                    message = "CHI +",
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- Chakra (J981)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_chakra',
    config = { extra = { mult_per_slot = 10 } },
    rarity = 2,
    atlas = 'j_final_chakra',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) 
        local slots = (G.consumeables and G.consumeables.config) and G.consumeables.config.card_limit or 0
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_slot, slots * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_slot } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local slots = G.consumeables.config.card_limit
            if slots > 0 then
                return {
                    mult_mod = slots * card.ability.extra.mult_per_slot,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { slots * card.ability.extra.mult_per_slot } }
                }
            end
        end
    end
})

-- Mantra (J982)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_mantra',
    config = { extra = { x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_final_mantra',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            for k, v in ipairs(context.scoring_hand) do
                suits[v.base.suit] = true
            end
            local count = 0
            for k, v in pairs(suits) do count = count + 1 end
            
            if count == 1 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- Mandala (J983)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_mandala',
    rarity = 2,
    atlas = 'j_final_mandala',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            for k, v in ipairs(context.scoring_hand) do
                suits[v.base.suit] = true
            end
            local count = 0
            for k, v in pairs(suits) do count = count + 1 end
            
            if count >= 4 and #G.consumeables.cards < G.consumeables.config.card_limit then
                local _card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'mandala')
                _card:add_to_deck()
                G.consumeables:emplace(_card)
                return {
                    message = "MANDALA!",
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

-- Lótus (J984)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_lotus',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_final_lotus',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_used == 0 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Om (J985)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_om',
    rarity = 2,
    atlas = 'j_final_om',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card == context.scoring_hand[1] then
                return {
                    message = 'OM',
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- Guru (J986)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_guru',
    rarity = 2,
    atlas = 'j_final_guru',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.level_up and not context.blueprint then
            if #G.consumeables.cards < G.consumeables.config.card_limit then
                local _card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, nil, 'guru')
                _card:add_to_deck()
                G.consumeables:emplace(_card)
                return {
                    message = "GURU!",
                    colour = G.C.SECONDARY_SET.Spectral
                }
            end
        end
    end
})

-- Yogi (J987)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_yogi',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_final_yogi',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.dollars == 0 then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Avatar (J988)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_avatar',
    config = { extra = { target_key = nil } },
    rarity = 2,
    atlas = 'j_final_avatar',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card) 
        local name = "None"
        if ( (card and card.ability and card.ability.extra) or self.config.extra ).target_key then
            name = G.P_CENTERS[( (card and card.ability and card.ability.extra) or self.config.extra ).target_key].name
        end
        return { vars = { name } } 
    end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            local other_jokers = {}
            for k, v in ipairs(G.jokers.cards) do
                if v ~= card then table.insert(other_jokers, v.config.center.key) end
            end
            if #other_jokers > 0 then
                -- ODYSSEY FIX: Ensure the correct vanilla helper is used
                card.ability.extra.target_key = pseudorandom_element(other_jokers, pseudoseed('avatar'))
            end
        end
        
        if card.ability.extra.target_key then
            local target_center = G.P_CENTERS[card.ability.extra.target_key]
            if target_center and target_center.calculate and type(target_center.calculate) == 'function' then
                -- Simular BluePrint/Brainstorm
                return target_center:calculate(card, context)
            end
        end
    end
})


-- J989-998: Final & Specials (Rare)

-- Enlightenment (J989)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_enlightenment',
    config = { extra = { x_mult = 4 } },
    rarity = 3,
    atlas = 'j_final_enlightenment',
    pos = { x = 0, y = 0 },
    cost = 15,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
        if context.setting_blind and not context.blueprint then
            for k, v in ipairs(G.playing_cards) do
                v:set_ability(G.P_CENTERS.m_odyssey_ceramic)
            end
        end
    end
})

-- Ascension (J990)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_ascension',
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    atlas = 'j_final_ascension',
    pos = { x = 0, y = 0 },
    cost = 15,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Transcendence (J991)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_transcendence',
    config = { extra = { x_mult = 6 } },
    rarity = 3,
    atlas = 'j_final_transcendence',
    pos = { x = 0, y = 0 },
    cost = 15,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local bonus = card.ability.extra.x_mult
            for k, v in ipairs(G.jokers.cards) do
                if v.config.center.rarity == 4 then bonus = bonus * 2; break end
            end
            return {
                x_mult = bonus,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { bonus } }
            }
        end
    end
})

-- Divinity (J992)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_divinity',
    config = { extra = { x_mult = 7 } },
    rarity = 3,
    atlas = 'j_final_divinity',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Omniscience (J993)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_omniscience',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_final_omniscience',
    pos = { x = 0, y = 0 },
    cost = 15,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.blind and not G.GAME.blind.reveal_boss then 
                G.GAME.blind:reveal_boss()
            end
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Omnipotence (J994)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_omnipotence',
    config = { extra = { x_mult = 10, hand_size = -2 } },
    rarity = 3,
    atlas = 'j_final_omnipotence',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).hand_size } } end,
    add_to_deck = function(self, card)
        G.hand:change_size(card.ability.extra.hand_size)
    end,
    remove_from_deck = function(self, card)
        G.hand:change_size(-card.ability.extra.hand_size)
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Omnipresence (J995)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_omnipresence',
    rarity = 3,
    atlas = 'j_final_omnipresence',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.retrigger_joker and not context.blueprint then
            if context.other_joker ~= card then
                return {
                    message = 'OMNIPRESENCE',
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- Eternity (J996)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_eternity',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_final_eternity',
    pos = { x = 0, y = 0 },
    cost = 15,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
        if context.setting_blind and not context.blueprint then
            for k, v in ipairs(G.jokers.cards) do
                v:set_eternal(true)
            end
        end
    end
})

-- Infinity (J997)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_infinity',
    rarity = 3,
    atlas = 'j_final_infinity',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) 
        local bonus = G.GAME.hands_played or 0
        return { vars = { bonus } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local bonus = G.GAME.hands_played or 0
            return {
                mult_mod = bonus,
                message = localize{ type = 'variable', key = 'a_mult', vars = { bonus } }
            }
        end
    end
})

-- Absolute (J998)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_absolute',
    config = { extra = { min_mult = 1000, x_mult = 2 } },
    rarity = 3,
    atlas = 'j_final_absolute',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).min_mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                mult_mod = card.ability.extra.min_mult,
                message = "ABSOLUTE"
            }
        end
    end
})


-- J999-1000: Final & Specials (Legendary)

-- The Creator (J999)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_the_creator',
    config = { extra = { x_mult = 100 } },
    rarity = 4,
    atlas = 'j_final_the_creator',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            for k, v in ipairs(G.jokers.cards) do
                if not v.edition then v:set_edition({polychrome = true}) end
            end
        end
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Odyssey (J1000)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_odyssey',
    rarity = 4,
    atlas = 'j_final_odyssey',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.GAME and G.GAME.jokers_encountered then
            for _ in pairs(G.GAME.jokers_encountered) do count = count + 1 end
        end
        return { vars = { count } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.GAME and G.GAME.jokers_encountered then
                for _ in pairs(G.GAME.jokers_encountered) do count = count + 1 end
            end
            if count > 0 then
                return {
                    x_mult = count,
                    message = "X" .. count,
                    colour = G.C.MULT
                }
            end
        end
    end
})


-- 1. Baralho Nebulosa
SMODS.Back({
    name = "Nebulosa",
    key = "nebula_deck",
    atlas = "b_nebula",
    pos = { x = 0, y = 0 },
    config = { vouchers = {'v_telescope'} },
})

-- 2. Baralho de Prótons
SMODS.Back({
    name = "Prótons",
    key = "protons",
    atlas = "b_protons",
    pos = { x = 0, y = 0 },
    config = { hand_size = 1 },
})

-- 3. Baralho de Elétrons
SMODS.Back({
    name = "Elétrons",
    key = "electrons",
    atlas = "b_electrons",
    pos = { x = 0, y = 0 },
    config = { discards = 1 },
})

-- 4. Baralho de Nêutrons
SMODS.Back({
    name = "Nêutrons",
    key = "neutrons",
    atlas = "b_neutrons",
    pos = { x = 0, y = 0 },
    config = { joker_slot = 2 },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    if v:is_face() then
                        v:start_dissolve(nil, true)
                    end
                end
                return true
            end
        }))
    end
})

-- 5. Baralho de Fótons
SMODS.Back({
    name = "Fótons",
    key = "photons",
    atlas = "b_photons",
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    v:set_ability(G.P_CENTERS.m_odyssey_diamond)
                end
                return true
            end
        }))
    end
})

