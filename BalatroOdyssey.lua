-- Balatro Odyssey
-- A mod adding 1000 unique Jokers
-- Author: fenomelini
-- Version: 0.1.2-alpha

----------------------------------------------
------------MOD CODE -------------------------
----------------------------------------------

-- Initialize the mod
SMODS.current_mod.config = SMODS.current_mod.config or {}
SMODS.current_mod.prefix = 'odyssey'

-- Global Mod Table
BalatroOdyssey = {}

----------------------------------------------
-- Odyssey Run Initialization
----------------------------------------------
-- Hook into game start run event
local game_start_run_ref = Game.start_run
function Game:start_run(args)
    -- FIX: Ensure global white color is pure white
    if G.C and G.C.WHITE then
        G.C.WHITE = {1, 1, 1, 1}
    end
    -- FIX: Reset love color state just in case
    if love and love.graphics then
        love.graphics.setColor(1, 1, 1, 1)
    end
    
    local ret = game_start_run_ref(self, args)
    
    -- Initialize Odyssey globals
    G.GAME.round_resets.consumeable_slots = G.GAME.round_resets.consumeable_slots or G.consumeables.config.card_limit
    G.GAME.round_resets.joker_slots = G.GAME.round_resets.joker_slots or G.jokers.config.card_limit
    G.GAME.round_resets.hand_size = G.GAME.round_resets.hand_size or G.hand.config.card_limit
    G.GAME.last_hand_time = G.TIMERS.REAL
    
    -- Odyssey Goal: Defeat ALL 100 custom Boss Blinds
    G.GAME.win_ante = 100

    G.GAME.viking_destroyed_count = G.GAME.viking_destroyed_count or 0
    G.GAME.odyssey_king_of_kings_active = G.GAME.odyssey_king_of_kings_active or 0
    G.GAME.booster_choices = G.GAME.booster_choices or 0
    G.GAME.shop_spectral_count = G.GAME.shop_spectral_count or 0
    G.GAME.negative_rate = G.GAME.negative_rate or 0
    G.GAME.skip_reward_multiplier = G.GAME.skip_reward_multiplier or 1
    G.GAME.interest_rate = G.GAME.interest_rate or 0
    G.GAME.interest_mult = G.GAME.interest_mult or 1
    G.GAME.reveal_future_blinds = G.GAME.reveal_future_blinds or 0
    G.GAME.reveal_skip_rewards = G.GAME.reveal_skip_rewards or false
    G.GAME.odyssey_prev_round_1_hand = G.GAME.odyssey_prev_round_1_hand or false
    
    -- Tarot Temp Buffs
    G.GAME.warrior_chips = G.GAME.warrior_chips or 0
    G.GAME.magician_mult = G.GAME.magician_mult or 0
    G.GAME.rogue_x_mult = G.GAME.rogue_x_mult or 1
    G.GAME.bard_retrigger = G.GAME.bard_retrigger or 0
    
    return ret
end
----------------------------------------------


----------------------------------------------
-- ATLAS CONFIGURATION
----------------------------------------------
-- 150 sprites customizados

SMODS.Atlas({ key = 'j_singularity_solitary', path = 'odyssey_j_singularity_solitary.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_isolated', path = 'odyssey_j_singularity_isolated.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_hermit', path = 'odyssey_j_singularity_hermit.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_purist', path = 'odyssey_j_singularity_purist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_minimalist', path = 'odyssey_j_singularity_minimalist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_unique', path = 'odyssey_j_singularity_unique.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_singular', path = 'odyssey_j_singularity_singular.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_monopolist', path = 'odyssey_j_singularity_monopolist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_exclusive', path = 'odyssey_j_singularity_exclusive.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_cosmic_solitary', path = 'odyssey_j_singularity_cosmic_solitary.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_ascetic', path = 'odyssey_j_singularity_ascetic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_one_man_army', path = 'odyssey_j_singularity_one_man_army.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_total_isolation', path = 'odyssey_j_singularity_total_isolation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_alone_in_space', path = 'odyssey_j_singularity_alone_in_space.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_stellar_hermit', path = 'odyssey_j_singularity_stellar_hermit.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_cosmic_solitude', path = 'odyssey_j_singularity_cosmic_solitude.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_growing_singularity', path = 'odyssey_j_singularity_growing_singularity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_dimensional_isolator', path = 'odyssey_j_singularity_dimensional_isolator.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_only_hope', path = 'odyssey_j_singularity_only_hope.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_monolith', path = 'odyssey_j_singularity_monolith.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_solidification', path = 'odyssey_j_singularity_solidification.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_parallel_universe', path = 'odyssey_j_singularity_parallel_universe.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_point_zero', path = 'odyssey_j_singularity_point_zero.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_black_singularity', path = 'odyssey_j_singularity_black_singularity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_lonely_star', path = 'odyssey_j_singularity_solitary_star.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_individualism', path = 'odyssey_j_singularity_individualism.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_primordial_void', path = 'odyssey_j_singularity_primordial_void.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_quantum_isolation', path = 'odyssey_j_singularity_quantum_isolation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_cosmic_monopoly', path = 'odyssey_j_singularity_cosmic_monopoly.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_reverse_singularity', path = 'odyssey_j_singularity_reverse_singularity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_black_hole', path = 'odyssey_j_singularity_black_hole.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_absolute_singularity', path = 'odyssey_j_singularity_absolute_singularity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_point_of_no_return', path = 'odyssey_j_singularity_point_of_no_return.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_stellar_collapse', path = 'odyssey_j_singularity_stellar_collapse.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_temporal_singularity', path = 'odyssey_j_singularity_temporal_singularity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_perfect_vacuum', path = 'odyssey_j_singularity_perfect_vacuum.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_inverse_singularity', path = 'odyssey_j_singularity_inverse_singularity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_omega_point', path = 'odyssey_j_singularity_omega_point.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_primordial', path = 'odyssey_j_singularity_primordial_singularity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_singularity_reverse_big_bang', path = 'odyssey_j_singularity_reverse_big_bang.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_superposition', path = 'odyssey_j_quantum_superposition.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_quantum_fluctuation', path = 'odyssey_j_quantum_quantum_fluctuation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_uncertainty', path = 'odyssey_j_quantum_uncertainty.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_duality', path = 'odyssey_j_quantum_duality.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_entanglement', path = 'odyssey_j_quantum_entanglement.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_quantum_leap', path = 'odyssey_j_quantum_quantum_leap.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_probability', path = 'odyssey_j_quantum_probability.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_schrodinger', path = 'odyssey_j_quantum_schrodinger.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_wave_collapse', path = 'odyssey_j_quantum_wave_collapse.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_tunneling', path = 'odyssey_j_quantum_tunneling.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_quantum_state', path = 'odyssey_j_quantum_quantum_state.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_observer', path = 'odyssey_j_quantum_observer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_antimatter', path = 'odyssey_j_quantum_antimatter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_entangled', path = 'odyssey_j_quantum_entangled.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_quantum_spin', path = 'odyssey_j_quantum_quantum_spin.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_virtual_particle', path = 'odyssey_j_quantum_virtual_particle.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_quantum_field', path = 'odyssey_j_quantum_quantum_field.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_decay', path = 'odyssey_j_quantum_decay.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_fission', path = 'odyssey_j_quantum_fission.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_fusion', path = 'odyssey_j_quantum_fusion.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_time_paradox', path = 'odyssey_j_quantum_temporal_paradox.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_deja_vu', path = 'odyssey_j_quantum_deja_vu.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_infinite_loop', path = 'odyssey_j_quantum_infinite_loop.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_rewind', path = 'odyssey_j_quantum_rewind.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_time_acceleration', path = 'odyssey_j_quantum_temporal_acceleration.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_time_anchor', path = 'odyssey_j_quantum_temporal_anchor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_chrono_trigger', path = 'odyssey_j_quantum_chrono_trigger.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_entropy', path = 'odyssey_j_quantum_entropy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_time_traveler', path = 'odyssey_j_quantum_time_traveler.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_slow_motion', path = 'odyssey_j_quantum_slow_motion.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_dimensional_portal', path = 'odyssey_j_quantum_dimensional_portal.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_mirror', path = 'odyssey_j_quantum_mirror.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_yin_yang', path = 'odyssey_j_quantum_yin_yang.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_parallel_dimension', path = 'odyssey_j_quantum_parallel_dimension.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_spatial_fold', path = 'odyssey_j_quantum_spatial_fold.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_wormhole', path = 'odyssey_j_quantum_wormhole.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_tesseract', path = 'odyssey_j_quantum_tesseract.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_klein_bottle', path = 'odyssey_j_quantum_klein_bottle.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_higher_planes', path = 'odyssey_j_quantum_higher_planes.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_quantum_hyperspace', path = 'odyssey_j_quantum_hyperspace.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_bifurcation', path = 'odyssey_j_temporal_bifurcation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_overlap', path = 'odyssey_j_temporal_overlap.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_layers', path = 'odyssey_j_temporal_layers.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_flatland', path = 'odyssey_j_temporal_flatland.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_void_between_worlds', path = 'odyssey_j_temporal_void_between_worlds.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_extra_dimension', path = 'odyssey_j_temporal_extra_dimension.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_multiverse', path = 'odyssey_j_temporal_multiverse.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_rift', path = 'odyssey_j_temporal_rift.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_circular_board', path = 'odyssey_j_temporal_circular_board.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_shadow_realm', path = 'odyssey_j_temporal_shadow_realm.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_dimensional_nexus', path = 'odyssey_j_temporal_dimensional_nexus.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_pocket_dimension', path = 'odyssey_j_temporal_pocket_dimension.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_phase_shift', path = 'odyssey_j_temporal_phase_shift.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_negative_space', path = 'odyssey_j_temporal_negative_space.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_astral_plane', path = 'odyssey_j_temporal_astral_plane.png', px = 71, py = 95 })


SMODS.Atlas({ key = 'j_temporal_convergence', path = 'odyssey_j_temporal_convergence.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_limbo', path = 'odyssey_j_temporal_limbo.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_subspace', path = 'odyssey_j_temporal_subspace.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_fractured_reality', path = 'odyssey_j_temporal_fractured_reality.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_omniverse', path = 'odyssey_j_temporal_omniverse.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_cosmic_clock', path = 'odyssey_j_temporal_cosmic_clock.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_time_echo', path = 'odyssey_j_temporal_echo.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_traveler_2', path = 'odyssey_j_temporal_traveler_2.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_paradox', path = 'odyssey_j_temporal_paradox.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_alternate_timeline', path = 'odyssey_j_temporal_alternate_timeline.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_stasis', path = 'odyssey_j_temporal_stasis.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_frozen_moment', path = 'odyssey_j_temporal_frozen_moment.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_uncertain_future', path = 'odyssey_j_temporal_uncertain_future.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_chronometer', path = 'odyssey_j_temporal_chronometer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_time_dilation', path = 'odyssey_j_temporal_time_dilation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_event_horizon', path = 'odyssey_j_temporal_temporal_event_horizon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_rewind', path = 'odyssey_j_temporal_temporal_rewind.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_repetition', path = 'odyssey_j_temporal_temporal_repetition.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_infinite_deja_vu', path = 'odyssey_j_temporal_infinite_deja_vu.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_promising_future', path = 'odyssey_j_temporal_promising_future.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_eternal_present', path = 'odyssey_j_temporal_eternal_present.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_forgotten_past', path = 'odyssey_j_temporal_lost_past.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_growth', path = 'odyssey_j_temporal_temporal_growth.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_double_hand', path = 'odyssey_j_temporal_double_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_temporal_eternal_loop', path = 'odyssey_j_temporal_eternal_loop.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_legacy', path = 'odyssey_j_dimensions_legacy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_infinite_growth', path = 'odyssey_j_dimensions_infinite_growth.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_accumulation', path = 'odyssey_j_dimensions_accumulation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_last_hour', path = 'odyssey_j_dimensions_last_hour.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_linear_scaling', path = 'odyssey_j_dimensions_linear_scaling.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_momentum', path = 'odyssey_j_dimensions_momentum.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_sacrifice', path = 'odyssey_j_dimensions_sacrifice.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_lucky_number', path = 'odyssey_j_dimensions_lucky_number.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_random_bonus', path = 'odyssey_j_dimensions_random_bonus.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_cumulative', path = 'odyssey_j_dimensions_cumulative.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_streak', path = 'odyssey_j_dimensions_streak.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_fast_burn', path = 'odyssey_j_dimensions_fast_burn.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_hidden_treasure', path = 'odyssey_j_dimensions_hidden_treasure.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_first_three', path = 'odyssey_j_dimensions_first_three.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_last_three', path = 'odyssey_j_dimensions_last_three.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_best_play', path = 'odyssey_j_dimensions_best_play.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_learning', path = 'odyssey_j_dimensions_learning.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_memory', path = 'odyssey_j_dimensions_memory.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_big_luck', path = 'odyssey_j_dimensions_big_luck.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_temporal_synergy', path = 'odyssey_j_dimensions_temporal_synergy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_ultimate_stability', path = 'odyssey_j_dimensions_stability.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_chaotic', path = 'odyssey_j_dimensions_chaotic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_first_card', path = 'odyssey_j_dimensions_first_card.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_last_card', path = 'odyssey_j_dimensions_last_card.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_double_processing', path = 'odyssey_j_dimensions_double_processing.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_ante_start', path = 'odyssey_j_dimensions_aposta_start.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_boss_fighter', path = 'odyssey_j_dimensions_boss_fighter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_blind_watcher', path = 'odyssey_j_dimensions_blind_watcher.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_reverse_order', path = 'odyssey_j_dimensions_reverse_order.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_final_sacrifice', path = 'odyssey_j_dimensions_final_sacrifice.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_eternity', path = 'odyssey_j_time_eternity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_perpetual_cycle', path = 'odyssey_j_time_cycle.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_destiny_anchor', path = 'odyssey_j_temporal_anchor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_quantum_bifurcation', path = 'odyssey_j_temporal_bifurcation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_doomsday_clock', path = 'odyssey_j_temporal_cosmic_clock.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_countdown', path = 'odyssey_j_time_countdown.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_eternal_stasis', path = 'odyssey_j_temporal_stasis.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_perfect_memory', path = 'odyssey_j_dimensions_memory.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_fixed_point', path = 'odyssey_j_singularity_point_zero.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_maximum_entropy', path = 'odyssey_j_chaos_maximum_entropy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_temporal_singularity_2', path = 'odyssey_j_temporal_traveler_2.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_causal_reversal', path = 'odyssey_j_paradox_polarity_reversal.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_end_of_times', path = 'odyssey_j_time_end_times.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_merge', path = 'odyssey_j_dimensions_dimensional_merge.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_pocket_universe', path = 'odyssey_j_dimensions_pocket_universe.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_lord', path = 'odyssey_j_dimensions_dimensional_lord.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_reality_breach', path = 'odyssey_j_dimensions_reality_breach.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_omnipresent', path = 'odyssey_j_dimensions_omnipresent.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_collapse', path = 'odyssey_j_dimensions_dimensional_collapse.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_multiverse_navigator', path = 'odyssey_j_dimensions_multiverse_navigator.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_transcendence', path = 'odyssey_j_dimensions_dimensional_transcendence.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_master_of_space', path = 'odyssey_j_dimensions_master_of_space.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_dimensions_omnidimensional', path = 'odyssey_j_dimensions_omnidimensional.png', px = 71, py = 95 })

-- TIME & TURNS (601-650)
SMODS.Atlas({ key = 'j_time_hourglass', path = 'odyssey_j_time_hourglass.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_stopwatch', path = 'odyssey_j_time_stopwatch.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_countdown', path = 'odyssey_j_time_countdown.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_patience', path = 'odyssey_j_time_patience.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_haste', path = 'odyssey_j_time_haste.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_extra_turn', path = 'odyssey_j_time_extra_turn.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_rush_hour', path = 'odyssey_j_time_rush_hour.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_delay', path = 'odyssey_j_time_delay.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_cycle', path = 'odyssey_j_time_cycle.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_seasons', path = 'odyssey_j_time_seasons.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_day_night', path = 'odyssey_j_time_day_and_night.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_sundial', path = 'odyssey_j_time_sundial.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_pendulum', path = 'odyssey_j_time_pendulum.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_metronome', path = 'odyssey_j_time_metronome.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_zone', path = 'odyssey_j_time_time_zone.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_ice_age', path = 'odyssey_j_time_ice_age.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_stone_age', path = 'odyssey_j_time_stone_age.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_bronze_age', path = 'odyssey_j_time_bronze_age.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_iron_age', path = 'odyssey_j_time_iron_age.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_future', path = 'odyssey_j_time_future.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_machine', path = 'odyssey_j_time_time_machine.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_back_to_the_future', path = 'odyssey_j_time_back_to_the_future.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_doppler_effect', path = 'odyssey_j_time_doppler_effect.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_relativity', path = 'odyssey_j_time_relativity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_wormhole', path = 'odyssey_j_time_wormhole.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_skip', path = 'odyssey_j_time_time_skip.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_freeze', path = 'odyssey_j_time_time_freeze.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_loop', path = 'odyssey_j_time_time_loop.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_grandfather_paradox', path = 'odyssey_j_time_grandfather_paradox.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_precognition', path = 'odyssey_j_time_precognition.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_deja_vu', path = 'odyssey_j_time_deja_vu.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_eternity', path = 'odyssey_j_time_eternity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_ephemeral', path = 'odyssey_j_time_ephemeral.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_chronokinesis', path = 'odyssey_j_time_chronokinesis.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_synchronicity', path = 'odyssey_j_time_synchronicity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_anachronism', path = 'odyssey_j_time_anachronism.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_lost_time', path = 'odyssey_j_time_lost_time.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_end_times', path = 'odyssey_j_time_end_times.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_time_lord', path = 'odyssey_j_time_time_lord.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_the_world', path = 'odyssey_j_time_the_world.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_aeon', path = 'odyssey_j_time_aeon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_kairos', path = 'odyssey_j_time_kairos.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_chronos', path = 'odyssey_j_time_chronos.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_ouroboros', path = 'odyssey_j_time_ouroboros.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_reverse_entropy', path = 'odyssey_j_time_reverse_entropy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_big_crunch', path = 'odyssey_j_time_big_crunch.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_big_bang', path = 'odyssey_j_time_big_bang.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_sacred_timeline', path = 'odyssey_j_time_sacred_timeline.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_father_time', path = 'odyssey_j_time_father_time.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_time_guardian_of_eternity', path = 'odyssey_j_time_guardian_of_eternity.png', px = 71, py = 95 })

----------------------------------------------
-- DECK ATLASES
----------------------------------------------
SMODS.Atlas({ key = 'b_nebula', path = 'odyssey_d_nebula.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_protons', path = 'odyssey_d_protons.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_electrons', path = 'odyssey_d_electrons.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_neutrons', path = 'odyssey_d_neutrons.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_photons', path = 'odyssey_d_photons.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_gravitational', path = 'odyssey_d_gravitational.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_event_horizon', path = 'odyssey_d_event_horizon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_wormhole', path = 'odyssey_d_wormhole.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_supernova', path = 'odyssey_d_supernova.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_quasar', path = 'odyssey_d_quasar.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_dark_energy', path = 'odyssey_d_dark_energy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_antimatter', path = 'odyssey_d_antimatter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_vacuum', path = 'odyssey_d_vacuum.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_string_theory', path = 'odyssey_d_string_theory.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_chaos', path = 'odyssey_d_chaos.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_order', path = 'odyssey_d_order.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_paradox', path = 'odyssey_d_paradox.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_timeline', path = 'odyssey_d_timeline.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_parallel', path = 'odyssey_d_parallel.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_dimensional', path = 'odyssey_d_dimensional.png', px = 71, py = 95 })

-- CELESTIAL (161-200)
SMODS.Atlas({ key = 'j_celestial_wormhole', path = 'odyssey_j_celestial_wormhole.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_shooting_star', path = 'odyssey_j_celestial_shooting_star.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_constellation', path = 'odyssey_j_celestial_constellation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_new_moon', path = 'odyssey_j_celestial_new_moon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_rising_sun', path = 'odyssey_j_celestial_rising_sun.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_nebula', path = 'odyssey_j_celestial_nebula.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_comet', path = 'odyssey_j_celestial_comet.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_asteroid', path = 'odyssey_j_celestial_asteroid.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_pulsar', path = 'odyssey_j_celestial_pulsar.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_quasar', path = 'odyssey_j_celestial_quasar.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_supernova', path = 'odyssey_j_celestial_supernova.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_satellite', path = 'odyssey_j_celestial_satellite.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_eclipse', path = 'odyssey_j_celestial_eclipse.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_meteor', path = 'odyssey_j_celestial_meteor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_cosmic_dust', path = 'odyssey_j_celestial_cosmic_dust.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_stellar_radiation', path = 'odyssey_j_celestial_stellar_radiation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_planetary_alignment', path = 'odyssey_j_celestial_planetary_alignment.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_meteor_shower', path = 'odyssey_j_celestial_meteor_shower.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_solar_storm', path = 'odyssey_j_celestial_solar_storm.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_rings_of_saturn', path = 'odyssey_j_celestial_rings_of_saturn.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_zero_gravity', path = 'odyssey_j_celestial_zero_gravity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_stellar_field', path = 'odyssey_j_celestial_stellar_field.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_nuclear_fusion', path = 'odyssey_j_celestial_nuclear_fusion.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_solar_wind', path = 'odyssey_j_celestial_solar_wind.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_gravitational_tide', path = 'odyssey_j_celestial_gravitational_tide.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_event_horizon', path = 'odyssey_j_celestial_event_horizon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_stellar_singularity', path = 'odyssey_j_celestial_stellar_singularity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_planetary_nebula', path = 'odyssey_j_celestial_planetary_nebula.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_protostar', path = 'odyssey_j_celestial_protostar.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_white_dwarf', path = 'odyssey_j_celestial_white_dwarf.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_big_bang', path = 'odyssey_j_celestial_big_bang.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_supermassive_black_hole', path = 'odyssey_j_celestial_supermassive_black_hole.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_gamma_ray_burst', path = 'odyssey_j_celestial_gamma_ray_burst.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_dark_matter', path = 'odyssey_j_celestial_dark_matter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_dark_energy', path = 'odyssey_j_celestial_dark_energy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_cosmic_inflation', path = 'odyssey_j_celestial_cosmic_inflation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_false_vacuum', path = 'odyssey_j_celestial_false_vacuum.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_dyson_sphere', path = 'odyssey_j_celestial_dyson_sphere.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_universe_generator', path = 'odyssey_j_celestial_universe_generator.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_celestial_cosmic_entity', path = 'odyssey_j_celestial_cosmic_entity.png', px = 71, py = 95 })

-- Chaos Group (201-240)
SMODS.Atlas({ key = 'j_chaos_loaded_die', path = 'odyssey_j_chaos_loaded_die.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_lucky_coin', path = 'odyssey_j_chaos_lucky_coin.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_roulette', path = 'odyssey_j_chaos_roulette.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_unpredictable', path = 'odyssey_j_chaos_unpredictable.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_controlled_chaos', path = 'odyssey_j_chaos_controlled_chaos.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_minor_entropy', path = 'odyssey_j_chaos_minor_entropy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_shuffler', path = 'odyssey_j_chaos_shuffler.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_wild_joker', path = 'odyssey_j_chaos_wild_joker.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_beginners_luck', path = 'odyssey_j_chaos_beginner_s_luck.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_high_stakes', path = 'odyssey_j_chaos_high_stakes.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_calculated_risk', path = 'odyssey_j_chaos_calculated_risk.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_frenzy', path = 'odyssey_j_chaos_frenzy.png', px = 71, py = 95 })

SMODS.Atlas({ key = 'j_chaos_scatter', path = 'odyssey_j_chaos_scatter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_white_noise', path = 'odyssey_j_chaos_white_noise.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_turbulence', path = 'odyssey_j_chaos_turbulence.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_unstable', path = 'odyssey_j_chaos_unstable.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_theory', path = 'odyssey_j_chaos_chaos_theory.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_butterfly_effect', path = 'odyssey_j_chaos_butterfly_effect.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_pandemonium', path = 'odyssey_j_chaos_pandemonium.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_discord', path = 'odyssey_j_chaos_discord.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_anarchy', path = 'odyssey_j_chaos_anarchy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_mana_vortex', path = 'odyssey_j_chaos_mana_vortex.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_transmutation', path = 'odyssey_j_chaos_transmutation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_unstable_alchemy', path = 'odyssey_j_chaos_unstable_alchemy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_chain_reaction', path = 'odyssey_j_chaos_chain_reaction.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_will_o_the_wisp', path = 'odyssey_j_chaos_will_o_the_wisp.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_pandoras_box', path = 'odyssey_j_chaos_pandora_s_box.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_bad_omen', path = 'odyssey_j_chaos_bad_omen.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_leap_of_faith', path = 'odyssey_j_chaos_leap_of_faith.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_dissonance', path = 'odyssey_j_chaos_dissonance.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_agent_of_chaos', path = 'odyssey_j_chaos_agent_of_chaos.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_improbability_drive', path = 'odyssey_j_chaos_improbability_drive.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_chance_nexus', path = 'odyssey_j_chaos_chance_nexus.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_primal_form', path = 'odyssey_j_chaos_primal_form.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_heart_of_chaos', path = 'odyssey_j_chaos_heart_of_chaos.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_warp_storm', path = 'odyssey_j_chaos_warp_storm.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_the_great_filter', path = 'odyssey_j_chaos_the_great_filter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_azathoth', path = 'odyssey_j_chaos_azathoth.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_chaos_crawling_chaos', path = 'odyssey_j_chaos_crawling_chaos.png', px = 71, py = 95 })

SMODS.Atlas({ key = 'j_glitch_visual_bug', path = 'odyssey_j_glitch_visual_bug.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_syntax_error', path = 'odyssey_j_glitch_syntax_error.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_lag', path = 'odyssey_j_glitch_lag.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_dead_pixel', path = 'odyssey_j_glitch_dead_pixel.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_money_glitch', path = 'odyssey_j_glitch_money_glitch.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_overflow', path = 'odyssey_j_glitch_overflow.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_underflow', path = 'odyssey_j_glitch_underflow.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_clipping', path = 'odyssey_j_glitch_clipping.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_corrupted', path = 'odyssey_j_glitch_corrupted.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_missingno', path = 'odyssey_j_glitch_missingno.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_blue_screen', path = 'odyssey_j_glitch_blue_screen.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_error_404', path = 'odyssey_j_glitch_error_404.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_infinite_loop', path = 'odyssey_j_glitch_infinite_loop.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_stack_overflow', path = 'odyssey_j_glitch_stack_overflow.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_memory_leak', path = 'odyssey_j_glitch_memory_leak.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_patch', path = 'odyssey_j_glitch_patch.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_exploit', path = 'odyssey_j_glitch_exploit.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_debug_mode', path = 'odyssey_j_glitch_debug_mode.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_god_mode', path = 'odyssey_j_glitch_god_mode.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_noclip', path = 'odyssey_j_glitch_noclip.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_speedrun', path = 'odyssey_j_glitch_speedrun.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_softlock', path = 'odyssey_j_glitch_softlock.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_duplication_glitch', path = 'odyssey_j_glitch_duplication_glitch.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_source_code', path = 'odyssey_j_glitch_source_code.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_hacker', path = 'odyssey_j_glitch_hacker.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_firewall', path = 'odyssey_j_glitch_firewall.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_virus', path = 'odyssey_j_glitch_virus.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_trojan', path = 'odyssey_j_glitch_trojan.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_phishing', path = 'odyssey_j_glitch_phishing.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_zero_day', path = 'odyssey_j_glitch_zero_day.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_game_breaker', path = 'odyssey_j_glitch_game_breaker.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_kill_screen', path = 'odyssey_j_glitch_kill_screen.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_matrix_glitch', path = 'odyssey_j_glitch_matrix_glitch.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_overwrite', path = 'odyssey_j_glitch_overwrite.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_hex_editor', path = 'odyssey_j_glitch_hex_editor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_corruption', path = 'odyssey_j_glitch_corruption.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_segfault', path = 'odyssey_j_glitch_segfault.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_root_access', path = 'odyssey_j_glitch_root_access.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_the_architect', path = 'odyssey_j_glitch_the_architect.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_glitch_digital_singularity', path = 'odyssey_j_glitch_digital_singularity.png', px = 71, py = 95 })

-- ELEMENTAL (401-450)
SMODS.Atlas({ key = 'j_elemental_eternal_flame', path = 'odyssey_j_elemental_eternal_flame.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_raindrop', path = 'odyssey_j_elemental_raindrop.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_runestone', path = 'odyssey_j_elemental_runestone.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_gentle_breeze', path = 'odyssey_j_elemental_gentle_breeze.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_inferno', path = 'odyssey_j_elemental_inferno.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_tsunami', path = 'odyssey_j_elemental_tsunami.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_earthquake', path = 'odyssey_j_elemental_earthquake.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_tornado', path = 'odyssey_j_elemental_tornado.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_volcano', path = 'odyssey_j_elemental_volcano.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_iceberg', path = 'odyssey_j_elemental_iceberg.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_lightning', path = 'odyssey_j_elemental_lightning.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_magma', path = 'odyssey_j_elemental_magma.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_mud', path = 'odyssey_j_elemental_mud.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_ember', path = 'odyssey_j_elemental_ember.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_dew', path = 'odyssey_j_elemental_dew.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_crystal', path = 'odyssey_j_elemental_crystal.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_smoke', path = 'odyssey_j_elemental_smoke.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_spark', path = 'odyssey_j_elemental_spark.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_wave', path = 'odyssey_j_elemental_wave.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_ash', path = 'odyssey_j_elemental_ash.png', px = 71, py = 95 })

SMODS.Atlas({ key = 'j_elemental_fire_spirit', path = 'odyssey_j_elemental_fire_spirit.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_water_spirit', path = 'odyssey_j_elemental_water_spirit.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_earth_spirit', path = 'odyssey_j_elemental_earth_spirit.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_air_spirit', path = 'odyssey_j_elemental_air_spirit.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_elemental_fusion', path = 'odyssey_j_elemental_elemental_fusion.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_steam', path = 'odyssey_j_elemental_steam.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_lava', path = 'odyssey_j_elemental_lava.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_sandstorm', path = 'odyssey_j_elemental_sandstorm.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_storm', path = 'odyssey_j_elemental_storm.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_element_master', path = 'odyssey_j_elemental_element_master.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_prism', path = 'odyssey_j_elemental_prism.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_aether', path = 'odyssey_j_elemental_aether.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_plasma', path = 'odyssey_j_elemental_plasma.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_geode', path = 'odyssey_j_elemental_geode.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_thunderbolt', path = 'odyssey_j_elemental_thunderbolt.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_blizzard', path = 'odyssey_j_elemental_blizzard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_fire_meteor', path = 'odyssey_j_elemental_fire_meteor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_garden', path = 'odyssey_j_elemental_garden.png', px = 71, py = 95 })

SMODS.Atlas({ key = 'j_elemental_phoenix', path = 'odyssey_j_elemental_phoenix.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_leviathan', path = 'odyssey_j_elemental_leviathan.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_behemoth', path = 'odyssey_j_elemental_behemoth.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_ziz', path = 'odyssey_j_elemental_ziz.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_fifth_element', path = 'odyssey_j_elemental_fifth_element.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_master_alchemist', path = 'odyssey_j_elemental_master_alchemist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_heart_of_the_world', path = 'odyssey_j_elemental_heart_of_the_world.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_neutron_star', path = 'odyssey_j_elemental_neutron_star.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_superconductor', path = 'odyssey_j_elemental_superconductor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_absolute_zero', path = 'odyssey_j_elemental_absolute_zero.png', px = 71, py = 95 })

SMODS.Atlas({ key = 'j_elemental_avatar', path = 'odyssey_j_elemental_avatar.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_elemental_cataclysm', path = 'odyssey_j_elemental_cataclysm.png', px = 71, py = 95 })

-- TRIBAL (451-500)
SMODS.Atlas({ key = 'j_tribal_squire', path = 'odyssey_j_tribal_squire.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_lady_in_waiting', path = 'odyssey_j_tribal_lady_in_waiting.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_royal_guard', path = 'odyssey_j_tribal_royal_guard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_jester', path = 'odyssey_j_tribal_jester.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_warrior', path = 'odyssey_j_tribal_warrior.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_mage', path = 'odyssey_j_tribal_mage.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_rogue', path = 'odyssey_j_tribal_rogue.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_cleric', path = 'odyssey_j_tribal_cleric.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_barbarian', path = 'odyssey_j_tribal_barbarian.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_paladin', path = 'odyssey_j_tribal_paladin.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_druid', path = 'odyssey_j_tribal_druid.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_necromancer', path = 'odyssey_j_tribal_necromancer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_bard', path = 'odyssey_j_tribal_bard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_monk', path = 'odyssey_j_tribal_monk.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_hunter', path = 'odyssey_j_tribal_hunter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_blacksmith', path = 'odyssey_j_tribal_blacksmith.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_merchant', path = 'odyssey_j_tribal_merchant.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_alchemist', path = 'odyssey_j_tribal_alchemist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_seer', path = 'odyssey_j_tribal_seer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_peasant', path = 'odyssey_j_tribal_peasant.png', px = 71, py = 95 })

SMODS.Atlas({ key = 'j_tribal_barbarian_king', path = 'odyssey_j_tribal_barbarian_king.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_fairy_queen', path = 'odyssey_j_tribal_fairy_queen.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_archmage', path = 'odyssey_j_tribal_archmage.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_grandmaster', path = 'odyssey_j_tribal_grandmaster.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_assassin', path = 'odyssey_j_tribal_assassin.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_berserker', path = 'odyssey_j_tribal_berserker.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_shaman', path = 'odyssey_j_tribal_shaman.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_knight', path = 'odyssey_j_tribal_knight.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_ninja', path = 'odyssey_j_tribal_ninja.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_samurai', path = 'odyssey_j_tribal_samurai.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_viking', path = 'odyssey_j_tribal_viking.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_pirate', path = 'odyssey_j_tribal_pirate.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_gladiator', path = 'odyssey_j_tribal_gladiator.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_musketeer', path = 'odyssey_j_tribal_musketeer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_legionnaire', path = 'odyssey_j_tribal_legionnaire.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_emperor', path = 'odyssey_j_tribal_emperor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_high_priestess', path = 'odyssey_j_tribal_high_priestess.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_the_hermit', path = 'odyssey_j_tribal_the_hermit.png', px = 71, py = 95 })

SMODS.Atlas({ key = 'j_tribal_council_of_kings', path = 'odyssey_j_tribal_council_of_kings.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_harem', path = 'odyssey_j_tribal_harem.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_brotherhood', path = 'odyssey_j_tribal_brotherhood.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_mage_circle', path = 'odyssey_j_tribal_mage_circle.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_thieves_guild', path = 'odyssey_j_tribal_thieves_guild.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_holy_order', path = 'odyssey_j_tribal_holy_order.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_shadow_army', path = 'odyssey_j_tribal_shadow_army.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_champion', path = 'odyssey_j_tribal_champion.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_dark_lord', path = 'odyssey_j_tribal_dark_lord.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_hero', path = 'odyssey_j_tribal_hero.png', px = 71, py = 95 })

SMODS.Atlas({ key = 'j_tribal_great_chief', path = 'odyssey_j_tribal_king_of_kings.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_ancient_one', path = 'odyssey_j_tribal_god_of_war.png', px = 71, py = 95 })

SMODS.Atlas({ key = 'j_corruption_blood_pact', path = 'odyssey_j_corruption_blood_pact.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_sold_soul', path = 'odyssey_j_corruption_sold_soul.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_cursed_blade', path = 'odyssey_j_corruption_cursed_blade.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_poisoned_chalice', path = 'odyssey_j_corruption_poisoned_chalice.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_minor_sacrifice', path = 'odyssey_j_corruption_minor_sacrifice.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_life_drain', path = 'odyssey_j_corruption_life_drain.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_parasite', path = 'odyssey_j_corruption_parasite.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_decomposition', path = 'odyssey_j_corruption_decomposition.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_rust', path = 'odyssey_j_corruption_rust.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_noxious_spores', path = 'odyssey_j_corruption_noxious_spores.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_contamination', path = 'odyssey_j_corruption_contamination.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_necrosis', path = 'odyssey_j_corruption_necrosis.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_plague', path = 'odyssey_j_corruption_plague.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_rotten_hand', path = 'odyssey_j_corruption_rotten_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_dark_heart', path = 'odyssey_j_corruption_dark_heart.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_corrupted_mind', path = 'odyssey_j_corruption_corrupted_mind.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_cannibalism', path = 'odyssey_j_corruption_cannibalism.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_vampirism', path = 'odyssey_j_corruption_vampirism.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_necromancy', path = 'odyssey_j_corruption_necromancy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_offering', path = 'odyssey_j_corruption_offering.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_curse_of_gold', path = 'odyssey_j_corruption_curse_of_gold.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_void_whispers', path = 'odyssey_j_corruption_void_whispers.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_mark_of_the_beast', path = 'odyssey_j_corruption_mark_of_the_beast.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_soul_corruption', path = 'odyssey_j_corruption_soul_corruption.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_decadence', path = 'odyssey_j_corruption_decadence.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_toxin', path = 'odyssey_j_corruption_toxin.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_mutation', path = 'odyssey_j_corruption_mutation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_scar', path = 'odyssey_j_corruption_scar.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_slow_poison', path = 'odyssey_j_corruption_slow_poison.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_grim_harvest', path = 'odyssey_j_corruption_grim_harvest.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_pestilence', path = 'odyssey_j_corruption_pestilence.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_famine', path = 'odyssey_j_corruption_famine.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_war', path = 'odyssey_j_corruption_war.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_death', path = 'odyssey_j_corruption_death.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_apocalypse', path = 'odyssey_j_corruption_apocalypse.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_entropy', path = 'odyssey_j_corruption_entropy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_absolute_chaos', path = 'odyssey_j_corruption_absolute_chaos.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_the_end', path = 'odyssey_j_corruption_the_end.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_world_eater', path = 'odyssey_j_corruption_world_eater.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_corruption_the_entity', path = 'odyssey_j_corruption_the_entity.png', px = 71, py = 95 })

-- Enhancements Atlas
SMODS.Atlas({ key = 'enhancements', path = 'odyssey_enhancements.png', px = 71, py = 95 })

-- Deck Atlases (1-40)
SMODS.Atlas({ key = 'b_holographic', path = 'odyssey_d_holographic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_polychrome', path = 'odyssey_d_polychrome.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_foil', path = 'odyssey_d_foil.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_negative', path = 'odyssey_d_negative.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_glass', path = 'odyssey_d_glass.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_steel', path = 'odyssey_d_steel.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_stone', path = 'odyssey_d_stone.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_gold', path = 'odyssey_d_gold.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_lucky', path = 'odyssey_d_lucky.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_wild', path = 'odyssey_d_wild.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_mult', path = 'odyssey_d_mult.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_bonus', path = 'odyssey_d_bonus.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_double', path = 'odyssey_d_double.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_tiny', path = 'odyssey_d_tiny.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_ascension', path = 'odyssey_d_ascension.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_fall', path = 'odyssey_d_fall.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_avarice', path = 'odyssey_d_avarice.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_poverty', path = 'odyssey_d_poverty.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_gluttony', path = 'odyssey_d_gluttony.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_envy', path = 'odyssey_d_envy.png', px = 71, py = 95 })

-- Jokers 311-360 Added Automagically
SMODS.Atlas({ key = 'j_paradox_less_is_more', path = 'odyssey_j_paradox_less_is_more.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_weak_is_strong', path = 'odyssey_j_paradox_weak_is_strong.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_lose_to_win', path = 'odyssey_j_paradox_lose_to_win.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_useful_discard', path = 'odyssey_j_paradox_useful_discard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_crooked_hand', path = 'odyssey_j_paradox_crooked_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_reverse_flush', path = 'odyssey_j_paradox_reverse_flush.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_odd_pair', path = 'odyssey_j_paradox_odd_pair.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_empty_full_house', path = 'odyssey_j_paradox_empty_full_house.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_high_low', path = 'odyssey_j_paradox_high_low.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_seeing_blind', path = 'odyssey_j_paradox_seeing_blind.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_rich_poor', path = 'odyssey_j_paradox_rich_poor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_slow_fast', path = 'odyssey_j_paradox_slow_fast.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_pacifist_joker', path = 'odyssey_j_paradox_pacifist_joker.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_liars_paradox', path = 'odyssey_j_paradox_liar_s_paradox.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_value_inversion', path = 'odyssey_j_paradox_value_inversion.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_loud_silence', path = 'odyssey_j_paradox_loud_silence.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_failures_success', path = 'odyssey_j_paradox_failure_s_success.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_order_of_chaos', path = 'odyssey_j_paradox_order_of_chaos.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_all_or_nothing', path = 'odyssey_j_paradox_all_or_nothing.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_zenos_paradox', path = 'odyssey_j_paradox_zeno_s_paradox.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_alive_and_dead_cat', path = 'odyssey_j_paradox_alive_and_dead_cat.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_beginning_of_the_end', path = 'odyssey_j_paradox_beginning_of_the_end.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_square_circle', path = 'odyssey_j_paradox_square_circle.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_hot_cold', path = 'odyssey_j_paradox_hot_cold.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_past_future', path = 'odyssey_j_paradox_past_future.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_false_truth', path = 'odyssey_j_paradox_false_truth.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_mortal_immortal', path = 'odyssey_j_paradox_mortal_immortal.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_unlucky_luck', path = 'odyssey_j_paradox_unlucky_luck.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_shrinking_growth', path = 'odyssey_j_paradox_shrinking_growth.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_polarity_reversal', path = 'odyssey_j_paradox_polarity_reversal.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_bootstrap_paradox', path = 'odyssey_j_paradox_bootstrap_paradox.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_chicken_egg', path = 'odyssey_j_paradox_chicken_and_egg.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_ship_of_theseus', path = 'odyssey_j_paradox_ship_of_theseus.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_fermi_paradox', path = 'odyssey_j_paradox_fermi_s_paradox.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_evil_twin', path = 'odyssey_j_paradox_evil_twin.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_anti_joker', path = 'odyssey_j_paradox_anti_joker.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_reverse_logic', path = 'odyssey_j_paradox_reverse_logic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_impossible', path = 'odyssey_j_paradox_impossible.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_ouroboros', path = 'odyssey_j_paradox_ouroboros.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_paradox_grandfather_paradox', path = 'odyssey_j_paradox_grandfather_paradox.png', px = 71, py = 95 })

-- Anomaly Jokers (361-400)
SMODS.Atlas({ key = 'j_anomaly_spade_anomaly', path = 'odyssey_j_anomaly_spade_anomaly.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_heart_anomaly', path = 'odyssey_j_anomaly_heart_anomaly.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_club_anomaly', path = 'odyssey_j_anomaly_club_anomaly.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_diamond_anomaly', path = 'odyssey_j_anomaly_diamond_anomaly.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_rank_shift', path = 'odyssey_j_anomaly_rank_shift.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_numeric_inversion', path = 'odyssey_j_anomaly_numeric_inversion.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_chromatic_anomaly', path = 'odyssey_j_anomaly_chromatic_anomaly.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_material_anomaly', path = 'odyssey_j_anomaly_material_anomaly.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_anomalous_echo', path = 'odyssey_j_anomaly_anomalous_echo.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_phantom', path = 'odyssey_j_anomaly_phantom.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_instability', path = 'odyssey_j_anomaly_instability.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_distortion', path = 'odyssey_j_anomaly_distortion.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_interference', path = 'odyssey_j_anomaly_interference.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_static_noise', path = 'odyssey_j_anomaly_static_noise.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_lost_signal', path = 'odyssey_j_anomaly_lost_signal.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_audio_glitch', path = 'odyssey_j_anomaly_audio_glitch.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_gravitational_anomaly', path = 'odyssey_j_anomaly_gravitational_anomaly.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_temporal_anomaly', path = 'odyssey_j_anomaly_temporal_anomaly.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_spatial_anomaly', path = 'odyssey_j_anomaly_spatial_anomaly.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_unstable_wormhole', path = 'odyssey_j_anomaly_unstable_wormhole.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_augmented_reality', path = 'odyssey_j_anomaly_augmented_reality.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_simulation', path = 'odyssey_j_anomaly_simulation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_broken_code', path = 'odyssey_j_anomaly_broken_code.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_hidden_variable', path = 'odyssey_j_anomaly_hidden_variable.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_unhandled_exception', path = 'odyssey_j_anomaly_unhandled_exception.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_buffer_overflow', path = 'odyssey_j_anomaly_buffer_overflow.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_memory_dump', path = 'odyssey_j_anomaly_memory_dump.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_race_condition', path = 'odyssey_j_anomaly_race_condition.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_deadlock', path = 'odyssey_j_anomaly_deadlock.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_heisenbug', path = 'odyssey_j_anomaly_heisenbug.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_the_monolith', path = 'odyssey_j_anomaly_the_monolith.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_primordial_anomaly', path = 'odyssey_j_anomaly_primordial_anomaly.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_reality_rift', path = 'odyssey_j_anomaly_reality_rift.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_mirror_universe', path = 'odyssey_j_anomaly_mirror_universe.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_strange_matter', path = 'odyssey_j_anomaly_strange_matter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_phantom_energy', path = 'odyssey_j_anomaly_phantom_energy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_function_collapse', path = 'odyssey_j_anomaly_function_collapse.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_parity_error', path = 'odyssey_j_anomaly_parity_error.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_the_watcher', path = 'odyssey_j_anomaly_the_watcher.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_anomaly_fatal_error', path = 'odyssey_j_anomaly_fatal_error.png', px = 71, py = 95 })

-- Professions Group (501-550)
SMODS.Atlas({ key = 'j_professions_miner', path = 'odyssey_j_professions_miner.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_farmer', path = 'odyssey_j_professions_farmer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_fisherman', path = 'odyssey_j_professions_fisherman.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_chef', path = 'odyssey_j_professions_chef.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_doctor', path = 'odyssey_j_professions_doctor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_engineer', path = 'odyssey_j_professions_engineer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_architect', path = 'odyssey_j_professions_architect.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_astronomer', path = 'odyssey_j_professions_astronomer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_librarian', path = 'odyssey_j_professions_librarian.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_mailman', path = 'odyssey_j_professions_mailman.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_firefighter', path = 'odyssey_j_professions_firefighter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_police', path = 'odyssey_j_professions_police.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_judge', path = 'odyssey_j_professions_judge.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_lawyer', path = 'odyssey_j_professions_lawyer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_teacher', path = 'odyssey_j_professions_teacher.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_student', path = 'odyssey_j_professions_student.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_scientist', path = 'odyssey_j_professions_scientist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_artist', path = 'odyssey_j_professions_artist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_musician', path = 'odyssey_j_professions_musician.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_actor', path = 'odyssey_j_professions_actor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_surgeon', path = 'odyssey_j_professions_surgeon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_chemist', path = 'odyssey_j_professions_chemist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_geologist', path = 'odyssey_j_professions_geologist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_botanist', path = 'odyssey_j_professions_botanist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_zoologist', path = 'odyssey_j_professions_zoologist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_archaeologist', path = 'odyssey_j_professions_archaeologist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_historian', path = 'odyssey_j_professions_historian.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_futurist', path = 'odyssey_j_professions_futurist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_investor', path = 'odyssey_j_professions_investor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_banker', path = 'odyssey_j_professions_banker.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_cat_burglar', path = 'odyssey_j_professions_cat_burglar.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_spy', path = 'odyssey_j_professions_spy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_diplomat', path = 'odyssey_j_professions_diplomat.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_general', path = 'odyssey_j_professions_general.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_admiral', path = 'odyssey_j_professions_admiral.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_astronaut', path = 'odyssey_j_professions_astronaut.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_diver', path = 'odyssey_j_professions_diver.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_pilot', path = 'odyssey_j_professions_pilot.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_ceo', path = 'odyssey_j_professions_ceo.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_president', path = 'odyssey_j_professions_president.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_dictator', path = 'odyssey_j_professions_dictator.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_revolutionary', path = 'odyssey_j_professions_revolutionary.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_prophet', path = 'odyssey_j_professions_prophet.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_magician', path = 'odyssey_j_professions_magician.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_illusionist', path = 'odyssey_j_professions_illusionist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_hypnotist', path = 'odyssey_j_professions_hypnotist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_beast_tamer', path = 'odyssey_j_professions_beast_tamer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_foreman', path = 'odyssey_j_professions_foreman.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_guild_master', path = 'odyssey_j_professions_guild_master.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_professions_tycoon', path = 'odyssey_j_professions_tycoon.png', px = 71, py = 95 })

-- Economy Group (551-600)
SMODS.Atlas({ key = 'j_economy_piggy_bank', path = 'odyssey_j_economy_piggy_bank.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_angel_investor', path = 'odyssey_j_economy_angel_investor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_clearance_sale', path = 'odyssey_j_economy_clearance_sale.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_coupon', path = 'odyssey_j_economy_coupon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_rebate', path = 'odyssey_j_economy_rebate.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_service_fee', path = 'odyssey_j_economy_service_fee.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_tip_jar', path = 'odyssey_j_economy_tip_jar.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_black_market', path = 'odyssey_j_economy_black_market.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_loan_shark', path = 'odyssey_j_economy_loan_shark.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_inheritance', path = 'odyssey_j_economy_inheritance.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_tithe', path = 'odyssey_j_economy_tithe.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_inflation', path = 'odyssey_j_economy_inflation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_deflation', path = 'odyssey_j_economy_deflation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_pawn_shop', path = 'odyssey_j_economy_pawn_shop.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_treasure_hunt', path = 'odyssey_j_economy_treasure_hunt.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_gold_mine', path = 'odyssey_j_economy_gold_mine.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_unionizer', path = 'odyssey_j_economy_unionizer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_accountant', path = 'odyssey_j_economy_accountant.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_auditor', path = 'odyssey_j_economy_auditor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_capitalist', path = 'odyssey_j_economy_capitalist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_invisible_hand', path = 'odyssey_j_economy_invisible_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_economic_bubble', path = 'odyssey_j_economy_economic_bubble.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_cryptocurrency', path = 'odyssey_j_economy_cryptocurrency.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_income_tax', path = 'odyssey_j_economy_income_tax.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_money_laundering', path = 'odyssey_j_economy_money_laundering.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_bribery', path = 'odyssey_j_economy_bribery.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_hedge_fund', path = 'odyssey_j_economy_hedge_fund.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_monopoly', path = 'odyssey_j_economy_monopoly.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_recession', path = 'odyssey_j_economy_recession.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_stimulus_package', path = 'odyssey_j_economy_stimulus_package.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_lottery', path = 'odyssey_j_economy_lottery.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_insurance', path = 'odyssey_j_economy_insurance.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_retirement', path = 'odyssey_j_economy_retirement.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_venture_capital', path = 'odyssey_j_economy_venture_capital.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_credit_card', path = 'odyssey_j_economy_credit_card.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_compound_interest', path = 'odyssey_j_economy_compound_interest.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_day_trader', path = 'odyssey_j_economy_day_trader.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_oil_tycoon', path = 'odyssey_j_economy_oil_tycoon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_the_great_depression', path = 'odyssey_j_economy_the_great_depression.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_midas', path = 'odyssey_j_economy_midas.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_philosophers_stone', path = 'odyssey_j_economy_philosopher_s_stone.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_money_printer', path = 'odyssey_j_economy_money_printer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_central_bank', path = 'odyssey_j_economy_central_bank.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_mercenary', path = 'odyssey_j_economy_mercenary.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_make_it_rain', path = 'odyssey_j_economy_make_it_rain.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_blood_diamond', path = 'odyssey_j_economy_blood_diamond.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_fools_gold', path = 'odyssey_j_economy_fool_s_gold.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_utopia', path = 'odyssey_j_economy_utopia.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_mammon', path = 'odyssey_j_economy_mammon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_markets_hand', path = 'odyssey_j_economy_the_market_s_hand.png', px = 71, py = 95 })

SMODS.Atlas({ key = 'b_wrath', path = 'odyssey_d_wrath.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_sloth', path = 'odyssey_d_sloth.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_lust', path = 'odyssey_d_lust.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_pride', path = 'odyssey_d_pride.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_alpha', path = 'odyssey_d_alpha.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_omega', path = 'odyssey_d_omega.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_zero', path = 'odyssey_d_zero.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_fibonacci', path = 'odyssey_d_fibonacci.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_prime', path = 'odyssey_d_prime.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_odyssey', path = 'odyssey_d_odyssey.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_fractal', path = 'odyssey_d_fractal.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_mirror', path = 'odyssey_d_mirror.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_ghost', path = 'odyssey_d_ghost.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_vampire', path = 'odyssey_d_vampire.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_zombie', path = 'odyssey_d_zombie.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_cyborg', path = 'odyssey_d_cyborg.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_alien', path = 'odyssey_d_alien.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_mutant', path = 'odyssey_d_mutant.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_clone', path = 'odyssey_d_clone.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_invisible', path = 'odyssey_d_invisible.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_ethereal', path = 'odyssey_d_ethereal.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_radioactive', path = 'odyssey_d_radioactive.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_magnetic', path = 'odyssey_d_magnetic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_frozen', path = 'odyssey_d_frozen.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_volcanic', path = 'odyssey_d_volcanic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_oceanic', path = 'odyssey_d_oceanic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_solar', path = 'odyssey_d_solar.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_lunar', path = 'odyssey_d_lunar.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_stellar', path = 'odyssey_d_stellar.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_mystic', path = 'odyssey_d_mystic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_tech', path = 'odyssey_d_tech.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_primitive', path = 'odyssey_d_primitive.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_arcane', path = 'odyssey_d_arcane.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_celestial', path = 'odyssey_d_celestial.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_spectral', path = 'odyssey_d_spectral.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_standard', path = 'odyssey_d_standard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_buffoon', path = 'odyssey_d_buffoon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_mercenary', path = 'odyssey_d_mercenary.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_investor', path = 'odyssey_d_investor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_minimalist_ii', path = 'odyssey_d_minimalist_ii.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_maximalist_ii', path = 'odyssey_d_maximalist_ii.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_chaotic_ii', path = 'odyssey_d_chaotic_ii.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_ordered_ii', path = 'odyssey_d_ordered_ii.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_lucky_ii', path = 'odyssey_d_lucky_ii.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_unlucky', path = 'odyssey_d_unlucky.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_midas', path = 'odyssey_d_midas.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_arthur', path = 'odyssey_d_arthur.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_merlin', path = 'odyssey_d_merlin.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_dragon', path = 'odyssey_d_dragon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_phoenix', path = 'odyssey_d_phoenix.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_hydra', path = 'odyssey_d_hydra.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_chimera', path = 'odyssey_d_chimera.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_griffin', path = 'odyssey_d_griffin.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_unicorn', path = 'odyssey_d_unicorn.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_kraken', path = 'odyssey_d_kraken.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_leviathan', path = 'odyssey_d_leviathan.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_behemoth', path = 'odyssey_d_behemoth.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_titan', path = 'odyssey_d_titan.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_gnome', path = 'odyssey_d_gnome.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'b_the_creator', path = 'odyssey_d_the_creator.png', px = 71, py = 95 })

-- HAND AND DISCARD MANIPULATION
SMODS.Atlas({ key = 'j_hand_and_discard_extra_hand', path = 'odyssey_j_hand_and_discard_extra_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_extra_discard', path = 'odyssey_j_hand_and_discard_extra_discard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_recycling', path = 'odyssey_j_hand_and_discard_recycling.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_trash_can', path = 'odyssey_j_hand_and_discard_trash_can.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_full_hand', path = 'odyssey_j_hand_and_discard_full_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_empty_hand', path = 'odyssey_j_hand_and_discard_empty_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_juggler', path = 'odyssey_j_hand_and_discard_juggler.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_street_magician', path = 'odyssey_j_hand_and_discard_street_magician.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_cards_up_sleeve', path = 'odyssey_j_hand_and_discard_cards_up_sleeve.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_dealer', path = 'odyssey_j_hand_and_discard_dealer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_auto_shuffler', path = 'odyssey_j_hand_and_discard_auto_shuffler.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_deck_cut', path = 'odyssey_j_hand_and_discard_deck_cut.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_ghost_hand', path = 'odyssey_j_hand_and_discard_ghost_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_tactical_discard', path = 'odyssey_j_hand_and_discard_tactical_discard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_steady_hand', path = 'odyssey_j_hand_and_discard_steady_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_shaky_hand', path = 'odyssey_j_hand_and_discard_shaky_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_boxing_glove', path = 'odyssey_j_hand_and_discard_boxing_glove.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_silk_glove', path = 'odyssey_j_hand_and_discard_silk_glove.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_gauntlet', path = 'odyssey_j_hand_and_discard_gauntlet.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_magic_finger', path = 'odyssey_j_hand_and_discard_magic_finger.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_hand_of_midas', path = 'odyssey_j_hand_and_discard_hand_of_midas.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_iron_hand', path = 'odyssey_j_hand_and_discard_iron_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_stone_hand', path = 'odyssey_j_hand_and_discard_stone_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_glass_hand', path = 'odyssey_j_hand_and_discard_glass_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_helping_hand', path = 'odyssey_j_hand_and_discard_helping_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_dead_hand', path = 'odyssey_j_hand_and_discard_dead_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_divine_hand', path = 'odyssey_j_hand_and_discard_divine_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_cursed_hand', path = 'odyssey_j_hand_and_discard_cursed_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_perfect_discard', path = 'odyssey_j_hand_and_discard_perfect_discard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_strategic_discard', path = 'odyssey_j_hand_and_discard_strategic_discard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_gold_discard', path = 'odyssey_j_hand_and_discard_gold_discard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_steel_discard', path = 'odyssey_j_hand_and_discard_steel_discard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_glass_discard', path = 'odyssey_j_hand_and_discard_glass_discard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_mirrored_hand', path = 'odyssey_j_hand_and_discard_mirrored_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_shadow_hand', path = 'odyssey_j_hand_and_discard_shadow_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_quick_hand', path = 'odyssey_j_hand_and_discard_quick_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_slow_hand', path = 'odyssey_j_hand_and_discard_slow_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_ambidextrous', path = 'odyssey_j_hand_and_discard_ambidextrous.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_hand_of_god', path = 'odyssey_j_hand_and_discard_hand_of_god.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_devils_hand', path = 'odyssey_j_hand_and_discard_devil_s_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_kings_hand', path = 'odyssey_j_hand_and_discard_king_s_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_queens_hand', path = 'odyssey_j_hand_and_discard_queen_s_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_jacks_hand', path = 'odyssey_j_hand_and_discard_jack_s_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_aces_hand', path = 'odyssey_j_hand_and_discard_ace_s_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_infinite_hand', path = 'odyssey_j_hand_and_discard_infinite_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_infinite_discard', path = 'odyssey_j_hand_and_discard_infinite_discard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_supreme_hand', path = 'odyssey_j_hand_and_discard_supreme_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_void_hand', path = 'odyssey_j_hand_and_discard_void_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_the_creator', path = 'odyssey_j_hand_and_discard_the_creator.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_the_destroyer', path = 'odyssey_j_hand_and_discard_the_destroyer.png', px = 71, py = 95 })

-- PROBABILITY AND LUCK
SMODS.Atlas({ key = 'j_luck_and_probability_four_leaf_clover', path = 'odyssey_j_luck_and_probability_four_leaf_clover.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_rabbit_s_foot', path = 'odyssey_j_luck_and_probability_rabbit_s_foot.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_horseshoe', path = 'odyssey_j_luck_and_probability_horseshoe.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_d6_die', path = 'odyssey_j_luck_and_probability_d6_die.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_d20_die', path = 'odyssey_j_luck_and_probability_d20_die.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_coin_flip', path = 'odyssey_j_luck_and_probability_coin_flip.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_safe_bet', path = 'odyssey_j_luck_and_probability_safe_bet.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_risky_bet', path = 'odyssey_j_luck_and_probability_risky_bet.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_raffle', path = 'odyssey_j_luck_and_probability_raffle.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_bingo', path = 'odyssey_j_luck_and_probability_bingo.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_jackpot', path = 'odyssey_j_luck_and_probability_jackpot.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_slot_machine', path = 'odyssey_j_luck_and_probability_slot_machine.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_sports_betting', path = 'odyssey_j_luck_and_probability_sports_betting.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_scratch_card', path = 'odyssey_j_luck_and_probability_scratch_card.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_fortune_cookie', path = 'odyssey_j_luck_and_probability_fortune_cookie.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_amulet', path = 'odyssey_j_luck_and_probability_amulet.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_talisman', path = 'odyssey_j_luck_and_probability_talisman.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_dreamcatcher', path = 'odyssey_j_luck_and_probability_dreamcatcher.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_gargoyle', path = 'odyssey_j_luck_and_probability_gargoyle.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_evil_eye', path = 'odyssey_j_luck_and_probability_evil_eye.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_figa', path = 'odyssey_j_luck_and_probability_figa.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_luck_manipulator', path = 'odyssey_j_luck_and_probability_luck_manipulator.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_dice_master', path = 'odyssey_j_luck_and_probability_dice_master.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_lady_luck', path = 'odyssey_j_luck_and_probability_lady_luck.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_underdog', path = 'odyssey_j_luck_and_probability_underdog.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_black_cat', path = 'odyssey_j_luck_and_probability_black_cat.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_broken_mirror', path = 'odyssey_j_luck_and_probability_broken_mirror.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_three_leaf_clover', path = 'odyssey_j_luck_and_probability_three_leaf_clover.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_beginner_s_luck', path = 'odyssey_j_luck_and_probability_beginner_s_luck.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_destiny', path = 'odyssey_j_luck_and_probability_destiny.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_karma', path = 'odyssey_j_luck_and_probability_karma.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_wheel_of_fate', path = 'odyssey_j_luck_and_probability_wheel_of_fate.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_oracle', path = 'odyssey_j_luck_and_probability_oracle.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_prophecy', path = 'odyssey_j_luck_and_probability_prophecy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_blind_luck', path = 'odyssey_j_luck_and_probability_blind_luck.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_chance', path = 'odyssey_j_luck_and_probability_chance.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_serendipity', path = 'odyssey_j_luck_and_probability_serendipity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_miracle', path = 'odyssey_j_luck_and_probability_miracle.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_divinity', path = 'odyssey_j_luck_and_probability_divinity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_goddess_of_fortune', path = 'odyssey_j_luck_and_probability_goddess_of_fortune.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_controlled_chaos', path = 'odyssey_j_luck_and_probability_controlled_chaos.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_infinite_luck', path = 'odyssey_j_luck_and_probability_infinite_luck.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_improbability', path = 'odyssey_j_luck_and_probability_improbability.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_zero_entropy', path = 'odyssey_j_luck_and_probability_zero_entropy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_the_chosen_one', path = 'odyssey_j_luck_and_probability_the_chosen_one.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_holy_grail', path = 'odyssey_j_luck_and_probability_holy_grail.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_golden_midas_hand', path = 'odyssey_j_luck_and_probability_golden_midas_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_cosmic_clover', path = 'odyssey_j_luck_and_probability_cosmic_clover.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_777', path = 'odyssey_j_luck_and_probability_777.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_fortuna', path = 'odyssey_j_luck_and_probability_fortuna.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_luck_and_probability_manifest_destiny', path = 'odyssey_j_luck_and_probability_manifest_destiny.png', px = 71, py = 95 })

----------------------------------------------
-- TRANSFORMATIONS & MUTATIONS (J751-J800)
----------------------------------------------
SMODS.Atlas({ key = 'j_transformations_chameleon', path = 'odyssey_j_transformations_chameleon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_mimic', path = 'odyssey_j_transformations_mimic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_shapeshifter', path = 'odyssey_j_transformations_shapeshifter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_doppelganger', path = 'odyssey_j_transformations_doppelganger.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_magic_mirror', path = 'odyssey_j_transformations_magic_mirror.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_prism', path = 'odyssey_j_transformations_prism.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_catalyst', path = 'odyssey_j_transformations_catalyst.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_evolution', path = 'odyssey_j_transformations_evolution.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_devolution', path = 'odyssey_j_transformations_devolution.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_transmuter', path = 'odyssey_j_transformations_transmuter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_converter', path = 'odyssey_j_transformations_converter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_basic_alchemy', path = 'odyssey_j_transformations_basic_alchemy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_polymorph', path = 'odyssey_j_transformations_polymorph.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_mask', path = 'odyssey_j_transformations_mask.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_disguise', path = 'odyssey_j_transformations_disguise.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_costume', path = 'odyssey_j_transformations_costume.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_makeup', path = 'odyssey_j_transformations_makeup.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_wig', path = 'odyssey_j_transformations_wig.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_fake_beard', path = 'odyssey_j_transformations_fake_beard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_shadow', path = 'odyssey_j_transformations_shadow.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_vampire', path = 'odyssey_j_transformations_vampire.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_werewolf', path = 'odyssey_j_transformations_werewolf.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_frankenstein', path = 'odyssey_j_transformations_frankenstein.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_zombie', path = 'odyssey_j_transformations_zombie.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_phantom_of_the_opera', path = 'odyssey_j_transformations_phantom_of_the_opera.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_jekyll_hyde', path = 'odyssey_j_transformations_jekyll_hyde.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_mutant', path = 'odyssey_j_transformations_mutant.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_hybrid', path = 'odyssey_j_transformations_hybrid.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_chimera', path = 'odyssey_j_transformations_chimera.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_hydra', path = 'odyssey_j_transformations_hydra.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_dark_phoenix', path = 'odyssey_j_transformations_dark_phoenix.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_basilisk', path = 'odyssey_j_transformations_basilisk.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_medusa', path = 'odyssey_j_transformations_medusa.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_siren', path = 'odyssey_j_transformations_siren.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_griffin', path = 'odyssey_j_transformations_griffin.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_dragon', path = 'odyssey_j_transformations_dragon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_unicorn', path = 'odyssey_j_transformations_unicorn.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_centaur', path = 'odyssey_j_transformations_centaur.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_metamorphosis', path = 'odyssey_j_transformations_metamorphosis.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_transcendence', path = 'odyssey_j_transformations_transcendence.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_ascension', path = 'odyssey_j_transformations_ascension.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_apotheosis', path = 'odyssey_j_transformations_apotheosis.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_singularity', path = 'odyssey_j_transformations_singularity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_big_bang', path = 'odyssey_j_transformations_big_bang.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_reincarnation', path = 'odyssey_j_transformations_reincarnation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_final_evolution', path = 'odyssey_j_transformations_final_evolution.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_perfect_form', path = 'odyssey_j_transformations_perfect_form.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_primal_chaos', path = 'odyssey_j_transformations_primal_chaos.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_the_changeling', path = 'odyssey_j_transformations_the_changeling.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_transformations_proteus', path = 'odyssey_j_transformations_proteus.png', px = 71, py = 95 })

----------------------------------------------
-- SOCIAL & META INTERACTION (50 sprites)
----------------------------------------------
SMODS.Atlas({ key = 'j_social_audience', path = 'odyssey_j_social_audience.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_critic', path = 'odyssey_j_social_critic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_fan', path = 'odyssey_j_social_fan.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_hater', path = 'odyssey_j_social_hater.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_streamer', path = 'odyssey_j_social_streamer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_chat', path = 'odyssey_j_social_chat.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_moderator', path = 'odyssey_j_social_moderator.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_troll', path = 'odyssey_j_social_troll.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_lurker', path = 'odyssey_j_social_lurker.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_subscriber', path = 'odyssey_j_social_subscriber.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_sponsor', path = 'odyssey_j_social_sponsor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_ad', path = 'odyssey_j_social_ad.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_clickbait', path = 'odyssey_j_social_clickbait.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_viral', path = 'odyssey_j_social_viral.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_meme', path = 'odyssey_j_social_meme.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_emoji', path = 'odyssey_j_social_emoji.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_hashtag', path = 'odyssey_j_social_hashtag.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_trending', path = 'odyssey_j_social_trending.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_canceled', path = 'odyssey_j_social_canceled.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_influencer', path = 'odyssey_j_social_influencer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_fourth_wall', path = 'odyssey_j_social_fourth_wall.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_developer', path = 'odyssey_j_social_developer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_beta_tester', path = 'odyssey_j_social_beta_tester.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_speedrunner', path = 'odyssey_j_social_speedrunner.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_completionist', path = 'odyssey_j_social_completionist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_lore_master', path = 'odyssey_j_social_lore_master.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_min_maxer', path = 'odyssey_j_social_min_maxer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_casual', path = 'odyssey_j_social_casual.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_tryhard', path = 'odyssey_j_social_tryhard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_rage_quit', path = 'odyssey_j_social_rage_quit.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_save_scummer', path = 'odyssey_j_social_save_scummer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_modder', path = 'odyssey_j_social_modder.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_pirate', path = 'odyssey_j_social_pirate.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_drm', path = 'odyssey_j_social_drm.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_microtransaction', path = 'odyssey_j_social_microtransaction.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_dlc', path = 'odyssey_j_social_dlc.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_patch_notes', path = 'odyssey_j_social_patch_notes.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_easter_egg', path = 'odyssey_j_social_easter_egg.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_game_master', path = 'odyssey_j_social_game_master.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_admin', path = 'odyssey_j_social_admin.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_god_mode', path = 'odyssey_j_social_god_mode.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_noclip', path = 'odyssey_j_social_noclip.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_infinite_ammo', path = 'odyssey_j_social_infinite_ammo.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_aimbot', path = 'odyssey_j_social_aimbot.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_wallhack', path = 'odyssey_j_social_wallhack.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_lag_switch', path = 'odyssey_j_social_lag_switch.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_ban_hammer', path = 'odyssey_j_social_ban_hammer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_credits', path = 'odyssey_j_social_credits.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_the_player', path = 'odyssey_j_social_the_player.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_social_localthunk', path = 'odyssey_j_social_localthunk.png', px = 71, py = 95 })

-- POSITIONING & ADJACENCY J851-J900
SMODS.Atlas({ key = 'j_pos_left_neighbor', path = 'odyssey_j_pos_left_neighbor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_right_neighbor', path = 'odyssey_j_pos_right_neighbor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_bodyguard', path = 'odyssey_j_pos_bodyguard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_leader', path = 'odyssey_j_pos_leader.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_follower', path = 'odyssey_j_pos_follower.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_center_stage', path = 'odyssey_j_pos_center_stage.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_outsider', path = 'odyssey_j_pos_outsider.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_pair', path = 'odyssey_j_pos_pair.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_trio', path = 'odyssey_j_pos_trio.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_chain', path = 'odyssey_j_pos_chain.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_magnet', path = 'odyssey_j_pos_magnet.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_repulsor', path = 'odyssey_j_pos_repulsor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_mirror', path = 'odyssey_j_pos_mirror.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_prism', path = 'odyssey_j_pos_prism.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_lens', path = 'odyssey_j_pos_lens.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_amplifier', path = 'odyssey_j_pos_amplifier.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_silencer', path = 'odyssey_j_pos_silencer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_battery', path = 'odyssey_j_pos_battery.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_ground_wire', path = 'odyssey_j_pos_ground_wire.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_connector', path = 'odyssey_j_pos_connector.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_battle_formation', path = 'odyssey_j_pos_battle_formation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_frontline', path = 'odyssey_j_pos_frontline.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_backline', path = 'odyssey_j_pos_backline.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_flank', path = 'odyssey_j_pos_flank.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_siege', path = 'odyssey_j_pos_siege.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_isolation', path = 'odyssey_j_pos_isolation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_clumping', path = 'odyssey_j_pos_clumping.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_musical_chairs', path = 'odyssey_j_pos_musical_chairs.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_carousel', path = 'odyssey_j_pos_carousel.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_rook', path = 'odyssey_j_pos_rook.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_bishop', path = 'odyssey_j_pos_bishop.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_knight', path = 'odyssey_j_pos_knight.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_king', path = 'odyssey_j_pos_king.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_queen', path = 'odyssey_j_pos_queen.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_pawn', path = 'odyssey_j_pos_pawn.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_castling', path = 'odyssey_j_pos_castling.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_check', path = 'odyssey_j_pos_check.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_checkmate', path = 'odyssey_j_pos_checkmate.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_pentagram', path = 'odyssey_j_pos_pentagram.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_alignment', path = 'odyssey_j_pos_alignment.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_disorder', path = 'odyssey_j_pos_disorder.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_symmetry', path = 'odyssey_j_pos_symmetry.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_positional_chaos', path = 'odyssey_j_pos_positional_chaos.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_black_hole', path = 'odyssey_j_pos_black_hole.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_supernova', path = 'odyssey_j_pos_supernova.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_galaxy', path = 'odyssey_j_pos_galaxy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_universe', path = 'odyssey_j_pos_universe.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_multiverse', path = 'odyssey_j_pos_multiverse.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_the_architect', path = 'odyssey_j_pos_the_architect.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_pos_the_conductor', path = 'odyssey_j_pos_the_conductor.png', px = 71, py = 95 })

-- CONDITIONS & LOGIC (901-950)
SMODS.Atlas({ key = 'j_cond_hair_trigger', path = 'odyssey_j_cond_hair_trigger.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_heavy_trigger', path = 'odyssey_j_cond_heavy_trigger.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_conditional', path = 'odyssey_j_cond_conditional.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_if', path = 'odyssey_j_cond_if.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_else', path = 'odyssey_j_cond_else.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_while', path = 'odyssey_j_cond_while.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_for_loop', path = 'odyssey_j_cond_for_loop.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_switch', path = 'odyssey_j_cond_switch.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_break', path = 'odyssey_j_cond_break.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_continue', path = 'odyssey_j_cond_continue.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_return', path = 'odyssey_j_cond_return.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_print', path = 'odyssey_j_cond_print.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_input', path = 'odyssey_j_cond_input.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_output', path = 'odyssey_j_cond_output.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_variable', path = 'odyssey_j_cond_variable.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_constant', path = 'odyssey_j_cond_constant.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_function', path = 'odyssey_j_cond_function.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_class', path = 'odyssey_j_cond_class.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_object', path = 'odyssey_j_cond_object.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_array', path = 'odyssey_j_cond_array.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_boolean', path = 'odyssey_j_cond_boolean.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_integer', path = 'odyssey_j_cond_integer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_float', path = 'odyssey_j_cond_float.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_string', path = 'odyssey_j_cond_string.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_char', path = 'odyssey_j_cond_char.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_null', path = 'odyssey_j_cond_null.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_undefined', path = 'odyssey_j_cond_undefined.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_nan', path = 'odyssey_j_cond_nan.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_infinity', path = 'odyssey_j_cond_infinity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_exception', path = 'odyssey_j_cond_exception.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_try_catch', path = 'odyssey_j_cond_try_catch.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_async', path = 'odyssey_j_cond_async.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_await', path = 'odyssey_j_cond_await.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_promise', path = 'odyssey_j_cond_promise.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_callback', path = 'odyssey_j_cond_callback.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_recursion', path = 'odyssey_j_cond_recursion.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_stack', path = 'odyssey_j_cond_stack.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_heap', path = 'odyssey_j_cond_heap.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_algorithm', path = 'odyssey_j_cond_algorithm.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_ai', path = 'odyssey_j_cond_ai.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_neural_net', path = 'odyssey_j_cond_neural_net.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_deep_learning', path = 'odyssey_j_cond_deep_learning.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_machine_learning', path = 'odyssey_j_cond_machine_learning.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_big_data', path = 'odyssey_j_cond_big_data.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_blockchain', path = 'odyssey_j_cond_blockchain.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_nft', path = 'odyssey_j_cond_nft.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_metaverse', path = 'odyssey_j_cond_metaverse.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_web3', path = 'odyssey_j_cond_web3.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_turing_complete', path = 'odyssey_j_cond_turing_complete.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_cond_tech_singularity', path = 'odyssey_j_cond_tech_singularity.png', px = 71, py = 95 })

-- FINAL & SPECIALS (951-1000)
SMODS.Atlas({ key = 'j_final_the_end', path = 'odyssey_j_final_the_end.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_the_beginning', path = 'odyssey_j_final_the_beginning.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_the_middle', path = 'odyssey_j_final_the_middle.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_prologue', path = 'odyssey_j_final_prologue.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_epilogue', path = 'odyssey_j_final_epilogue.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_chapter1', path = 'odyssey_j_final_chapter1.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_chapter2', path = 'odyssey_j_final_chapter2.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_chapter3', path = 'odyssey_j_final_chapter3.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_climax', path = 'odyssey_j_final_climax.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_plot_twist', path = 'odyssey_j_final_plot_twist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_hero', path = 'odyssey_j_final_hero.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_sidekick', path = 'odyssey_j_final_sidekick.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_mentor', path = 'odyssey_j_final_mentor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_rival', path = 'odyssey_j_final_rival.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_love', path = 'odyssey_j_final_love.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_hate', path = 'odyssey_j_final_hate.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_peace', path = 'odyssey_j_final_peace.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_war', path = 'odyssey_j_final_war.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_death', path = 'odyssey_j_final_death.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_rebirth', path = 'odyssey_j_final_rebirth.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_karma', path = 'odyssey_j_final_karma.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_dharma', path = 'odyssey_j_final_dharma.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_nirvana', path = 'odyssey_j_final_nirvana.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_samsara', path = 'odyssey_j_final_samsara.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_light', path = 'odyssey_j_final_light.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_darkness', path = 'odyssey_j_final_darkness.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_zen', path = 'odyssey_j_final_zen.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_tao', path = 'odyssey_j_final_tao.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_yin', path = 'odyssey_j_final_yin.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_yang', path = 'odyssey_j_final_yang.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_chi', path = 'odyssey_j_final_chi.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_chakra', path = 'odyssey_j_final_chakra.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_mantra', path = 'odyssey_j_final_mantra.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_mandala', path = 'odyssey_j_final_mandala.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_lotus', path = 'odyssey_j_final_lotus.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_om', path = 'odyssey_j_final_om.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_guru', path = 'odyssey_j_final_guru.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_yogi', path = 'odyssey_j_final_yogi.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_avatar', path = 'odyssey_j_final_avatar.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_enlightenment', path = 'odyssey_j_final_enlightenment.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_ascension', path = 'odyssey_j_final_ascension.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_transcendence', path = 'odyssey_j_final_transcendence.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_divinity', path = 'odyssey_j_final_divinity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_omniscience', path = 'odyssey_j_final_omniscience.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_omnipotence', path = 'odyssey_j_final_omnipotence.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_omnipresence', path = 'odyssey_j_final_omnipresence.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_eternity', path = 'odyssey_j_final_eternity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_infinity', path = 'odyssey_j_final_infinity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_absolute', path = 'odyssey_j_final_absolute.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_the_creator', path = 'odyssey_j_final_the_creator.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_odyssey', path = 'odyssey_j_final_odyssey.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_villain', path = 'odyssey_j_final_villain.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_king_of_kings', path = 'odyssey_j_tribal_king_of_kings.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_tribal_god_of_war', path = 'odyssey_j_tribal_god_of_war.png', px = 71, py = 95 })

----------------------------------------------
-- VOUCHERS (200 sprites)
----------------------------------------------
SMODS.Atlas({ key = 'v_absolute_zero', path = 'odyssey_v_absolute_zero.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_accumulator', path = 'odyssey_v_accumulator.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_ace', path = 'odyssey_v_ace.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_acrobat', path = 'odyssey_v_acrobat.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_alchemist', path = 'odyssey_v_alchemist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_alloy', path = 'odyssey_v_alloy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_amulet', path = 'odyssey_v_amulet.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_anvil', path = 'odyssey_v_anvil.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_apprentice', path = 'odyssey_v_apprentice.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_archaeologist', path = 'odyssey_v_archaeologist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_archives', path = 'odyssey_v_archives.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_artist', path = 'odyssey_v_artist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_asteroid', path = 'odyssey_v_asteroid.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_astronomer', path = 'odyssey_v_astronomer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_atlas', path = 'odyssey_v_atlas.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_bailout', path = 'odyssey_v_bailout.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_bank', path = 'odyssey_v_bank.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_bishop', path = 'odyssey_v_bishop.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_black_market', path = 'odyssey_v_black_market.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_blower', path = 'odyssey_v_blower.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_box', path = 'odyssey_v_box.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_card', path = 'odyssey_v_card.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_cartographer', path = 'odyssey_v_cartographer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_casino', path = 'odyssey_v_casino.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_ceramic', path = 'odyssey_v_ceramic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_chip', path = 'odyssey_v_chip.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_circus', path = 'odyssey_v_circus.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_cloning', path = 'odyssey_v_cloning.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_cloth', path = 'odyssey_v_cloth.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_collector', path = 'odyssey_v_collector.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_comet_1', path = 'odyssey_v_comet_1.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_compass', path = 'odyssey_v_compass.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_contraband', path = 'odyssey_v_contraband.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_converter', path = 'odyssey_v_converter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_core', path = 'odyssey_v_core.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_cosmologist', path = 'odyssey_v_cosmologist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_coupon', path = 'odyssey_v_coupon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_crystal', path = 'odyssey_v_crystal.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_crystal_forge', path = 'odyssey_v_crystal_forge.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_curator', path = 'odyssey_v_curator.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_d20', path = 'odyssey_v_d20.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_dark_energy', path = 'odyssey_v_dark_energy.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_dark_matter', path = 'odyssey_v_dark_matter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_darkness', path = 'odyssey_v_darkness.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_deck', path = 'odyssey_v_deck.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_deep_space_obs', path = 'odyssey_v_deep_space_obs.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_destroyer', path = 'odyssey_v_destroyer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_diamond', path = 'odyssey_v_diamond.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_dice', path = 'odyssey_v_dice.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_distopian', path = 'odyssey_v_distopian.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_doppelganger', path = 'odyssey_v_doppelganger.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_dreamer', path = 'odyssey_v_dreamer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_dyson_sphere', path = 'odyssey_v_dyson_sphere.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_earth', path = 'odyssey_v_earth.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_electromagnet', path = 'odyssey_v_electromagnet.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_emerald', path = 'odyssey_v_emerald.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_empress', path = 'odyssey_v_empress.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_engineer', path = 'odyssey_v_engineer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_essentialist', path = 'odyssey_v_essentialist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_explorer', path = 'odyssey_v_explorer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_falling_star', path = 'odyssey_v_falling_star.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_feather', path = 'odyssey_v_feather.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_fire', path = 'odyssey_v_fire.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_fool', path = 'odyssey_v_fool.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_force_field', path = 'odyssey_v_force_field.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_forest', path = 'odyssey_v_forest.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_founder', path = 'odyssey_v_founder.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_fuel_tank', path = 'odyssey_v_fuel_tank.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_futurist', path = 'odyssey_v_futurist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_gambler', path = 'odyssey_v_gambler.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_gem', path = 'odyssey_v_gem.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_giga_mult', path = 'odyssey_v_giga_mult.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_glass_2', path = 'odyssey_v_glass_2.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_glow', path = 'odyssey_v_glow.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_god', path = 'odyssey_v_god.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_gold_coupon', path = 'odyssey_v_gold_coupon.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_gold_plating', path = 'odyssey_v_gold_plating.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_gold_ticket', path = 'odyssey_v_gold_ticket.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_gps', path = 'odyssey_v_gps.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_hammer', path = 'odyssey_v_hammer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_hedge_fund', path = 'odyssey_v_hedge_fund.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_high_roller', path = 'odyssey_v_high_roller.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_historian', path = 'odyssey_v_historian.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_hurricane', path = 'odyssey_v_hurricane.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_hyperdrive', path = 'odyssey_v_hyperdrive.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_ice', path = 'odyssey_v_ice.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_illusionist', path = 'odyssey_v_illusionist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_inferno', path = 'odyssey_v_inferno.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_inkwell', path = 'odyssey_v_inkwell.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_insurance', path = 'odyssey_v_insurance.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_investment', path = 'odyssey_v_investment.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_iridium', path = 'odyssey_v_iridium.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_jester', path = 'odyssey_v_jester.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_jewelry', path = 'odyssey_v_jewelry.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_joker', path = 'odyssey_v_joker.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_juggler', path = 'odyssey_v_juggler.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_key', path = 'odyssey_v_key.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_king', path = 'odyssey_v_king.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_knight', path = 'odyssey_v_knight.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_laboratory', path = 'odyssey_v_laboratory.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_laser', path = 'odyssey_v_laser.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_lens', path = 'odyssey_v_lens.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_library', path = 'odyssey_v_library.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_light', path = 'odyssey_v_light.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_lightning', path = 'odyssey_v_lightning.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_liquidation', path = 'odyssey_v_liquidation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_lock', path = 'odyssey_v_lock.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_lucid', path = 'odyssey_v_lucid.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_magic_mirror', path = 'odyssey_v_magic_mirror.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_magician', path = 'odyssey_v_magician.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_magnet', path = 'odyssey_v_magnet.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_map', path = 'odyssey_v_map.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_master', path = 'odyssey_v_master.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_master_key', path = 'odyssey_v_master_key.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_masterpiece', path = 'odyssey_v_masterpiece.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_maximalist', path = 'odyssey_v_maximalist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_mechanic', path = 'odyssey_v_mechanic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_mega_mult', path = 'odyssey_v_mega_mult.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_member', path = 'odyssey_v_member.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_metal', path = 'odyssey_v_metal.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_meteor', path = 'odyssey_v_meteor.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_microscope', path = 'odyssey_v_microscope.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_midas_touch', path = 'odyssey_v_midas_touch.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_mimic', path = 'odyssey_v_mimic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_minimalist', path = 'odyssey_v_minimalist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_mountain', path = 'odyssey_v_mountain.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_mult', path = 'odyssey_v_mult.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_novice', path = 'odyssey_v_novice.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_observatory_1', path = 'odyssey_v_observatory_1.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_ocean', path = 'odyssey_v_ocean.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_offshore', path = 'odyssey_v_offshore.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_optimist', path = 'odyssey_v_optimist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_origami', path = 'odyssey_v_origami.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_pack', path = 'odyssey_v_pack.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_paper', path = 'odyssey_v_paper.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_partner', path = 'odyssey_v_partner.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_pathfinder', path = 'odyssey_v_pathfinder.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_pawn', path = 'odyssey_v_pawn.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_pessimist', path = 'odyssey_v_pessimist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_planetarium', path = 'odyssey_v_planetarium.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_plastic', path = 'odyssey_v_plastic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_platinum', path = 'odyssey_v_platinum.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_polymer', path = 'odyssey_v_polymer.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_portal', path = 'odyssey_v_portal.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_pragmatic', path = 'odyssey_v_pragmatic.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_prism', path = 'odyssey_v_prism.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_pro', path = 'odyssey_v_pro.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_propellant', path = 'odyssey_v_propellant.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_quantum_bit', path = 'odyssey_v_quantum_bit.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_qubit', path = 'odyssey_v_qubit.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_queen', path = 'odyssey_v_queen.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_rabbits_foot', path = 'odyssey_v_rabbits_foot.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_realist', path = 'odyssey_v_realist.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_recruiter', path = 'odyssey_v_recruiter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_recycler', path = 'odyssey_v_recycler.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_replicator', path = 'odyssey_v_replicator.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_research_center', path = 'odyssey_v_research_center.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_rock', path = 'odyssey_v_rock.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_rocket', path = 'odyssey_v_rocket.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_rook', path = 'odyssey_v_rook.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_rubber', path = 'odyssey_v_rubber.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_ruby', path = 'odyssey_v_ruby.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_satellite', path = 'odyssey_v_satellite.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_scout', path = 'odyssey_v_scout.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_seed', path = 'odyssey_v_seed.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_separation', path = 'odyssey_v_separation.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_shadow', path = 'odyssey_v_shadow.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'mystery', path = 'odyssey_secret_hand_blocked.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_shield', path = 'odyssey_v_shield.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_shuttle', path = 'odyssey_v_shuttle.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_solar_panel', path = 'odyssey_v_solar_panel.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_space_station', path = 'odyssey_v_space_station.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_specter', path = 'odyssey_v_specter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_squire', path = 'odyssey_v_squire.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_stack', path = 'odyssey_v_stack.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_steelworks', path = 'odyssey_v_steelworks.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_stone_2', path = 'odyssey_v_stone_2.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_storm', path = 'odyssey_v_storm.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_strongbox', path = 'odyssey_v_strongbox.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_talent_scout', path = 'odyssey_v_talent_scout.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_tapestry', path = 'odyssey_v_tapestry.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_tax_haven', path = 'odyssey_v_tax_haven.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_telescope', path = 'odyssey_v_telescope.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_time_capsule', path = 'odyssey_v_time_capsule.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_time_machine', path = 'odyssey_v_time_machine.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_tire', path = 'odyssey_v_tire.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_titanium', path = 'odyssey_v_titanium.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_transmuter', path = 'odyssey_v_transmuter.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_tree', path = 'odyssey_v_tree.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_utopian', path = 'odyssey_v_utopian.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_vase', path = 'odyssey_v_vase.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_vault', path = 'odyssey_v_vault.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_veteran', path = 'odyssey_v_veteran.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_vip', path = 'odyssey_v_vip.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_visionary', path = 'odyssey_v_visionary.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_warp_drive', path = 'odyssey_v_warp_drive.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_water', path = 'odyssey_v_water.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_wind', path = 'odyssey_v_wind.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_window', path = 'odyssey_v_window.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_wood', path = 'odyssey_v_wood.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'v_xmult', path = 'odyssey_v_xmult.png', px = 71, py = 95 })

----------------------------------------------
-- WAVE 8 ATLASES
----------------------------------------------
for i = 1, 100 do
    SMODS.Atlas({ key = 'tarot_' .. i, path = 'odyssey_tarot_' .. i .. '.png', px = 71, py = 95 })
    SMODS.Atlas({ key = 'planet_' .. i, path = 'odyssey_planet_' .. i .. '.png', px = 71, py = 95 })
    SMODS.Atlas({ key = 'spectral_' .. i, path = 'odyssey_spectral_' .. i .. '.png', px = 71, py = 95 })
    SMODS.Atlas({ key = 'blind_' .. i, path = 'odyssey_blind_' .. i .. '.png', px = 34, py = 34 })
end

-- MISSING ATLAS ENTRIES (AUTO-ADDED)
SMODS.Atlas({ key = 'j_luck_and_probability_wishbone', path = 'odyssey_j_luck_and_probability_wishbone.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_economy_credit_card_2', path = 'odyssey_j_economy_credit_card_2.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_destiny', path = 'odyssey_j_final_destiny.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_fate', path = 'odyssey_j_final_fate.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_chaos', path = 'odyssey_j_final_chaos.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_order', path = 'odyssey_j_final_order.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_apocalypse', path = 'odyssey_j_final_apocalypse.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_genesis', path = 'odyssey_j_final_genesis.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_alpha', path = 'odyssey_j_final_alpha.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_omega', path = 'odyssey_j_final_omega.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_lucky_discard', path = 'odyssey_j_hand_and_discard_lucky_discard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_hand_of_fate', path = 'odyssey_j_hand_and_discard_hand_of_fate.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_hand_of_justice', path = 'odyssey_j_hand_and_discard_hand_of_justice.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_precision', path = 'odyssey_j_hand_and_discard_precision.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_chaos_discard', path = 'odyssey_j_hand_and_discard_chaos_discard.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_hand_and_discard_agile_hand', path = 'odyssey_j_hand_and_discard_agile_hand.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_singularity', path = 'odyssey_j_final_singularity.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_big_bang', path = 'odyssey_j_final_big_bang.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_big_crunch', path = 'odyssey_j_final_big_crunch.png', px = 71, py = 95 })
SMODS.Atlas({ key = 'j_final_paradox', path = 'odyssey_j_final_paradox.png', px = 71, py = 95 })


----------------------------------------------
-- UTILITY FUNCTIONS
----------------------------------------------

-- Helper: Count total number of Jokers
function count_jokers()
    return #G.jokers.cards
end

-- Helper: Get number of empty Joker slots
function get_empty_slots()
    return G.jokers.config.card_limit - #G.jokers.cards
end

-- Helper: Get current deck size
function get_deck_size()
    return #G.playing_cards
end

-- Helper: Check if card is specific suit
function is_suit(card, suit)
    return card:is_suit(suit)
end

-- Helper: Check if card is specific rank
function is_rank(card, rank)
    return card.base.value == rank
end

-- Helper: Get Joker by key
function get_joker_by_key(key)
    for i = 1, #G.jokers.cards do
        if G.jokers.cards[i].ability.name == key then
            return G.jokers.cards[i]
        end
    end
    return nil
end

-- Helper: Count Jokers of specific rarity
function count_jokers_by_rarity(rarity)
    local count = 0
    for i = 1, #G.jokers.cards do
        if G.jokers.cards[i].config.center.rarity == rarity then
            count = count + 1
        end
    end
    return count
end

-- Helper: Get neighbor Joker (supports Connector bridging)
function get_joker_neighbor(card, direction)
    local my_pos = nil
    for i=1, #G.jokers.cards do
        if G.jokers.cards[i] == card then my_pos = i break end
    end
    if not my_pos then return nil end
    
    local step = direction == 'left' and -1 or 1
    local target_pos = my_pos + step
    
    local target = G.jokers.cards[target_pos]
    if target and target.config.center.key == 'j_odyssey_j_pos_connector' then
        target_pos = target_pos + step
        target = G.jokers.cards[target_pos]
    end
    
    return target
end

-- Helper: Check if only one Joker of this type exists
function is_unique_joker(card)
    local duplicates = 0
    for i = 1, #G.jokers.cards do
        if G.jokers.cards[i] and G.jokers.cards[i] ~= card and G.jokers.cards[i].ability.name == card.ability.name then
            duplicates = duplicates + 1
        end
    end
    return duplicates == 0
end

-- Helper: Utility function for localization
function create_loc_text(key, name, text)
    return {
        name = name,
        text = text
    }
end

-- Sorte Azarada: Override pseudorandom to fail checks for luck cards
local old_pseudorandom = pseudorandom
function pseudorandom(seed, min, max)
    if G.jokers and G.jokers.cards then
        for _, j in ipairs(G.jokers.cards) do
            if j.config.center.key == 'j_odyssey_j_paradox_unlucky_luck' and not j.debuff then
                if seed == 'undead_retrigger' or seed == 'light_money' or seed == 'magic_tarot' then
                    return 0.99 -- Fail the check (usually check is < prob)
                end
            end
        end
    end
    return old_pseudorandom(seed, min, max)
end

-- ODYSSEY CUSTOM: Robust n-of-a-kind helper for custom hands
function get_n_of_a_kind(hand, n)
    local ranks = {}
    for i = 1, #hand do
        local r = hand[i]:get_id()
        if r > 0 then
            ranks[r] = ranks[r] or {}
            table.insert(ranks[r], hand[i])
        end
    end
    local results = {}
    -- Sort ranks to ensure deterministic order (highest rank first like vanilla)
    local sorted_ranks = {}
    for r, group in pairs(ranks) do
        table.insert(sorted_ranks, {rank = r, group = group})
    end
    table.sort(sorted_ranks, function(a, b) return a.rank > b.rank end)

    for _, item in ipairs(sorted_ranks) do
        if #item.group >= n then
            -- If it's more than n, we only return first n cards to match vanilla behavior
            local group = {}
            for i = 1, n do
                table.insert(group, item.group[i])
            end
            table.insert(results, group)
        end
    end
    return results
end

-- Safety patch for create_popup_UIBox_tooltip to prevent crash when localization is missing
-- Some game parts expect tooltip.text to be a table, but localize returns a string "ERROR" on failure
local old_create_popup_UIBox_tooltip = create_popup_UIBox_tooltip
function create_popup_UIBox_tooltip(tooltip)
    if tooltip and type(tooltip.text) == 'string' then
        tooltip.text = {tooltip.text}
    end
    return old_create_popup_UIBox_tooltip(tooltip)
end

-- Hook for global Odyssey mechanics (like per-hand Tarot buffs)
SMODS.current_mod.calculate = function(self, context)
    if not context or type(context) ~= 'table' then return end
    
    -- Per-hand scoring buffs
    if context.joker_main then
        local chips = G.GAME.warrior_chips or 0
        local mult = G.GAME.magician_mult or 0
        local x_mult = G.GAME.rogue_x_mult or 1
        
        -- Spectral: Supernova (1), Zero Absoluto (14), Planck (15)
        x_mult = x_mult * (G.GAME.odyssey_spectral_1_xmult or 1)
        x_mult = x_mult * (G.GAME.odyssey_spectral_14_xmult or 1)
        x_mult = x_mult * (G.GAME.odyssey_spectral_15_xmult or 1)
        
        -- Spectral: Oppenheimer (50) X10 next hand
        if G.GAME.odyssey_spectral_50_next_xmult then
            x_mult = x_mult * G.GAME.odyssey_spectral_50_next_xmult
            G.GAME.odyssey_spectral_50_next_xmult = nil -- Consume
        end

        -- Spectral: Yang (94) X1.5 for 5-card hands
        if G.GAME.odyssey_yang_active and #context.full_hand == 5 then
            x_mult = x_mult * 1.5
        end

        if chips > 0 or mult > 0 or x_mult > 1 then
            return {
                message = "Odyssey!",
                chips = chips > 0 and chips or nil,
                mult = mult > 0 and mult or nil,
                x_mult = x_mult > 1 and x_mult or nil,
                colour = G.C.PURPLE
            }
        end
    end

    -- Spectral: Sharma (95) +$1 per Joker per hand
    if context.after and G.GAME.odyssey_sharma_active then
        ease_dollars(#G.jokers.cards)
    end

    -- Bard Retrigger
    if context.repetition and context.cardarea == G.play then
        if G.GAME.bard_retrigger and G.GAME.bard_retrigger > 0 then
            return {
                message = "Bard!",
                repetitions = 1,
                card = context.other_card
            }
        end
    end

    -- Reset round-based effects
    if context.end_of_round and not context.other_card then
        G.GAME.odyssey_spectral_1_xmult = 1
        G.GAME.odyssey_galileo_active = nil
        G.GAME.odyssey_newton_active = nil
        G.GAME.odyssey_einstein_active = nil
        G.GAME.odyssey_drake_active = nil
        
        -- Reset Tarot buffs
        G.GAME.warrior_chips = 0
        G.GAME.magician_mult = 0
        G.GAME.rogue_x_mult = 1
        G.GAME.bard_retrigger = 0

        -- Safety: Turn all cards face up when winning a round to prevent permanent flip bugs
        -- Specifically helpful for Endless mode transition.
        if G.playing_cards then
            for k, v in ipairs(G.playing_cards) do
                v.facing = 'front'
                v.sprite_facing = 'front'
            end
        end
    end
end

-- Reveal all Odyssey content (Jokers, Vouchers, Decks, etc.) in the Collections menu
function BalatroOdyssey.reveal_all_content()
    -- Prefix for Odyssey content
    local function is_odyssey_key(k)
        if not k then return false end
        return type(k) == 'string' and k:find('odyssey_') ~= nil
    end

    -- Mark discovered in individual centers
    for k, v in pairs(G.P_CENTERS) do
        if is_odyssey_key(k) then
            v.discovered = true
            v.unlocked = true
            v.alerted = true
        end
    end
    
    -- Mark discovered in Blinds
    for k, v in pairs(G.P_BLINDS) do
        if is_odyssey_key(k) then
            v.discovered = true
            v.unlocked = true
        end
    end

    -- Update profile metadata if available
    local profile = (G and G.SETTINGS and G.SETTINGS.profile and G.PROFILES) and G.PROFILES[G.SETTINGS.profile] or nil
    if profile then
        profile.meta = profile.meta or { unlocked = {}, discovered = {}, alerted = {} }
        profile.meta.unlocked = profile.meta.unlocked or {}
        profile.meta.discovered = profile.meta.discovered or {}
        profile.meta.alerted = profile.meta.alerted or {}
        
        for k, v in pairs(G.P_CENTERS) do
            if is_odyssey_key(k) then
                profile.meta.unlocked[k] = true
                profile.meta.discovered[k] = true
                profile.meta.alerted[k] = true
            end
        end
        for k, v in pairs(G.P_BLINDS) do
            if is_odyssey_key(k) then
                profile.meta.unlocked[k] = true
                profile.meta.discovered[k] = true
            end
        end
    end
end

-- ODYSSEY ADJACENCY HELPERS
function BalatroOdyssey.get_card_index(card, area)
    if not area or not area.cards then return nil end
    for i = 1, #area.cards do
        if area.cards[i] == card then return i end
    end
    return nil
end

function BalatroOdyssey.is_adjacent(card1, card2, area)
    local idx1 = BalatroOdyssey.get_card_index(card1, area)
    local idx2 = BalatroOdyssey.get_card_index(card2, area)
    if idx1 and idx2 and math.abs(idx1 - idx2) == 1 then
        return true
    end
    return false
end

function BalatroOdyssey.get_adjacent_cards(card, area)
    local idx = BalatroOdyssey.get_card_index(card, area)
    local adjacent = {}
    if not idx or not area or not area.cards then return adjacent end
    if area.cards[idx-1] then table.insert(adjacent, area.cards[idx-1]) end
    if area.cards[idx+1] then table.insert(adjacent, area.cards[idx+1]) end
    return adjacent
end


-- Safety patch for create_popup_UIBox_tooltip to prevent crash when localization is missing

----------------------------------------------
-- ODYSSEY ENGINE MONITOR & LOGGING SYSTEM
----------------------------------------------
-- Sistema centralizado para rastrear cada ao dos 1000 Jokers e itens.

ODYSSEY_LOG = {
    info = function(cat, msg) print("[ODYSSEY INFO][" .. cat .. "] " .. msg) end,
    warn = function(cat, msg) print("[ODYSSEY WARN][" .. cat .. "] " .. msg) end,
    err  = function(cat, msg) print("[ODYSSEY ERROR][" .. cat .. "] " .. msg) end,
    debug = function(card, context, ret)
        local key = (card.config and card.config.center and card.config.center.key) or "unknown"
        if not key:find("odyssey") then return end -- S loga itens do mod
        
        local ctx_name = "Unknown"
        if context.joker_main then ctx_name = "Main Scoring"
        elseif context.before then ctx_name = "Before Hand"
        elseif context.after then ctx_name = "After Hand"
        elseif context.end_of_round then ctx_name = "End of Round"
        elseif context.discard then ctx_name = "Discard"
        elseif context.individual then ctx_name = "Individual Card"
        elseif context.repetition then ctx_name = "Repetition/Retrigger"
        elseif context.setting_blind then ctx_name = "Setting Blind"
        elseif context.selling_self then ctx_name = "Selling Joker"
        elseif context.skip_blind then ctx_name = "Skip Blind"
        elseif context.open_booster then ctx_name = "Open Booster"
        elseif context.buying_card then ctx_name = "Buying Card"
        end

        local res = "Ignored"
        if ret then
            res = "SUCCESS -> "
            if type(ret) == "table" then
                for k, v in pairs(ret) do
                    if k ~= "card" then res = res .. k .. ": " .. tostring(v) .. " | " end
                end
            end
        end
        if ret then
            print("[ODYSSEY DEBUG][" .. key .. "] Context: " .. ctx_name .. " | Result: " .. res)
        end
    end
}

-- 1. Hook de Clculo de Jokers (Com Proteo contra Crash)
local card_calc_joker_ref = Card.calculate_joker
function Card.calculate_joker(self, context)
    -- Tenta executar o clculo original
    local status, ret = pcall(card_calc_joker_ref, self, context)
    
    if not status then
        -- Se o Joker do mod deu erro de cdigo, logamos o erro detalhado em vez de fechar o jogo
        ODYSSEY_LOG.err("CRASH PROTECT", "Joker " .. (self.config.center.key or "unknown") .. " crashed! Error: " .. tostring(ret))
        return nil
    end

    -- Se for um item do Odyssey, logamos o comportamento
    if self.config.center.key and self.config.center.key:find("odyssey") then
        ODYSSEY_LOG.debug(self, context, ret)
    end
    
    return ret
end

-- 2. Hook de Uso de Consumveis
local card_use_consumeable_ref = Card.use_consumeable
function Card.use_consumeable(self, area, copier)
    local key = self.config.center.key or "unknown"
    if key:find("odyssey") then
        ODYSSEY_LOG.info("CONSUMABLE", "Using " .. key .. " (Area: " .. (area and area.config.type or "nil") .. ")")
    end
    
    local status, ret = pcall(card_use_consumeable_ref, self, area, copier)
    if not status then
        ODYSSEY_LOG.err("CRASH PROTECT", "Consumable " .. key .. " crashed! Error: " .. tostring(ret))
    end
    return ret
end

-- 3. Hook de Criao de Cartas (Para rastrear pools)
local create_card_ref = create_card
function create_card(...)
    local card = create_card_ref(...)
    if card and card.config.center.key and card.config.center.key:find("odyssey") then
        local args = {...}
        ODYSSEY_LOG.info("POOL", "Generated Odyssey item: " .. card.config.center.key .. " (Set: " .. tostring(args[1]) .. ")")
    end
    return card
end


-- Balatro Odyssey: Standard Vanilla Overrides & Hooks
-- Consolidates critical game logic and patches known injector bugs.

-- 1. Game Setup & Pool Management
local old_get_blind_amount = get_blind_amount
function get_blind_amount(ante)
    local amount = old_get_blind_amount(ante)
    -- Odyssey Scale: Base points grow 3x faster to compensate for 1000 Jokers power creep.
    return amount * 3
end

-- 2. Currency & Stat Easing
local old_ease_dollars = ease_dollars
function ease_dollars(amount, instant)
    if G.GAME.bankrupt_at and (G.GAME.dollars + amount < G.GAME.bankrupt_at) then return end
    old_ease_dollars(amount, instant)
end

-- 3. Card & Hand Logic Consolidation
local old_is_suit = Card.is_suit
function Card:is_suit(suit, bypass_debuff, flush_calc)
    if G.GAME and G.GAME.modifiers.odyssey_chameleon and not bypass_debuff then return true end
    return old_is_suit(self, suit, bypass_debuff, flush_calc)
end

local old_get_cost = Card.get_cost
function Card:get_cost()
    local cost = old_get_cost(self)
    if G.GAME.odyssey_astronomer_planets_free and self.ability.set == 'Planet' then return 0 end
    
    -- Odyssey Coupon Joker (j_economy_coupon)
    if G.jokers and G.jokers.cards then
        for _, j in ipairs(G.jokers.cards) do
            if j.config.center.key == 'j_odyssey_j_economy_coupon' and j.ability.extra and j.ability.extra.active then
                return 0
            end
        end
    end
    
    return cost
end

-- 4. Safety Fixes (Lovely/Injector Stability)
local old_ebcb = ease_background_colour_blind
function ease_background_colour_blind(state, blindname)
    local b_name = blindname or (G.GAME.blind and G.GAME.blind.name) or ''
    -- Safety check: Avoid "attempt to index field 'boss' (a nil value)" in common_events.lua
    for _, v in pairs(G.P_BLINDS) do
        if v.name == b_name and not v.boss then
            ease_background_colour{new_colour = G.C.BLIND['Small'], contrast = 1}
            return
        end
    end
    old_ebcb(state, b_name)
end

local old_reroll_boss = G.FUNCS.reroll_boss
G.FUNCS.reroll_boss = function(e)
    if not G.blind_select_opts or not G.blind_select_opts.boss then return end
    old_reroll_boss(e)
end

-- 5. Round Timer Initializer
local old_set_blind = Blind.set_blind
function Blind:set_blind(blind, reset, silent)
    old_set_blind(self, blind, reset, silent)
    G.GAME.last_hand_time = G.TIMERS.REAL
end

-- 6. Blind Mechanics Overrides
-- A Espaguetificao: Jokers don't give Mult (Only Chips/XMult)
local old_calculate_joker = Card.calculate_joker
function Card:calculate_joker(context)
    local ret = old_calculate_joker(self, context)
    if ret and G.GAME.blind and G.GAME.blind.key == 'blind_odyssey_blind_64' then
        if ret.mult_mod then ret.mult_mod = nil end
        if ret.mult then ret.mult = nil end
    end
    return ret
end

-- 7. Perma-Mult & Perma-Bonus Logic for Playing Cards
local old_get_chip_mult = Card.get_chip_mult
function Card:get_chip_mult()
    local mult = old_get_chip_mult(self)
    if self.debuff then return 0 end
    if self.ability.set == 'Joker' then return 0 end
    return mult + (self.ability.perma_mult or 0)
end

local old_generate_UIBox_ability_table = Card.generate_UIBox_ability_table
function Card:generate_UIBox_ability_table()
    local res = old_generate_UIBox_ability_table(self)
    if (self.ability.set == 'Default' or self.ability.set == 'Enhanced') and self.ability.perma_mult and self.ability.perma_mult ~= 0 then
        -- Inject perma_mult into loc_vars if needed
    end
    return res
end



-- src/04_ui_overrides.lua
-- Sobrescreve a formatao de nmeros do jogo para usar sufixos (K, M, B...)

if not G.E_MANAGER then
    -- If loaded very early
end

function create_UIBox_hand_tip(handname)
  if not G.GAME.hands[handname].example then return {n=G.UIT.R, config={align = "cm"},nodes = {}} end 
  local hand_example = G.GAME.hands[handname].example
  local is_discovered = G.GAME.hands[handname].visible

  local card_limit = #hand_example
  -- Fine-tune width to avoid excessive spacing (0.5 * G.CARD_W is enough for smaller cards)
  local cardarea = CardArea(
    2,2,
    (card_limit * 0.55) * G.CARD_W, 
    0.75*G.CARD_H, 
    {card_limit = card_limit, type = 'title', highlight_limit = 0})

  for k, v in ipairs(hand_example) do
      local card = Card(0,0, 0.5*G.CARD_W, 0.5*G.CARD_H, G.P_CARDS[v[1]], G.P_CENTERS.c_base)
      
      -- If the hand is a secret hand and NOT discovered, use the lock sprite
      if not is_discovered and handname:find('secret_hand') then
          if G.ASSET_ATLAS['odyssey_mystery'] then
              card.children.front.atlas = G.ASSET_ATLAS['odyssey_mystery']
              card.children.front:set_sprite_pos({x=0, y=0})
          end
      end

      -- If discovered, we use normal behavior. If not discovered, we force them to look "highlighted" (bigger)
      -- so the lock image is more visible and fills the space.
      local scale_mod = (is_discovered and v[2]) and 0.25 or (not is_discovered and 0.2) or -0.15
      
      if v[2] or not is_discovered then card:juice_up(0.3, 0.2) end
      if k == 1 then play_sound('paper1',0.95 + math.random()*0.1, 0.3) end
      ease_value(card.T, 'scale', scale_mod, nil, 'REAL', true, 0.2)
      cardarea:emplace(card)
  end

  return {n=G.UIT.R, config={align = "cm", colour = G.C.WHITE, r = 0.1}, nodes={
    {n=G.UIT.C, config={align = "cm"}, nodes={
      {n=G.UIT.O, config={object = cardarea}}
    }}
  }}
end

--------------------------------------------------------------------------------
-- 1. Number Formatting
--------------------------------------------------------------------------------

-- Salva a funo original por segurana
local original_number_format = number_format

function number_format(number, reformat)
    if not number then return "0" end
    
    -- Garante que  um nmero
    local n = tonumber(number)
    if not n then return tostring(number) end

    -- Se for menor que 1000, retorna o nmero normal (arredondado)
    if math.abs(n) < 1000 then
        -- Permite decimais para nmeros pequenos (importante para multiplicadores como 0.5)
        if n == math.floor(n) then
            return tostring(math.floor(n))
        else
            return string.format("%.1f", n):gsub("%.0$", "")
        end
    end

    -- Tabela de sufixos
    local suffixes = {
        "K", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc"
    }
    
    local suffix_index = 0
    local temp_number = n
    
    -- Divide por 1000 at ficar menor que 1000
    while math.abs(temp_number) >= 1000 and suffix_index < #suffixes do
        temp_number = temp_number / 1000
        suffix_index = suffix_index + 1
    end
    
    -- Se estourou a lista de sufixos (nmeros absurdamente grandes), usa notao cientfica original
    if suffix_index > #suffixes then
        return original_number_format(number, reformat)
    end
    
    -- Formata com at 2 casas decimais
    local formatted = string.format("%.2f", temp_number)
    
    -- Remove zeros  direita desnecessrios
    if formatted:sub(-3) == ".00" then
        formatted = formatted:sub(1, -4)
    elseif formatted:sub(-1) == "0" then
        formatted = formatted:sub(1, -2)
    end
    
    return formatted .. suffixes[suffix_index]
end

--------------------------------------------------------------------------------
-- 2. Card Cost Overrides
--------------------------------------------------------------------------------
-- Hook Card:set_cost to implement deck logic for free/double prices

if Card then
    local old_set_cost = Card.set_cost
    Card.set_cost = function(self)
        -- Call original first to compute base cost
        if old_set_cost then old_set_cost(self) end
        
        -- Safe check for G variables
        if not (G and G.GAME and G.GAME.modifiers) then return end

        if G.GAME.selected_back and G.GAME.selected_back.effect.center.key == 'odyssey_tech' then
            -- Check if we are in shop (Booster or Jokers or Vouchers)
            if self.area == G.shop_jokers or self.area == G.shop_booster or self.area == G.shop_vouchers then
                 self.cost = self.cost * 2
                 -- Recompute sell cost
                 self.sell_cost = math.max(1, math.floor(self.cost/2))
                 -- Fix label
                 self.sell_cost_label = self.facing == 'back' and '?' or self.sell_cost
            end
        end

        local set = self.ability.set
        local name = self.ability.name

        -- Free Arcana (73)
        if G.GAME.modifiers.odyssey_free_arcana and set == 'Booster' and name and name:find('Arcane') then
             self.cost = 0
        end
        -- Free Celestial (74)
        if G.GAME.modifiers.odyssey_free_planet and set == 'Booster' and name and name:find('Celestial') then
             self.cost = 0
        end
        -- Free Spectral (75)
        if G.GAME.modifiers.odyssey_free_spectral and set == 'Booster' and name and name:find('Spectral') then
             self.cost = 0
        end
        -- Free Standard (76)
        if G.GAME.modifiers.odyssey_free_standard and set == 'Booster' and name and name:find('Standard') then
             self.cost = 0
        end
        -- Free Buffoon (77)
        if G.GAME.modifiers.odyssey_free_buffoon and set == 'Booster' and name and name:find('Buffoon') then
             self.cost = 0
        end
    end
end

------------------------------------------------------------------------
-- UI Override for Deck Selection Pagination
------------------------------------------------------------------------

-- Helper to apply the fix to a UI definition table (REORGANIZE PIPS TO ROWS OF 10)
local function apply_pip_fix(t)
    local function find_and_fix_pips(node, depth)
        if not node or type(node) ~= 'table' then return false end
        if depth > 40 then return false end
        
        -- Check if this node has many children (likely the pips container)
        if node.nodes and #node.nodes > 15 then
            -- Double check: Are the children UI nodes with B type (Button/Pip)?
            local all_pips = true
            for _, child in ipairs(node.nodes) do
                if type(child) ~= 'table' or child.n ~= G.UIT.B then
                    all_pips = false
                    break
                end
            end

            if all_pips then
                -- node.nodes is the array of pips. We empty it to hide them.
                node.nodes = {}
                return true -- Stop searching
            end
        end
        
        -- Recurse into children
        if node.nodes then
            for _, child in ipairs(node.nodes) do
                if find_and_fix_pips(child, depth + 1) then
                    return true
                end
            end
        end
        
        return false
    end

    find_and_fix_pips(t, 0)
end

-- Hook 1: G.UIDEF.run_setup_option
if G and G.UIDEF then
    local old_run_setup_option = G.UIDEF.run_setup_option
    G.UIDEF.run_setup_option = function(type)
        local t = old_run_setup_option(type)
        if type == 'Back' then
            apply_pip_fix(t)
        end
        return t
    end
end

-- Hook 2: create_option_cycle (Global)
if create_option_cycle then
    local old_create_option_cycle = create_option_cycle
    create_option_cycle = function(args)
        -- Filter Vanilla Decks if this is the Deck Selection cycle
        if args and args.options then
            local vanilla_keys = {
                ["b_red"] = true, ["b_blue"] = true, ["b_yellow"] = true, ["b_green"] = true, ["b_black"] = true,
                ["b_magic"] = true, ["b_nebula"] = true, ["b_ghost"] = true, ["b_abandoned"] = true, ["b_checkered"] = true,
                ["b_zodiac"] = true, ["b_painted"] = true, ["b_anaglyph"] = true, ["b_plasma"] = true, ["b_erratic"] = true
            }
            
            -- Check if this is a deck cycle
            local is_deck_cycle = false
            local first_opt = args.options[1]
            
            -- Heuristic: Check first option
            if type(first_opt) == 'table' then
                if first_opt.key and (vanilla_keys[first_opt.key] or string.find(first_opt.key, "^b_odyssey")) then
                    is_deck_cycle = true
                elseif first_opt.set == 'Back' then
                    is_deck_cycle = true
                end
            elseif type(first_opt) == 'string' then
                -- If it's a string, check if it matches a known deck name
                if first_opt == "Red Deck" or first_opt == "Baralho Vermelho" then
                    is_deck_cycle = true
                end
            end
            
            if is_deck_cycle then
                local new_options = {}
                for _, opt in ipairs(args.options) do
                    local is_odyssey = false
                    
                    -- STRICT FILTER: Only allow Odyssey decks
                    if type(opt) == 'table' then
                        if opt.key and (string.find(opt.key, "odyssey") or string.find(opt.key, "b_odyssey")) then
                            is_odyssey = true
                        end
                    end
                    
                    if is_odyssey then
                        table.insert(new_options, opt)
                    end
                end
                
                -- Only replace if we found at least one Odyssey deck
                if #new_options > 0 then
                    args.options = new_options
                end
            end
        end
        
        local t = old_create_option_cycle(args)
        
        -- Check if this is a large cycle (likely decks)
        if args and args.options and #args.options > 20 then
            apply_pip_fix(t)
        end
        
        return t
    end
end

sendDebugMessage("Balatro Odyssey: UI Overrides Loaded (Number Formatting + Deck Pagination)")


-- 05_deck_mechanics.lua
-- Handles custom logic for Balatro Odyssey Decks

local deck_mechanics = {}

-- Helper to get current deck key
local function get_deck_key()
    if G.GAME and G.GAME.selected_back then
        local key = G.GAME.selected_back.effect.center.key
        if not key then return nil end
        -- Handle Steamodded b_odyssey_ format and odyssey_ format
        key = key:gsub("^b_odyssey_", "")
        key = key:gsub("^odyssey_", "")
        return key
    end
    return nil
end

-- Helper to get deck config
local function get_deck_config()
    if G.GAME.selected_back and G.GAME.selected_back.effect.config then
        return G.GAME.selected_back.effect.config
    end
    return {}
end

------------------------------------------------------------------------
-- HOOKS
------------------------------------------------------------------------

-- 1. Card:calculate_joker (For scoring effects)
local old_calculate_joker = Card.calculate_joker or function() return nil end
Card.calculate_joker = function(self, context)
    local ret = old_calculate_joker(self, context)
    
    local deck_key = get_deck_key()
    if not deck_key then return ret end

    local function merge_effect(base, new)
        if not base then return new end
        if new.mult_mod then base.mult_mod = (base.mult_mod or 0) + new.mult_mod end
        if new.chip_mod then base.chip_mod = (base.chip_mod or 0) + new.chip_mod end
        if new.Xmult_mod then base.Xmult_mod = (base.Xmult_mod or 1) * new.Xmult_mod end
        if not base.message then
            base.message = new.message
            base.colour = new.colour
        end
        return base
    end

    -- Deck 6: Gravitational (Moved to Card:calculate_seal)
    -- Logic removed from here to avoid multiple triggers and dependency on jokers

    -- Deck 10: Quasar (+20 Mult Base)
    if deck_key == 'quasar' and context.joker_main then
        return merge_effect(ret, {
            message = localize{type='variable', key='a_mult', vars={20}},
            mult_mod = 20,
            colour = G.C.MULT
        })
    end

    -- Deck 35: Ascensao (Ascension) - Hands X2
    if deck_key == 'ascensao' and context.joker_main then
        return merge_effect(ret, {
            message = localize{type='variable', key='a_xmult', vars={2}},
            Xmult_mod = 2,
            colour = G.C.MULT
        })
    end

    -- Deck 36: Queda (Fall) - Hands X0.5
    if deck_key == 'queda' and context.joker_main then
        return merge_effect(ret, {
            message = localize{type='variable', key='a_xmult', vars={0.5}},
            Xmult_mod = 0.5,
            colour = G.C.MULT
        })
    end

    -- Deck 16: Order (Bonus for playing in order)
    if deck_key == 'order' and context.joker_main then
        -- Check if played cards are in rank order (ascending or descending)
        local ordered = true
        if #context.scoring_hand > 1 then
            local ascending = true
            local descending = true
            for i = 1, #context.scoring_hand - 1 do
                if context.scoring_hand[i].base.id >= context.scoring_hand[i+1].base.id then
                    ascending = false
                end
                if context.scoring_hand[i].base.id <= context.scoring_hand[i+1].base.id then
                    descending = false
                end
            end
            ordered = ascending or descending
        else
            ordered = false
        end

        if ordered then
             return merge_effect(ret, {
                message = localize{type='variable', key='a_xmult', vars={2}},
                Xmult_mod = 2,
                colour = G.C.MULT
            })
        end
    end

    -- Deck 18: Timeline (Add % of previous score)
    if deck_key == 'timeline' and context.joker_main then
        local stored = 0
        if G.GAME.selected_back.effect.config.extra and G.GAME.selected_back.effect.config.extra.stored_score then
            stored = G.GAME.selected_back.effect.config.extra.stored_score
        end
        if stored > 0 then
             return merge_effect(ret, {
                message = localize{type='variable', key='a_chips', vars={stored}},
                chip_mod = stored,
                colour = G.C.CHIPS
            })
        end
    end

    ------------------------------------------------------------------------
    -- NEW BARALHOS (41-100) IMPLEMENTATION (Merges)
    ------------------------------------------------------------------------

    -- 43. Lust (Luxuria) - Copas X1.2 Mult
    if deck_key == 'lust' and context.joker_main then
        local count = 0
        if context.scoring_hand then
            for _, c in ipairs(context.scoring_hand) do
                if c:is_suit('Hearts') then count = count + 1 end
            end
        end
        if count > 0 then
            return merge_effect(ret, {
                message = localize{type='variable', key='a_xmult', vars={count}},
                Xmult_mod = 1.2 ^ count,
                colour = G.C.MULT
            })
        end
    end

    -- 44. Pride (Orgulho) - Figuras +30 Fichas
    if deck_key == 'pride' and context.joker_main then
       local count = 0
       if context.scoring_hand then
           for _, c in ipairs(context.scoring_hand) do
               if c:is_face() then count = count + 1 end
           end
       end
       if count > 0 then
           return merge_effect(ret, {
               message = localize{type='variable', key='a_chips', vars={count * 30}},
               chip_mod = count * 30,
               colour = G.C.CHIPS
           })
       end
    end

    -- 67. Solar: Red suits only. Flush 2x.
    if deck_key == 'solar' and context.joker_main and context.scoring_name == 'Flush' then
        return merge_effect(ret, {
             message = localize{type='variable', key='a_xmult', vars={2}},
             Xmult_mod = 2,
             colour = G.C.MULT
        })
    end
    
    -- 66. Oceanic: Black suits only. Flush 2x.
    if deck_key == 'oceanic' and context.joker_main and context.scoring_name == 'Flush' then
        return merge_effect(ret, {
             message = localize{type='variable', key='a_xmult', vars={2}},
             Xmult_mod = 2,
             colour = G.C.MULT
        })
    end

    -- 80. Minimalist II: Hand size 3. X5 Mult.
    if deck_key == 'minimalist_ii' and context.joker_main then
        return merge_effect(ret, {
            message = localize{type='variable', key='a_xmult', vars={5}},
            Xmult_mod = 5,
            colour = G.C.MULT
        })
    end
    
    -- 82. Chaotic II: X2 Score (Boss effect doubled is harder).
    if deck_key == 'chaotic_ii' and context.joker_main then
        return merge_effect(ret, {
            message = localize{type='variable', key='a_xmult', vars={2}},
            Xmult_mod = 2,
            colour = G.C.MULT
        })
    end
    
    -- 83. Ordered II: 0.5x Score.
    if deck_key == 'ordered_ii' and context.joker_main then
        return merge_effect(ret, {
            message = localize{type='variable', key='a_xmult', vars={0.5}},
            Xmult_mod = 0.5,
            colour = G.C.MULT
        })
    end

    -- 89. Dragon: X10 Mult
    if deck_key == 'dragon' and context.joker_main then
        return merge_effect(ret, {
            message = localize{type='variable', key='a_xmult', vars={10}},
            Xmult_mod = 10,
            colour = G.C.MULT
        })
    end

    -- 96. Leviathan: Hand size 5 -> +1000 Chips
    if deck_key == 'leviathan' and context.joker_main and context.scoring_hand and #context.scoring_hand == 5 then
        return merge_effect(ret, {
            message = localize{type='variable', key='a_chips', vars={1000}},
            chip_mod = 1000,
            colour = G.C.CHIPS
        })
    end

    -- 97. Behemoth: Hand size 1 -> X5 Mult
    if deck_key == 'behemoth' and context.joker_main and context.scoring_hand and #context.scoring_hand == 1 then
        return merge_effect(ret, {
            message = localize{type='variable', key='a_xmult', vars={5}},
            Xmult_mod = 5,
            colour = G.C.MULT
        })
    end

    -- 42. Sloth (Preguia): X3 Mult
    if deck_key == 'sloth' and context.joker_main then
        return merge_effect(ret, {
            message = localize{type='variable', key='a_xmult', vars={3}},
            Xmult_mod = 3,
            colour = G.C.MULT
        })
    end

    -- 52. Mirror (Espelho): Right to Left (Descending) -> 2x
    if deck_key == 'mirror' and context.joker_main and context.scoring_hand and #context.scoring_hand >= 2 then
        local descending = true
        for i = 1, #context.scoring_hand - 1 do
            if context.scoring_hand[i].base.id <= context.scoring_hand[i+1].base.id then
                descending = false
                break
            end
        end
        if descending then
             return merge_effect(ret, {
                message = localize{type='variable', key='a_xmult', vars={2}},
                Xmult_mod = 2,
                colour = G.C.MULT
            })
        end
    end

    -- 54. Vampire: Apply accumulated Mult
    if deck_key == 'vampire' and context.joker_main then
        local mult = 0
        if G.GAME.selected_back.effect.config.extra then
            mult = G.GAME.selected_back.effect.config.extra.mult or 0
        end
        if mult > 0 then
            return merge_effect(ret, {
                message = localize{type='variable', key='a_mult', vars={mult}},
                mult_mod = mult,
                colour = G.C.MULT
            })
        end
    end

    -- 60. Invisible: X4 Mult if blind (checked elsewhere, technically always blind here)
    if deck_key == 'invisible' and context.joker_main then
        return merge_effect(ret, {
            message = localize{type='variable', key='a_xmult', vars={4}},
            Xmult_mod = 4,
            colour = G.C.MULT
        })
    end

    -- 65. Volcanic: +$5 per hand
    if deck_key == 'volcanic' and context.joker_main then
         -- Actually money should be applied on scoring? Or end of hand?
         -- joker_main calculates text.
         -- Use ease_dollars triggers in play_cards hook better.
         -- But user wants seeing it?
    end

    return ret
end

-- 2. Card:start_dissolve (For Event Horizon)
local old_start_dissolve = Card.start_dissolve
Card.start_dissolve = function(self, dissolve_colours, silent, dissolve_time_fac, no_juice)
    local deck_key = get_deck_key()
    
    -- Deck 7: Event Horizon (Destroy cards -> +0.5 Mult)
    if deck_key == 'event_horizon' then
        G.GAME.selected_back.effect.config.extra = G.GAME.selected_back.effect.config.extra or {}
        G.GAME.selected_back.effect.config.extra.mult = (G.GAME.selected_back.effect.config.extra.mult or 0) + 0.5
        -- Visual feedback?
        card_eval_status_text(G.GAME.selected_back, 'extra', nil, nil, nil, {message = localize{type='variable', key='a_mult', vars={0.5}}})
    end

    old_start_dissolve(self, dissolve_colours, silent, dissolve_time_fac, no_juice)
end

-- 2.1 Hook play_cards to capture score before hand (For Timeline Deck)
local old_play_cards = G.FUNCS.play_cards
G.FUNCS.play_cards = function(e)
    local deck_key = get_deck_key()
    if deck_key == 'timeline' then
        G.GAME.odyssey_temp_chips = G.GAME.chips
    end
    
    -- 41. Wrath (Ira): Hand gives $1
    if deck_key == 'wrath' then
        ease_dollars(1)
        card_eval_status_text(G.GAME.selected_back, 'extra', nil, nil, nil, {message = localize('$')..'1', colour = G.C.MONEY})
    end

    -- 65. Volcanic: +$5 per hand
    if deck_key == 'volcanic' then
        ease_dollars(5)
        card_eval_status_text(G.GAME.selected_back, 'extra', nil, nil, nil, {message = localize('$')..'5', colour = G.C.MONEY})
    end
    
    -- 64. Frozen: Debuff first hand
    if deck_key == 'frozen' and G.GAME.current_round.hands_played == 0 then
        -- This hook runs on play_cards. Cards are in G.play.cards or passed in event?
        -- G.play.cards should be populated.
        -- We debuff them.
        for k, v in ipairs(G.play.cards) do
            v:set_debuff(true)
        end
        card_eval_status_text(G.GAME.selected_back, 'extra', nil, nil, nil, {message = localize('k_frozen_ex')})
    end

    old_play_cards(e)
end

-- 2.2 Hook draw_from_play_to_discard to capture score after hand (For Timeline Deck)
local old_draw_from_play_to_discard = G.FUNCS.draw_from_play_to_discard
G.FUNCS.draw_from_play_to_discard = function(e)
    local deck_key = get_deck_key()
    
    if deck_key == 'timeline' then
        local current_chips = G.GAME.chips
        local previous_chips = G.GAME.odyssey_temp_chips or 0
        local hand_score = current_chips - previous_chips
        
        if hand_score > 0 then
            local to_store = math.floor(hand_score * 0.1)
            G.GAME.selected_back.effect.config.extra = G.GAME.selected_back.effect.config.extra or {}
            G.GAME.selected_back.effect.config.extra.stored_score = to_store
            
            -- Visual feedback
            card_eval_status_text(G.GAME.selected_back, 'extra', nil, nil, nil, {
                message = localize{type='variable', key='a_chips', vars={to_store}},
                colour = G.C.CHIPS
            })
        end
    end
    
    -- 51. Fractal: 5-of-a-Kind -> Clone card to deck
    -- We do this before cards are moved/destroyed
    if deck_key == 'fractal' then
         -- Identify if it was 5oak. Localizing text might be tricky, rely on internal name if possible?
         -- G.GAME.last_hand_played contains the text key?
         -- "Five of a Kind"
         -- We can check the cards count in scoring hand? context is not available here easily.
         -- But G.play.cards contains played cards.
         if #G.play.cards >= 5 then
            -- Rudimentary check: Are there 5 ranks same?
            -- Or just trust user? No.
            -- Check G.GAME.last_hand_played string (English key).
            -- This relies on game logic setting last_hand_played correctly before this function.
            -- Let's check G.GAME.hands[...].visible?
            
            -- Simplest: If 5 cards played, assume 5oak if they score?
            -- Actually, Flush House is 5 cards. Flush Five is 5 cards. 5oaK is 5 cards.
            -- If we just copy a card when 5 cards are played and they are all the same rank?
            local first_rank = G.play.cards[1].base.id
            local all_match = true
            for i=2, #G.play.cards do
                if G.play.cards[i].base.id ~= first_rank then all_match = false break end
            end
            
            if all_match and #G.play.cards >= 5 then
                 G.E_MANAGER:add_event(Event({
                    func = function() 
                        local card = copy_card(G.play.cards[1], nil, nil, G.playing_card)
                        card:add_to_deck()
                        G.deck:emplace(card)
                        card:start_materialize()
                        card_eval_status_text(G.GAME.selected_back, 'extra', nil, nil, nil, {message = localize('k_duplicated_ex')})
                        return true
                    end
                }))
            end
         end
    end

    -- 53. Ghost: Return played cards to hand
    if deck_key == 'ghost' then
        local cards_to_return = {}
        for k, v in ipairs(G.play.cards) do
            cards_to_return[#cards_to_return+1] = v
        end
        
        G.E_MANAGER:add_event(Event({
            trigger = 'after',
            delay = 0.1,
            func = function()
                for i=1, #cards_to_return do
                    if cards_to_return[i]:is_face_down() then cards_to_return[i]:flip() end
                    draw_card(G.play, G.hand, 90, 'up', nil, cards_to_return[i])
                end
                return true
            end
        }))
        return -- Skip default discard
    end
    
    -- 54. Vampire: Destroy played cards, gain Mult
    if deck_key == 'vampire' then
        local played_count = #G.play.cards
        if played_count > 0 then
            G.GAME.selected_back.effect.config.extra = G.GAME.selected_back.effect.config.extra or {}
            local gain_per_card = G.GAME.selected_back.effect.config.extra.gain or 1
            local total_gain = played_count * gain_per_card
            
            G.GAME.selected_back.effect.config.extra.mult = (G.GAME.selected_back.effect.config.extra.mult or 0) + total_gain
            
            card_eval_status_text(G.GAME.selected_back, 'extra', nil, nil, nil, {
                message = localize{type='variable', key='a_mult', vars={total_gain}},
                colour = G.C.MULT
            })

            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.1,
                func = function()
                    for k, v in ipairs(G.play.cards) do
                        v:start_dissolve()
                    end
                    return true
                end
            }))
        end
        return -- Skip default discard behavior
    end
    
    -- 65. Volcanic: Discard entire hand (destroy or discard?) logic says "Descarta" (Discard).
    if deck_key == 'volcanic' then
        -- Trigger default discard for played cards
        
        -- And then trigger discard for HAND cards
        G.E_MANAGER:add_event(Event({
            trigger = 'after',
            delay = 0.5,
            func = function()
                -- Discard all cards in hand
                for i = #G.hand.cards, 1, -1 do
                    local card = G.hand.cards[i]
                    if not card.highlighted then -- if not highlighted (should be none highlighted after play)
                         draw_card(G.hand, G.discard, i*10, 'down', false, card)
                    end
                end
                return true
            end
        }))
        -- Default behavior for played cards continues
    end

    old_draw_from_play_to_discard(e)
end

-- 3. Game:update (For Supernova check? Or end_of_round)
local old_end_round = G.FUNCS.end_round
G.FUNCS.end_round = function()
    local deck_key = get_deck_key()

    -- Deck 9: Supernova (Money > 50 -> Reset to 0, X3 Mult)
    if deck_key == 'supernova_deck' then
        if G.GAME.dollars > 50 then
            G.GAME.dollars = 0
            G.GAME.selected_back.effect.config.extra = G.GAME.selected_back.effect.config.extra or {}
            G.GAME.selected_back.effect.config.extra.xmult = (G.GAME.selected_back.effect.config.extra.xmult or 1) + 3
            G.E_MANAGER:add_event(Event({
                func = function()
                    play_sound('tarot1')
                    card_eval_status_text(G.GAME.selected_back, 'extra', nil, nil, nil, {message = "SUPERNOVA!", colour = G.C.RED})
                    return true
                end
            }))
        end
    end

    -- Deck 37: Avareza (Greed) - Gain $10 fixed
    if deck_key == 'avareza' then
        ease_dollars(10)
        card_eval_status_text(G.GAME.selected_back, 'extra', nil, nil, nil, {message = localize('$')..'10', colour = G.C.MONEY})
    end

    -- 58. Mutant: Suits change every round
    if deck_key == 'mutant' then
         G.E_MANAGER:add_event(Event({
            func = function()
                local suits = {'Spades', 'Hearts', 'Clubs', 'Diamonds'}
                for k, v in ipairs(G.playing_cards) do
                    local new_suit = suits[pseudorandom(pseudoseed('mutant')..v.base.id, 1, 4)]
                    v:change_suit(new_suit)
                end
                return true
            end
        }))
        card_eval_status_text(G.GAME.selected_back, 'extra', nil, nil, nil, {message = localize('k_mutant_ex')})
    end

    -- 62. Radioactive: Rank Decay
    if deck_key == 'radioactive' and G.hand and G.hand.cards then
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in ipairs(G.hand.cards) do
                    -- Check if not Ace (or 2 depending on logic). Let's say 2 is lowest.
                    if v.base.id > 2 then
                        local new_id = v.base.id - 1
                        -- Update card visual/value
                        local new_code = G.P_CARDS[string.sub(v.base.suit, 1, 1) .. '_' .. (G.id_def[new_id] or new_id)]
                        -- This P_CARDS lookup is tricky without utility.
                        -- Use internal helper if available or manually change base.
                        -- SMODS usually provides easy ways?
                        -- Trying manual base update approach
                         v.base.id = new_id
                         v.base.value = G.id_def[new_id] -- This might be a string like '2', 'K'
                         v:set_sprites(nil, v.config.card)
                    end
                end
                play_sound('timpani')
                card_eval_status_text(G.GAME.selected_back, 'extra', nil, nil, nil, {message = localize('k_decay_ex')})
                return true
            end
        }))
    end

    old_end_round()
end

-- 4. Blind Skip (For Wormhole)
local old_skip_blind = G.FUNCS.skip_blind
G.FUNCS.skip_blind = function(e)
    local deck_key = get_deck_key()
    
    if deck_key == 'wormhole' then
        -- Add Double Tag
        add_tag(Tag('tag_double'))
        
        -- [CRASH FIX] Verificamos si el objeto del mazo tiene la animacin.
        -- Si no la tiene (es nil), le inyectamos una funcin vaca para que no falle.
        if G.GAME.selected_back and not G.GAME.selected_back.juice_up then
            G.GAME.selected_back.juice_up = function() end
        end
        
        -- Ahora es seguro llamar a esto
        card_eval_status_text(G.GAME.selected_back, 'extra', nil, nil, nil, {message = localize('k_double_tag'), colour = G.C.ATTENTION})
    end

    old_skip_blind(e)
end

-- 5. Interest (For Quasar)
-- Note: G.FUNCS.get_interest might not be global. It is usually local in Game.lua.
-- We might need to hook where it is used or check if it is exposed.
-- Actually, G.FUNCS are usually UI callbacks.
-- Interest is calculated in G.FUNCS.end_round usually.
-- Let's check if we can modify interest cap.
-- G.GAME.interest_cap is set in Game:start_run.
-- We can set it to 0 in apply() for Quasar.

-- 6. Poll Edition (For Dark Energy)
local old_poll_edition = poll_edition
function poll_edition(_key, _mod, _no_neg, _guaranteed)
    local deck_key = get_deck_key()
    if deck_key == 'dark_energy' and not _no_neg and not _guaranteed then
        -- 4x chance (approx 1.2%)
        if pseudorandom('dark_energy') < 0.012 then
            return {negative = true}
        end
    end
    return old_poll_edition(_key, _mod, _no_neg, _guaranteed)
end

-- 7. Reroll Shop (For Vacuum)
local old_reroll_shop = G.FUNCS.reroll_shop
G.FUNCS.reroll_shop = function(e)
    if get_deck_key() == 'vacuum' then
        play_sound('cancel')
        return
    end
    old_reroll_shop(e)
end

-- 8. Find Joker (For String Theory)
-- Fakes having a Shortcut joker to enable gap-of-1 straights
local old_find_joker = find_joker
function find_joker(key)
    local ret = old_find_joker(key)
    if key == 'Shortcut' and get_deck_key() == 'string_theory' then
        if not next(ret) then
            table.insert(ret, { ability = {} }) -- Dummy card object
        end
    end
    return ret
end


-- 9. Blind Scaling (For Paradox, Ascensao, Queda, Lucky II, Unlucky)
local old_get_blind_amount = get_blind_amount
function get_blind_amount(ante)
    local amount = old_get_blind_amount(ante)
    local deck_key = get_deck_key()
    
    if deck_key == 'paradox' then
        if ante > 0 then
             amount = amount * (1.5 ^ ante)
        end
    end

    if deck_key == 'ascensao' then
        amount = amount * 2
    end

    if deck_key == 'queda' then
        amount = amount * 0.5
    end

    if deck_key == 'lucky_ii' then
        amount = amount * 4
    end

    if deck_key == 'unlucky' then
        amount = amount * 0.25
    end
    
    return amount
end

-- 10. Card:calculate_seal (For Gravitational Deck repetition)
local old_calculate_seal = Card.calculate_seal
Card.calculate_seal = function(self, context)
    local ret = old_calculate_seal(self, context)
    
    local deck_key = get_deck_key()
    
    -- Deck 6: Gravitational (Retrigger first played card)
    if deck_key == 'gravitational' and context.repetition and context.cardarea == G.play then
        if self == G.play.cards[1] then
            if type(ret) ~= 'table' then ret = {} end
            ret.repetitions = (ret.repetitions or 0) + 1
            ret.message = localize('k_again_ex')
            ret.card = self
        end
    end
    
    return ret
end

-- =========================================================================
-- ADDITIONAL HOOKS FOR NEW Decks (41-100)
-- NOTE: These were previously dangling outside logic!
-- We need to move them INSIDE Card.calculate_joker or create a new hook.
-- Let's merge them into Card.calculate_joker above.
-- But wait, the file structure suggests they were pasted at the end of the file
-- OUTSIDE of any function.
-- They start with "if deck_key == 'lust' ...". 
-- 'deck_key' is local to function scopes above, so this would crash if run.
-- Unless... they were meant to be inside hook 1?

-- REFACTORED: Moving the stranded logic into the main calculate_joker hook.

-- (See below for actual insertion)
-- =========================================================================
                colour = G.C.MULT

-- (Ended dangling code removal)


-- 12. Card:can_sell_card (For Kraken)
local old_can_sell_card = Card.can_sell_card
Card.can_sell_card = function(self, context)
    -- First check if deck blocks it
    if get_deck_key() == 'kraken' and self.ability.set == 'Joker' then
         return false
    end
    
    -- Then check standard logic
    if old_can_sell_card then 
        return old_can_sell_card(self, context) 
    end
    return true
end

-- 13. Blind:debuff_card (For Ordered II)
local old_debuff_card = Blind.debuff_card
Blind.debuff_card = function(self, card, from_blind)
    if get_deck_key() == 'ordered_ii' then
        return false 
    end
    return old_debuff_card(self, card, from_blind)
end


-- 14. Card:set_cost (For Tech Deck)
local old_set_cost = Card.set_cost
Card.set_cost = function(self)
    old_set_cost(self)
    if G.GAME.modifiers and G.GAME.modifiers.odyssey_shop_price_mult and self.area and 
       (self.area == G.shop_jokers or self.area == G.shop_vouchers or self.area == G.shop_booster) then
        self.cost = math.floor(self.cost * G.GAME.modifiers.odyssey_shop_price_mult)
    end
end

-- 15. Card:set_ability (For Midas Deck)
local old_set_ability = Card.set_ability
Card.set_ability = function(self, center, initial, delay_sprites)
    old_set_ability(self, center, initial, delay_sprites)
    if G.GAME.modifiers and G.GAME.modifiers.odyssey_midas then
        if self.ability.set == 'Joker' then
            if not self.edition then
                self:set_edition({polychrome = true})
            end
        elseif self.ability.set == 'Default' or self.ability.set == 'Enhanced' then
            if self.config.center ~= G.P_CENTERS.m_odyssey_plastic then
                self:set_ability(G.P_CENTERS.m_odyssey_plastic)
            end
        end
    end
end


local enhancements = {}

-- Atlas for Enhancements (User needs to provide odyssey_enhancements.png)
-- Grid 4x4 for the 16 enhancements
-- Row 1: Wood, Plastic, Rubber, Shadow
-- Row 2: Ceramic, Cloth, Paper, Light
-- Row 3: Diamond, Ruby, Emerald, Plant
-- Row 4: Holy, Undead, Cursed, Magic

-- 1. Madeira (Wood)
-- Effect: +10 Chips, 1 in 8 chance to break
SMODS.Enhancement({
    key = 'wood',
    atlas = 'enhancements',
    pos = { x = 0, y = 0 },
    config = { extra = { chips = 10, chance = 8 } },
    loc_txt = {
        name = 'Carta de Madeira',
        text = {
            "{C:chips}+#1#{} Fichas",
            "{C:green}#2# em #3#{} chance de",
            "quebrar ao pontuar"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            return {
                chips = card.ability.extra.chips
            }
        end
        if context.destroy_card and context.cardarea == G.play then
            if pseudorandom('wood_break') < G.GAME.probabilities.normal / card.ability.extra.chance then
                return {
                    remove = true
                }
            end
        end
    end
})

-- 2. Plstico (Plastic)
-- Effect: $3 when in hand at end of round
SMODS.Enhancement({
    key = 'plastic',
    atlas = 'enhancements',
    pos = { x = 1, y = 0 },
    config = { extra = { dollars = 3 } },
    loc_txt = {
        name = 'Carta de Plstico',
        text = {
            "Ganha {C:money}$#1#{} se esta",
            "carta estiver na mo",
            "ao final da rodada"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context, effect)
        if context.individual and context.cardarea == G.hand and context.end_of_round then
            if G.GAME.odyssey_money_laundering_active and G.GAME.odyssey_money_laundering_active > 0 then
                return nil
            end
            return {
                dollars = card.ability.extra.dollars,
                card = card
            }
        end
    end
})

-- 3. Borracha (Rubber)
-- Effect: Retrigger (Bouncy)
SMODS.Enhancement({
    key = 'rubber',
    atlas = 'enhancements',
    pos = { x = 2, y = 0 },
    config = {},
    loc_txt = {
        name = 'Carta de Borracha',
        text = {
            "Reativa esta carta",
            "{C:attention}1{} vez adicional"
        }
    },
    calculate = function(self, card, context, effect)
        if context.repetition and context.cardarea == G.play then
            return {
                message = localize('k_again_ex'),
                repetitions = 1,
                card = card
            }
        end
    end
})

-- 4. Cermica (Ceramic)
-- Effect: X1.5 Mult, 1 in 4 chance to break
SMODS.Enhancement({
    key = 'ceramic',
    atlas = 'enhancements',
    pos = { x = 0, y = 1 },
    config = { extra = { xmult = 1.5, chance = 4 } },
    loc_txt = {
        name = 'Carta de Cermica',
        text = {
            "{X:mult,C:white} X#1# {} Mult",
            "{C:green}#2# em #3#{} chance de",
            "quebrar ao pontuar"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult, G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            return {
                x_mult = card.ability.extra.xmult
            }
        end
        if context.destroy_card and context.cardarea == G.play then
            if pseudorandom('ceramic_break') < G.GAME.probabilities.normal / card.ability.extra.chance then
                return {
                    remove = true
                }
            end
        end
    end
})

-- 5. Tecido (Cloth)
-- Effect: +5 Chips, +2 Mult
SMODS.Enhancement({
    key = 'cloth',
    atlas = 'enhancements',
    pos = { x = 1, y = 1 },
    config = { extra = { chips = 5, mult = 2 } },
    loc_txt = {
        name = 'Carta de Tecido',
        text = {
            "{C:chips}+#1#{} Fichas",
            "{C:mult}+#2#{} Mult"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.mult } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            return {
                chips = card.ability.extra.chips,
                mult = card.ability.extra.mult
            }
        end
    end
})

-- 6. Papel (Paper)
-- Effect: +30 Chips, 1 in 6 chance to break
SMODS.Enhancement({
    key = 'paper',
    atlas = 'enhancements',
    pos = { x = 2, y = 1 },
    config = { extra = { chips = 30, chance = 6 } },
    loc_txt = {
        name = 'Carta de Papel',
        text = {
            "{C:chips}+#1#{} Fichas",
            "{C:green}#2# em #3#{} chance de",
            "quebrar ao pontuar"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            return {
                chips = card.ability.extra.chips
            }
        end
        if context.destroy_card and context.cardarea == G.play then
            if pseudorandom('paper_break') < G.GAME.probabilities.normal / card.ability.extra.chance then
                return {
                    remove = true
                }
            end
        end
    end
})

-- 7. Diamante (Diamond)
-- Effect: $1 when scored
SMODS.Enhancement({
    key = 'diamond',
    atlas = 'enhancements',
    pos = { x = 0, y = 2 },
    config = { extra = { dollars = 1 } },
    loc_txt = {
        name = 'Carta de Diamante',
        text = {
            "Ganha {C:money}$#1#{} quando",
            "esta carta pontua"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            return {
                dollars = card.ability.extra.dollars
            }
        end
    end
})

-- 8. Rubi (Ruby)
-- Effect: +10 Mult
SMODS.Enhancement({
    key = 'ruby',
    atlas = 'enhancements',
    pos = { x = 1, y = 2 },
    config = { extra = { mult = 10 } },
    loc_txt = {
        name = 'Carta de Rubi',
        text = {
            "{C:mult}+#1#{} Mult"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            return {
                mult = card.ability.extra.mult
            }
        end
    end
})

-- 9. Esmeralda (Emerald)
-- Effect: +50 Chips
SMODS.Enhancement({
    key = 'emerald',
    atlas = 'enhancements',
    pos = { x = 2, y = 2 },
    config = { extra = { chips = 50 } },
    loc_txt = {
        name = 'Carta de Esmeralda',
        text = {
            "{C:chips}+#1#{} Fichas"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            return {
                chips = card.ability.extra.chips
            }
        end
    end
})

-- 10. Sombra (Shadow)
-- Effect: X1.5 Mult when scored
SMODS.Enhancement({
    key = 'shadow',
    atlas = 'enhancements',
    pos = { x = 3, y = 0 },
    config = { extra = { xmult = 1.5 } },
    loc_txt = {
        name = 'Carta de Sombra',
        text = {
            "{X:mult,C:white} X#1# {} Mult"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            return {
                x_mult = card.ability.extra.xmult
            }
        end
    end
})

-- 11. Luz (Light)
-- Effect: 1 in 4 chance to gain  when scored
SMODS.Enhancement({
    key = 'light',
    atlas = 'enhancements',
    pos = { x = 3, y = 1 },
    config = { extra = { dollars = 3, chance = 4 } },
    loc_txt = {
        name = 'Carta de Luz',
        text = {
            "{C:green}#1# em #2#{} chance de",
            "ganhar {C:money}$#3#{}"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance, extra.dollars } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            if pseudorandom('light_money') < G.GAME.probabilities.normal / card.ability.extra.chance then
                return {
                    dollars = card.ability.extra.dollars
                }
            end
        end
    end
})

-- 12. Planta (Plant)
-- Effect: Gains +5 Chips when scored
SMODS.Enhancement({
    key = 'plant',
    atlas = 'enhancements',
    pos = { x = 3, y = 2 },
    config = { extra = { chips_gain = 5 } },
    loc_txt = {
        name = 'Carta de Planta',
        text = {
            "Ganha {C:chips}+#1#{} Fichas",
            "quando pontua"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips_gain } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            card.ability.extra_chips = (card.ability.extra_chips or 0) + card.ability.extra.chips_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.CHIPS,
                card = card
            }
        end
    end
})

-- 13. Sagrada (Holy)
-- Effect: +10 Mult, +30 Chips
SMODS.Enhancement({
    key = 'holy',
    atlas = 'enhancements',
    pos = { x = 0, y = 3 },
    config = { extra = { mult = 10, chips = 30 } },
    loc_txt = {
        name = 'Carta Sagrada',
        text = {
            "{C:mult}+#1#{} Mult",
            "{C:chips}+#2#{} Fichas"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.chips } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            return {
                mult = card.ability.extra.mult,
                chips = card.ability.extra.chips
            }
        end
    end
})

-- 14. Morta-Viva (Undead)
-- Effect: 1 in 3 chance to retrigger
SMODS.Enhancement({
    key = 'undead',
    atlas = 'enhancements',
    pos = { x = 1, y = 3 },
    config = { extra = { chance = 3 } },
    loc_txt = {
        name = 'Carta Morta-Viva',
        text = {
            "{C:green}#1# em #2#{} chance de",
            "reativar esta carta"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context, effect)
        if context.repetition and context.cardarea == G.play then
            if pseudorandom('undead_retrigger') < G.GAME.probabilities.normal / card.ability.extra.chance then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- 15. Maldita (Cursed)
-- Effect: X2 Mult, -20 Chips
SMODS.Enhancement({
    key = 'cursed',
    atlas = 'enhancements',
    pos = { x = 2, y = 3 },
    config = { extra = { xmult = 2, chips_loss = 20 } },
    loc_txt = {
        name = 'Carta Maldita',
        text = {
            "{X:mult,C:white} X#1# {} Mult",
            "{C:chips}-#2#{} Fichas"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult, extra.chips_loss } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            return {
                x_mult = card.ability.extra.xmult,
                chips = -card.ability.extra.chips_loss
            }
        end
    end
})

-- 16. Mgica (Magic)
-- Effect: 1 in 6 chance to create a Tarot card when scored
SMODS.Enhancement({
    key = 'magic',
    atlas = 'enhancements',
    pos = { x = 3, y = 3 },
    config = { extra = { chance = 6 } },
    loc_txt = {
        name = 'Carta Mgica',
        text = {
            "{C:green}#1# em #2#{} chance de",
            "criar uma carta de {C:tarot}Tar{}",
            "quando pontua"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            if pseudorandom('magic_tarot') < G.GAME.probabilities.normal / card.ability.extra.chance then
                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                    G.E_MANAGER:add_event(Event({
                        trigger = 'before',
                        delay = 0.0,
                        func = (function()
                            local card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'magic_enhancement')
                            card:add_to_deck()
                            G.consumeables:emplace(card)
                            G.GAME.consumeable_buffer = 0
                            return true
                        end)
                    }))
                    return {
                        message = localize('k_plus_tarot'),
                        colour = G.C.PURPLE,
                        card = card
                    }
                end
            end
        end
    end
})

-- 17. Platina (Platinum)
-- Effect: +100 Chips
SMODS.Enhancement({
    key = 'platinum',
    atlas = 'v_platinum',
    pos = { x = 0, y = 0 },
    config = { extra = { chips = 100 } },
    loc_txt = {
        name = 'Carta de Platina',
        text = {
            "{C:chips}+#1#{} Fichas"
        }
    },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context, effect)
        if context.main_scoring and context.cardarea == G.play then
            return {
                chips = card.ability.extra.chips
            }
        end
    end
})




----------------------------------------------
-- VOUCHERS (1-100)
----------------------------------------------

-- 1. Telescope & Observatory_1
SMODS.Voucher{
    key = 'telescope',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_telescope',
    cost = 10,
    redeem = function(self)
        G.GAME.planet_rate = G.GAME.planet_rate * 2
    end
}

SMODS.Voucher{
    key = 'observatory_1',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_observatory_1',
    cost = 10,
    requires = { 'v_odyssey_telescope' },
    redeem = function(self)
        G.GAME.planet_rate = G.GAME.planet_rate * 2
    end
}

-- 2. Asteroid & Meteor
SMODS.Voucher{
    key = 'asteroid',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_asteroid',
    cost = 10,
    redeem = function(self)
        G.GAME.tarot_rate = G.GAME.tarot_rate * 2
    end
}

SMODS.Voucher{
    key = 'meteor',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_meteor',
    cost = 10,
    requires = { 'v_odyssey_asteroid' },
    redeem = function(self)
        G.GAME.tarot_rate = G.GAME.tarot_rate * 2
    end
}

-- 3. Comet_1 & Falling_Star
SMODS.Voucher{
    key = 'comet_1',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_comet_1',
    cost = 10,
    redeem = function(self)
        G.GAME.spectral_rate = (G.GAME.spectral_rate or 0) + 1
    end
}

SMODS.Voucher{
    key = 'falling_star',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_falling_star',
    cost = 10,
    requires = { 'v_odyssey_comet_1' },
    redeem = function(self)
        G.GAME.spectral_rate = (G.GAME.spectral_rate or 0) + 2
    end
}

-- 4. Satellite & Space_Station
SMODS.Voucher{
    key = 'satellite',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_satellite',
    cost = 10,
    redeem = function(self)
        G.GAME.round_resets.consumeable_slots = G.GAME.round_resets.consumeable_slots + 1
        G.consumeables.config.card_limit = G.consumeables.config.card_limit + 1
    end
}

SMODS.Voucher{
    key = 'space_station',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_space_station',
    cost = 10,
    requires = { 'v_odyssey_satellite' },
    redeem = function(self)
        G.GAME.round_resets.consumeable_slots = G.GAME.round_resets.consumeable_slots + 1
        G.consumeables.config.card_limit = G.consumeables.config.card_limit + 1
    end
}

-- 5. Rocket & Shuttle
SMODS.Voucher{
    key = 'rocket',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_rocket',
    cost = 10,
    redeem = function(self)
        G.GAME.round_resets.hand_size = G.GAME.round_resets.hand_size + 1
        G.hand.config.card_limit = G.hand.config.card_limit + 1
    end
}

SMODS.Voucher{
    key = 'shuttle',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_shuttle',
    cost = 10,
    requires = { 'v_odyssey_rocket' },
    redeem = function(self)
        G.GAME.round_resets.hand_size = G.GAME.round_resets.hand_size + 1
        G.hand.config.card_limit = G.hand.config.card_limit + 1
    end
}

-- 6. Propellant & Separation
SMODS.Voucher{
    key = 'propellant',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_propellant',
    cost = 10,
    redeem = function(self)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + 1
    end
}

SMODS.Voucher{
    key = 'separation',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_separation',
    cost = 10,
    requires = { 'v_odyssey_propellant' },
    redeem = function(self)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + 1
    end
}

-- 7. Fuel_Tank & Core
SMODS.Voucher{
    key = 'fuel_tank',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_fuel_tank',
    cost = 10,
    redeem = function(self)
        G.GAME.interest_cap = G.GAME.interest_cap + 10
    end
}

SMODS.Voucher{
    key = 'core',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_core',
    cost = 10,
    requires = { 'v_odyssey_fuel_tank' },
    redeem = function(self)
        G.GAME.interest_cap = G.GAME.interest_cap + 10
    end
}

-- 8. Solar_Panel & Dyson_Sphere
SMODS.Voucher{
    key = 'solar_panel',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_solar_panel',
    cost = 10,
    redeem = function(self)
        G.GAME.solar_panel = (G.GAME.solar_panel or 0) + 1
    end
}

SMODS.Voucher{
    key = 'dyson_sphere',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_dyson_sphere',
    cost = 10,
    requires = { 'v_odyssey_solar_panel' },
    redeem = function(self)
        G.GAME.solar_panel = (G.GAME.solar_panel or 0) + 1
    end
}

-- 9. Recycler & Converter
SMODS.Voucher{
    key = 'recycler',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_recycler',
    cost = 10,
    redeem = function(self)
        G.GAME.round_resets.reroll_cost = math.max(1, G.GAME.round_resets.reroll_cost - 1)
    end
}

SMODS.Voucher{
    key = 'converter',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_converter',
    cost = 10,
    requires = { 'v_odyssey_recycler' },
    redeem = function(self)
        G.GAME.round_resets.reroll_cost = math.max(1, G.GAME.round_resets.reroll_cost - 1)
    end
}

-- 10. Dark_Matter & Dark_Energy
SMODS.Voucher{
    key = 'dark_matter',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_dark_matter',
    cost = 10,
    redeem = function(self)
        G.GAME.negative_rate = (G.GAME.negative_rate or 0) + 0.1
    end
}

SMODS.Voucher{
    key = 'dark_energy',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_dark_energy',
    cost = 10,
    requires = { 'v_odyssey_dark_matter' },
    redeem = function(self)
        G.GAME.negative_rate = (G.GAME.negative_rate or 0) + 0.15
    end
}

-- 11. Quantum_Bit & Qubit
SMODS.Voucher{
    key = 'quantum_bit',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_quantum_bit',
    cost = 10,
    redeem = function(self)
        G.GAME.planet_to_tarot_chance = (G.GAME.planet_to_tarot_chance or 0) + 0.25
    end
}

SMODS.Voucher{
    key = 'qubit',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_qubit',
    cost = 10,
    requires = { 'v_odyssey_quantum_bit' },
    redeem = function(self)
        G.GAME.planet_to_tarot_chance = (G.GAME.planet_to_tarot_chance or 0) + 0.25
    end
}

-- 12. Time_Capsule & Time_Machine
SMODS.Voucher{
    key = 'time_capsule',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_time_capsule',
    cost = 10,
    redeem = function(self)
        G.GAME.blind_replays = (G.GAME.blind_replays or 0) + 1
    end
}

SMODS.Voucher{
    key = 'time_machine_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_time_machine',
    cost = 10,
    requires = { 'v_odyssey_time_capsule' },
    redeem = function(self)
        G.GAME.blind_replays = (G.GAME.blind_replays or 0) + 2
    end
}

-- 13. Warp_Drive & Hyperdrive
SMODS.Voucher{
    key = 'warp_drive',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_warp_drive',
    cost = 10,
    redeem = function(self)
        G.GAME.skip_money_bonus = (G.GAME.skip_money_bonus or 0) + 5
    end
}

SMODS.Voucher{
    key = 'hyperdrive',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_hyperdrive',
    cost = 10,
    requires = { 'v_odyssey_warp_drive' },
    redeem = function(self)
        G.GAME.skip_money_bonus = (G.GAME.skip_money_bonus or 0) + 5
    end
}

-- 14. Shield & Force_Field
SMODS.Voucher{
    key = 'shield',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_shield',
    cost = 10,
    redeem = function(self)
        G.GAME.prevent_game_over = (G.GAME.prevent_game_over or 0) + 1
    end
}

SMODS.Voucher{
    key = 'force_field',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_force_field',
    cost = 10,
    requires = { 'v_odyssey_shield' },
    redeem = function(self)
        G.GAME.force_field_active = true
        G.GAME.prevent_game_over = (G.GAME.prevent_game_over or 0) + 1
    end
}

-- 15. Laser & Destroyer
SMODS.Voucher{
    key = 'laser',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_laser',
    cost = 10,
    redeem = function(self)
        G.GAME.stone_bonus_chips = (G.GAME.stone_bonus_chips or 0) + 50
    end
}

SMODS.Voucher{
    key = 'destroyer',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_destroyer',
    cost = 10,
    requires = { 'v_odyssey_laser' },
    redeem = function(self)
        G.GAME.stone_bonus_chips = (G.GAME.stone_bonus_chips or 0) + 50
    end
}

-- 16. Gold_Plating & Midas_Touch
SMODS.Voucher{
    key = 'gold_plating',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_gold_plating',
    cost = 10,
    redeem = function(self)
        G.GAME.gold_card_money_bonus = (G.GAME.gold_card_money_bonus or 0) + 4
    end
}

SMODS.Voucher{
    key = 'midas_touch',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_midas_touch',
    cost = 10,
    requires = { 'v_odyssey_gold_plating' },
    redeem = function(self)
        G.GAME.gold_card_money_bonus = (G.GAME.gold_card_money_bonus or 0) + 2 -- Total 6
    end
}

-- 17. Blower & Crystal_Forge
SMODS.Voucher{
    key = 'blower',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_blower',
    cost = 10,
    redeem = function(self)
        G.GAME.glass_indestructible = true
    end
}

SMODS.Voucher{
    key = 'crystal_forge',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_crystal_forge',
    cost = 10,
    requires = { 'v_odyssey_blower' },
    redeem = function(self)
        G.GAME.glass_bonus_xmult = (G.GAME.glass_bonus_xmult or 1) * 3
    end
}

-- 18. Steelworks & Titanium
SMODS.Voucher{
    key = 'steelworks',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_steelworks',
    cost = 10,
    redeem = function(self)
        G.GAME.steel_bonus_xmult = 1.8
    end
}

SMODS.Voucher{
    key = 'titanium',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_titanium',
    cost = 10,
    requires = { 'v_odyssey_steelworks' },
    redeem = function(self)
        G.GAME.steel_bonus_xmult = 2.5
    end
}

-- 19. Amulet & Rabbits_Foot
SMODS.Voucher{
    key = 'amulet',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_amulet',
    cost = 10,
    redeem = function(self)
        G.GAME.lucky_mult = (G.GAME.lucky_mult or 1) * 2
    end
}

SMODS.Voucher{
    key = 'rabbits_foot',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_rabbits_foot',
    cost = 10,
    requires = { 'v_odyssey_amulet' },
    redeem = function(self)
        G.GAME.lucky_mult = (G.GAME.lucky_mult or 1) * 2
    end
}

-- 20. Cloning & Replicator
SMODS.Voucher{
    key = 'cloning',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_cloning',
    cost = 10,
    redeem = function(self)
        G.GAME.shop_size = (G.GAME.shop_size or 2) + 1
        if G.shop_jokers and G.shop_jokers.config then
            G.shop_jokers.config.card_limit = G.shop_jokers.config.card_limit + 1
        end
    end
}

SMODS.Voucher{
    key = 'replicator',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_replicator',
    cost = 10,
    requires = { 'v_odyssey_cloning' },
    redeem = function(self)
        G.GAME.shop_size = (G.GAME.shop_size or 2) + 1
        if G.shop_jokers and G.shop_jokers.config then
            G.shop_jokers.config.card_limit = G.shop_jokers.config.card_limit + 1
        end
    end
}

-- 21. Black_Market & Contraband
SMODS.Voucher{
    key = 'black_market',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_black_market',
    cost = 10,
    redeem = function(self)
        G.GAME.shop_rare_rate = (G.GAME.shop_rare_rate or 1) * 2
    end
}

SMODS.Voucher{
    key = 'contraband',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_contraband',
    cost = 10,
    requires = { 'v_odyssey_black_market' },
    redeem = function(self)
        G.GAME.shop_legendary_rate = (G.GAME.shop_legendary_rate or 0) + 0.01
    end
}

-- 22. Coupon & Liquidation
SMODS.Voucher{
    key = 'coupon',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_coupon',
    cost = 10,
    redeem = function(self)
        G.GAME.discount_percent = 25
        for k, v in pairs(G.I.CARD) do if v.set_cost then v:set_cost() end end
    end
}

SMODS.Voucher{
    key = 'liquidation',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_liquidation',
    cost = 10,
    requires = { 'v_odyssey_coupon' },
    redeem = function(self)
        G.GAME.discount_percent = 50
        for k, v in pairs(G.I.CARD) do if v.set_cost then v:set_cost() end end
    end
}

-- 23. Investment & Hedge_Fund
SMODS.Voucher{
    key = 'investment',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_investment',
    cost = 10,
    redeem = function(self)
        G.GAME.joker_buy_bonus = (G.GAME.joker_buy_bonus or 0) + 5
    end
}

SMODS.Voucher{
    key = 'hedge_fund_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_hedge_fund',
    cost = 10,
    requires = { 'v_odyssey_investment' },
    redeem = function(self)
        G.GAME.joker_buy_bonus = (G.GAME.joker_buy_bonus or 0) + 5
    end
}

-- 24. Insurance & Bailout
SMODS.Voucher{
    key = 'insurance',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_insurance',
    cost = 10,
    redeem = function(self)
        G.GAME.loss_forgiveness = 0
    end
}

SMODS.Voucher{
    key = 'bailout',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_bailout',
    cost = 10,
    requires = { 'v_odyssey_insurance' },
    redeem = function(self)
        G.GAME.loss_forgiveness = 10
    end
}

-- 25. Library & Archives
SMODS.Voucher{
    key = 'library',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_library',
    cost = 10,
    redeem = function(self)
        G.GAME.shop_tarot_count = (G.GAME.shop_tarot_count or 0) + 1
    end
}

SMODS.Voucher{
    key = 'archives',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_archives',
    cost = 10,
    requires = { 'v_odyssey_library' },
    redeem = function(self)
        G.GAME.shop_tarot_count = (G.GAME.shop_tarot_count or 0) + 1
    end
}

-- 26. Deep_Space_Obs & Planetarium
SMODS.Voucher{
    key = 'deep_space_obs',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_deep_space_obs',
    cost = 10,
    redeem = function(self)
        G.GAME.shop_planet_count = (G.GAME.shop_planet_count or 0) + 1
    end
}

SMODS.Voucher{
    key = 'planetarium',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_planetarium',
    cost = 10,
    requires = { 'v_odyssey_deep_space_obs' },
    redeem = function(self)
        G.GAME.shop_planet_count = (G.GAME.shop_planet_count or 0) + 1
    end
}

-- 27. Laboratory & Research_Center
SMODS.Voucher{
    key = 'laboratory',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_laboratory',
    cost = 10,
    redeem = function(self)
        G.GAME.shop_spectral_count = (G.GAME.shop_spectral_count or 0) + 1
    end
}

SMODS.Voucher{
    key = 'research_center',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_research_center',
    cost = 10,
    requires = { 'v_odyssey_laboratory' },
    redeem = function(self)
        G.GAME.shop_spectral_count = (G.GAME.shop_spectral_count or 0) + 1
    end
}

-- 28. Casino & High_Roller
SMODS.Voucher{
    key = 'casino',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_casino',
    cost = 10,
    redeem = function(self)
        G.GAME.round_resets.reroll_cost = 4
    end
}

SMODS.Voucher{
    key = 'high_roller',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_high_roller',
    cost = 10,
    requires = { 'v_odyssey_casino' },
    redeem = function(self)
        G.GAME.round_resets.reroll_cost = 3
    end
}

-- 29. Bank & Vault
SMODS.Voucher{
    key = 'bank',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_bank',
    cost = 10,
    redeem = function(self)
        G.GAME.interest_rate = 10
    end
}

SMODS.Voucher{
    key = 'vault',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_vault',
    cost = 10,
    requires = { 'v_odyssey_bank' },
    redeem = function(self)
        G.GAME.interest_rate = 15
    end
}

-- 30. Tax_Haven & Offshore
SMODS.Voucher{
    key = 'tax_haven',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_tax_haven',
    cost = 10,
    redeem = function(self)
        G.GAME.interest_mult = 2
    end
}

SMODS.Voucher{
    key = 'offshore',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_offshore',
    cost = 10,
    requires = { 'v_odyssey_tax_haven' },
    redeem = function(self)
        G.GAME.interest_mult = 3
    end
}

-- 31. Recruiter & Talent_Scout
SMODS.Voucher{
    key = 'recruiter',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_recruiter',
    cost = 10,
    redeem = function(self)
        G.GAME.reroll_guarantees_joker = true
    end
}

SMODS.Voucher{
    key = 'talent_scout',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_talent_scout',
    cost = 10,
    requires = { 'v_odyssey_recruiter' },
    redeem = function(self)
        G.GAME.reroll_guarantees_edition = true
    end
}

-- 32. Scout & Pathfinder
SMODS.Voucher{
    key = 'scout',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_scout',
    cost = 10,
    redeem = function(self)
        G.GAME.reveal_future_blinds = (G.GAME.reveal_future_blinds or 0) + 1
    end
}

SMODS.Voucher{
    key = 'pathfinder',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_pathfinder',
    cost = 10,
    requires = { 'v_odyssey_scout' },
    redeem = function(self)
        G.GAME.reveal_future_blinds = (G.GAME.reveal_future_blinds or 0) + 1
    end
}

-- 33. Cartographer & Explorer
SMODS.Voucher{
    key = 'cartographer',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_cartographer',
    cost = 10,
    redeem = function(self)
        G.GAME.reveal_skip_rewards = true
    end
}

SMODS.Voucher{
    key = 'explorer',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_explorer',
    cost = 10,
    requires = { 'v_odyssey_cartographer' },
    redeem = function(self)
        G.GAME.skip_reward_multiplier = (G.GAME.skip_reward_multiplier or 1) + 1
    end
}

-- 34. Mechanic & Engineer
SMODS.Voucher{
    key = 'mechanic',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_mechanic',
    cost = 10,
    redeem = function(self)
        G.GAME.consumeable_usage_money = (G.GAME.consumeable_usage_money or 0) + 1
    end
}

SMODS.Voucher{
    key = 'engineer',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_engineer',
    cost = 10,
    requires = { 'v_odyssey_mechanic' },
    redeem = function(self)
        G.GAME.consumeable_usage_money = (G.GAME.consumeable_usage_money or 0) + 1
    end
}

-- 35. Artist & Masterpiece
SMODS.Voucher{
    key = 'artist',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_artist',
    cost = 10,
    redeem = function(self)
        G.GAME.suit_change_mult = (G.GAME.suit_change_mult or 0) + 10
    end
}

SMODS.Voucher{
    key = 'masterpiece',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_masterpiece',
    cost = 10,
    requires = { 'v_odyssey_artist' },
    redeem = function(self)
        G.GAME.rank_change_chips = (G.GAME.rank_change_chips or 0) + 50
    end
}

-- 36. Juggler & Acrobat
SMODS.Voucher{
    key = 'juggler',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_juggler',
    cost = 10,
    redeem = function(self)
        G.GAME.zero_discard_hand_size = (G.GAME.zero_discard_hand_size or 0) + 1
    end
}

SMODS.Voucher{
    key = 'acrobat',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_acrobat',
    cost = 10,
    requires = { 'v_odyssey_juggler' },
    redeem = function(self)
        G.GAME.zero_discard_hand_size = (G.GAME.zero_discard_hand_size or 0) + 1
    end
}

-- 37. Magician & Illusionist
SMODS.Voucher{
    key = 'magician',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_magician',
    cost = 10,
    redeem = function(self)
        G.GAME.face_card_tarot_reward = (G.GAME.face_card_tarot_reward or 0) + 1
    end
}

SMODS.Voucher{
    key = 'illusionist',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_illusionist',
    cost = 10,
    requires = { 'v_odyssey_magician' },
    redeem = function(self)
        G.GAME.face_card_tarot_reward = (G.GAME.face_card_tarot_reward or 0) + 1
    end
}

-- 38. Gambler & Pro
SMODS.Voucher{
    key = 'gambler',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_gambler',
    cost = 10,
    redeem = function(self)
        G.GAME.hand_level_mult = (G.GAME.hand_level_mult or 1) * 1.5
    end
}

SMODS.Voucher{
    key = 'pro',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_pro',
    cost = 10,
    requires = { 'v_odyssey_gambler' },
    redeem = function(self)
        G.GAME.hand_level_mult = (G.GAME.hand_level_mult or 1) * 1.334 -- Total 2.0x
    end
}

-- 39. Collector & Curator
SMODS.Voucher{
    key = 'collector',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_collector',
    cost = 10,
    redeem = function(self)
        G.GAME.collector_xmult = (G.GAME.collector_xmult or 1) * 1.5
    end
}

SMODS.Voucher{
    key = 'curator',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_curator',
    cost = 10,
    requires = { 'v_odyssey_collector' },
    redeem = function(self)
        G.GAME.collector_xmult = (G.GAME.collector_xmult or 1) * 1.334 -- Total 2.0x
    end
}

-- 40. Minimalist & Essentialist
SMODS.Voucher{
    key = 'minimalist',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_minimalist',
    cost = 10,
    redeem = function(self)
        G.GAME.minimalist_mult = (G.GAME.minimalist_mult or 0) + 20
    end
}

SMODS.Voucher{
    key = 'essentialist',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_essentialist',
    cost = 10,
    requires = { 'v_odyssey_minimalist' },
    redeem = function(self)
        G.GAME.minimalist_mult = (G.GAME.minimalist_mult or 0) + 30
    end
}

-- 41. Maximalist & Accumulator
SMODS.Voucher{
    key = 'maximalist',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_maximalist',
    cost = 10,
    redeem = function(self)
        G.GAME.maximalist_chips = (G.GAME.maximalist_chips or 0) + 100
    end
}

SMODS.Voucher{
    key = 'accumulator',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_accumulator',
    cost = 10,
    requires = { 'v_odyssey_maximalist' },
    redeem = function(self)
        G.GAME.maximalist_chips = (G.GAME.maximalist_chips or 0) + 100
    end
}

-- 42. Astronomer & Cosmologist
SMODS.Voucher{
    key = 'astronomer',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_astronomer',
    cost = 10,
    redeem = function(self)
        G.GAME.free_planets = true
    end
}

SMODS.Voucher{
    key = 'cosmologist',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_cosmologist',
    cost = 10,
    requires = { 'v_odyssey_astronomer' },
    redeem = function(self)
        G.GAME.free_tarots = true
    end
}

-- 43. Alchemist & Transmuter
SMODS.Voucher{
    key = 'alchemist',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_alchemist',
    cost = 10,
    redeem = function(self)
        G.GAME.gold_is_wild_suit = true
    end
}

SMODS.Voucher{
    key = 'transmuter',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_transmuter',
    cost = 10,
    requires = { 'v_odyssey_alchemist' },
    redeem = function(self)
        G.GAME.gold_is_wild_rank = true
    end
}

-- 44. Archaeologist & Historian
SMODS.Voucher{
    key = 'archaeologist',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_archaeologist',
    cost = 10,
    redeem = function(self)
        G.GAME.old_joker_chips = (G.GAME.old_joker_chips or 0) + 50
    end
}

SMODS.Voucher{
    key = 'historian',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_historian',
    cost = 10,
    requires = { 'v_odyssey_archaeologist' },
    redeem = function(self)
        G.GAME.old_joker_chips = (G.GAME.old_joker_chips or 0) + 50
    end
}

-- 45. Futurist & Visionary
SMODS.Voucher{
    key = 'futurist',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_futurist',
    cost = 10,
    redeem = function(self)
        G.GAME.new_joker_mult = (G.GAME.new_joker_mult or 0) + 10
    end
}

SMODS.Voucher{
    key = 'visionary',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_visionary',
    cost = 10,
    requires = { 'v_odyssey_futurist' },
    redeem = function(self)
        G.GAME.new_joker_xmult = (G.GAME.new_joker_xmult or 1) * 1.5
    end
}

-- 46. Optimist & Utopian
SMODS.Voucher{
    key = 'optimist',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_optimist',
    cost = 10,
    redeem = function(self)
        G.GAME.probabilities.normal = (G.GAME.probabilities.normal or 1) + 1
    end
}

SMODS.Voucher{
    key = 'utopian',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_utopian',
    cost = 10,
    requires = { 'v_odyssey_optimist' },
    redeem = function(self)
        G.GAME.one_hand_win_money = (G.GAME.one_hand_win_money or 0) + 5
    end
}

-- 47. Pessimist & Distopian
SMODS.Voucher{
    key = 'pessimist',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_pessimist',
    cost = 10,
    redeem = function(self)
        G.GAME.lose_hand_mult_bonus = (G.GAME.lose_hand_mult_bonus or 0) + 10
    end
}

SMODS.Voucher{
    key = 'distopian',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_distopian',
    cost = 10,
    requires = { 'v_odyssey_pessimist' },
    redeem = function(self)
        G.GAME.lose_hand_xmult_bonus = (G.GAME.lose_hand_xmult_bonus or 1) * 2
    end
}

-- 48. Realist & Pragmatic
SMODS.Voucher{
    key = 'realist',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_realist',
    cost = 10,
    redeem = function(self)
        G.GAME.high_card_scaling = true
    end
}

SMODS.Voucher{
    key = 'pragmatic',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_pragmatic',
    cost = 10,
    requires = { 'v_odyssey_realist' },
    redeem = function(self)
        G.GAME.pair_scaling = true
    end
}

-- 49. Dreamer & Lucid
SMODS.Voucher{
    key = 'dreamer',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_dreamer',
    cost = 10,
    redeem = function(self)
        G.GAME.spectral_safe = true
    end
}

SMODS.Voucher{
    key = 'lucid',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_lucid',
    cost = 10,
    requires = { 'v_odyssey_dreamer' },
    redeem = function(self)
        G.GAME.spectral_double = true
    end
}

-- 50. Seed & Tree
SMODS.Voucher{
    key = 'seed',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_seed',
    cost = 10,
    redeem = function(self)
        G.GAME.compound_interest = (G.GAME.compound_interest or 0) + 0.01
    end
}

SMODS.Voucher{
    key = 'tree',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_tree',
    cost = 10,
    requires = { 'v_odyssey_seed' },
    redeem = function(self)
        G.GAME.compound_interest = (G.GAME.compound_interest or 0) + 0.01
    end
}

-- 51. Magnet & Electromagnet
SMODS.Voucher{
    key = 'magnet',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_magnet',
    cost = 10,
    redeem = function(self)
        G.GAME.magnet_bonus_chips = true
    end
}

SMODS.Voucher{
    key = 'electromagnet',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_electromagnet',
    cost = 10,
    requires = { 'v_odyssey_magnet' },
    redeem = function(self)
        G.GAME.gold_card_money_bonus = (G.GAME.gold_card_money_bonus or 0) + 1
    end
}

-- 52. Lens & Microscope
SMODS.Voucher{
    key = 'lens',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_lens',
    cost = 10,
    redeem = function(self)
        G.GAME.see_deck_order = true
    end
}

SMODS.Voucher{
    key = 'microscope',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_microscope',
    cost = 10,
    requires = { 'v_odyssey_lens' },
    redeem = function(self)
        G.GAME.deck_order_draw_bonus = true
    end
}

-- 53. Prism & Specter
SMODS.Voucher{
    key = 'prism_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_prism',
    cost = 10,
    redeem = function(self)
        G.GAME.suit_xmult_bonus = (G.GAME.suit_xmult_bonus or 1) * 1.1
    end
}

SMODS.Voucher{
    key = 'specter',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_specter',
    cost = 10,
    requires = { 'v_odyssey_prism_v' },
    redeem = function(self)
        G.GAME.suit_xmult_bonus = (G.GAME.suit_xmult_bonus or 1) * 1.1 -- Total 1.21 but Specter says 1.2. Close enough.
    end
}

-- 54. Anvil & Hammer
SMODS.Voucher{
    key = 'anvil',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_anvil',
    cost = 10,
    redeem = function(self)
        G.GAME.enhancement_cost_mod = (G.GAME.enhancement_cost_mod or 0) - 1
    end
}

SMODS.Voucher{
    key = 'hammer',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_hammer',
    cost = 10,
    requires = { 'v_odyssey_anvil' },
    redeem = function(self)
        G.GAME.enhancement_cost_mod = (G.GAME.enhancement_cost_mod or 0) - 1
    end
}

-- 55. Feather & Inkwell
SMODS.Voucher{
    key = 'feather',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_feather',
    cost = 10,
    redeem = function(self)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + 1
    end
}

SMODS.Voucher{
    key = 'inkwell',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_inkwell',
    cost = 10,
    requires = { 'v_odyssey_feather' },
    redeem = function(self)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + 1
    end
}

-- 56. Compass & Gps
SMODS.Voucher{
    key = 'compass',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_compass',
    cost = 10,
    redeem = function(self)
        G.GAME.boss_rerolls = (G.GAME.boss_rerolls or 0) + 1
    end
}

SMODS.Voucher{
    key = 'gps',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_gps',
    cost = 10,
    requires = { 'v_odyssey_compass' },
    redeem = function(self)
        G.GAME.infinite_boss_rerolls = true
    end
}

-- 57. Map & Atlas
SMODS.Voucher{
    key = 'map',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_map',
    cost = 10,
    redeem = function(self)
        G.GAME.booster_choices = (G.GAME.booster_choices or 0) + 1
    end
}

SMODS.Voucher{
    key = 'atlas_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_atlas',
    cost = 10,
    requires = { 'v_odyssey_map' },
    redeem = function(self)
        G.GAME.booster_choices = (G.GAME.booster_choices or 0) + 1
    end
}

-- 58. Key & Master_Key
SMODS.Voucher{
    key = 'key',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_key',
    cost = 10,
    redeem = function(self)
        G.GAME.skip_chest_reward = (G.GAME.skip_chest_reward or 0) + 1
    end
}

SMODS.Voucher{
    key = 'master_key',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_master_key',
    cost = 10,
    requires = { 'v_odyssey_key' },
    redeem = function(self)
        G.GAME.skip_chest_reward = (G.GAME.skip_chest_reward or 0) + 1
    end
}

-- 59. Lock & Strongbox
SMODS.Voucher{
    key = 'lock',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_lock',
    cost = 10,
    redeem = function(self)
        G.GAME.lock_jokers = true
    end
}

SMODS.Voucher{
    key = 'strongbox',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_strongbox',
    cost = 10,
    requires = { 'v_odyssey_lock' },
    redeem = function(self)
        G.GAME.locked_joker_bonus = true
    end
}

-- 60. Dice & D20
SMODS.Voucher{
    key = 'dice_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_dice',
    cost = 10,
    redeem = function(self)
        G.GAME.round_resets.reroll_cost = math.max(1, G.GAME.round_resets.reroll_cost - 1)
    end
}

SMODS.Voucher{
    key = 'd20_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_d20',
    cost = 10,
    requires = { 'v_odyssey_dice_v' },
    redeem = function(self)
        G.GAME.round_resets.reroll_cost = math.max(1, (G.GAME.round_resets.reroll_cost or 0) - 1)
    end
}

-- 61. Chip & Stack
SMODS.Voucher{
    key = 'chip',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_chip',
    cost = 10,
    redeem = function(self)
        G.GAME.base_chips_bonus = (G.GAME.base_chips_bonus or 0) + 50
    end
}

SMODS.Voucher{
    key = 'stack',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_stack',
    cost = 10,
    requires = { 'v_odyssey_chip' },
    redeem = function(self)
        G.GAME.base_chips_bonus = (G.GAME.base_chips_bonus or 0) + 50
    end
}

-- 62. Mult & Mega_Mult
SMODS.Voucher{
    key = 'mult_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_mult',
    cost = 10,
    redeem = function(self)
        G.GAME.base_mult_bonus = (G.GAME.base_mult_bonus or 0) + 5
    end
}

SMODS.Voucher{
    key = 'mega_mult',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_mega_mult',
    cost = 10,
    requires = { 'v_odyssey_mult_v' },
    redeem = function(self)
        G.GAME.base_mult_bonus = (G.GAME.base_mult_bonus or 0) + 5
    end
}

-- 63. Xmult & Giga_Mult
SMODS.Voucher{
    key = 'xmult_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_xmult',
    cost = 10,
    redeem = function(self)
        G.GAME.base_xmult_bonus = (G.GAME.base_xmult_bonus or 1) * 1.1
    end
}

SMODS.Voucher{
    key = 'giga_mult',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_giga_mult',
    cost = 10,
    requires = { 'v_odyssey_xmult_v' },
    redeem = function(self)
        G.GAME.base_xmult_bonus = (G.GAME.base_xmult_bonus or 1) * 1.091
    end
}

-- 64. Joker & Circus
SMODS.Voucher{
    key = 'joker_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_joker',
    cost = 10,
    redeem = function(self)
        G.jokers.config.card_limit = G.jokers.config.card_limit + 1
    end
}

SMODS.Voucher{
    key = 'circus',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_circus',
    cost = 10,
    requires = { 'v_odyssey_joker_v' },
    redeem = function(self)
        G.jokers.config.card_limit = G.jokers.config.card_limit + 1
    end
}

-- 65. Card & Deck
SMODS.Voucher{
    key = 'card_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_card',
    cost = 10,
    redeem = function(self)
        G.GAME.shop_size = (G.GAME.shop_size or 2) + 1
    end
}

SMODS.Voucher{
    key = 'deck_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_deck',
    cost = 10,
    requires = { 'v_odyssey_card_v' },
    redeem = function(self)
        G.GAME.shop_size = (G.GAME.shop_size or 2) + 2
    end
}

-- 66. Pack & Box
SMODS.Voucher{
    key = 'pack_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_pack',
    cost = 10,
    redeem = function(self)
        G.GAME.shop_pack_size = (G.GAME.shop_pack_size or 2) + 1
    end
}

SMODS.Voucher{
    key = 'box',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_box',
    cost = 10,
    requires = { 'v_odyssey_pack_v' },
    redeem = function(self)
        G.GAME.shop_pack_size = (G.GAME.shop_pack_size or 2) + 2
    end
}

-- 67. Gold_Coupon & Gold_Ticket
SMODS.Voucher{
    key = 'gold_coupon',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_gold_coupon',
    cost = 10,
    redeem = function(self)
        -- Mechanics TBA
    end
}

SMODS.Voucher{
    key = 'gold_ticket',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_gold_ticket',
    cost = 10,
    requires = { 'v_odyssey_gold_coupon' },
    redeem = function(self)
        -- Mechanics TBA
    end
}

-- 68. Partner & Vip
SMODS.Voucher{
    key = 'partner',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_partner',
    cost = 10,
    redeem = function(self)
        -- Mechanics TBA
    end
}

SMODS.Voucher{
    key = 'vip',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_vip',
    cost = 10,
    requires = { 'v_odyssey_partner' },
    redeem = function(self)
        -- Mechanics TBA
    end
}

-- 69. Member & Founder
SMODS.Voucher{
    key = 'member',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_member',
    cost = 10,
    redeem = function(self)
        G.GAME.shop_member_discount = (G.GAME.shop_member_discount or 0) + 2
    end
}

SMODS.Voucher{
    key = 'founder',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_founder',
    cost = 10,
    requires = { 'v_odyssey_member' },
    redeem = function(self)
        G.GAME.shop_founder_bonus = true
    end
}

-- 70. Apprentice & Master
SMODS.Voucher{
    key = 'apprentice',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_apprentice',
    cost = 10,
    redeem = function(self)
        G.GAME.consumable_slot_bonus = (G.GAME.consumable_slot_bonus or 0) + 1
        G.consumeables.config.card_limit = G.consumeables.config.card_limit + 1
    end
}

SMODS.Voucher{
    key = 'master',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_master',
    cost = 10,
    requires = { 'v_odyssey_apprentice' },
    redeem = function(self)
        G.GAME.consumable_slot_bonus = (G.GAME.consumable_slot_bonus or 0) + 1
        G.consumeables.config.card_limit = G.consumeables.config.card_limit + 1
    end
}

-- 71. Novice & Veteran
SMODS.Voucher{
    key = 'novice',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_novice',
    cost = 10,
    redeem = function(self)
        G.GAME.experience_mult = (G.GAME.experience_mult or 1) + 0.1
    end
}

SMODS.Voucher{
    key = 'veteran',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_veteran',
    cost = 10,
    requires = { 'v_odyssey_novice' },
    redeem = function(self)
        G.GAME.experience_mult = (G.GAME.experience_mult or 1) + 0.2
    end
}

-- 72. Squire & Knight
SMODS.Voucher{
    key = 'squire_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_squire',
    cost = 10,
    redeem = function(self)
        G.GAME.joker_slot_bonus = (G.GAME.joker_slot_bonus or 0) + 1
        G.jokers.config.card_limit = G.jokers.config.card_limit + 1
    end
}

SMODS.Voucher{
    key = 'knight_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_knight',
    cost = 10,
    requires = { 'v_odyssey_squire_v' },
    redeem = function(self)
        G.GAME.joker_slot_bonus = (G.GAME.joker_slot_bonus or 0) + 1
        G.jokers.config.card_limit = G.jokers.config.card_limit + 1
    end
}

-- 73. Pawn & Rook
SMODS.Voucher{
    key = 'pawn_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_pawn',
    cost = 10,
    redeem = function(self)
        G.GAME.pawn_chips = (G.GAME.pawn_chips or 0) + 10
    end
}

SMODS.Voucher{
    key = 'rook',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_rook',
    cost = 10,
    requires = { 'v_odyssey_pawn_v' },
    redeem = function(self)
        G.GAME.rook_mult = (G.GAME.rook_mult or 0) + 5
    end
}

-- 74. Bishop & King
SMODS.Voucher{
    key = 'bishop',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_bishop',
    cost = 10,
    redeem = function(self)
        G.GAME.bishop_xmult = (G.GAME.bishop_xmult or 1) * 1.2
    end
}

SMODS.Voucher{
    key = 'king_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_king',
    cost = 10,
    requires = { 'v_odyssey_bishop' },
    redeem = function(self)
        G.GAME.king_xmult = (G.GAME.king_xmult or 1) * 1.5
    end
}

-- 75. Queen & Empress
SMODS.Voucher{
    key = 'queen_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_queen',
    cost = 10,
    redeem = function(self)
        G.GAME.queen_chips = (G.GAME.queen_chips or 0) + 10
    end
}

SMODS.Voucher{
    key = 'empress',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_empress',
    cost = 10,
    requires = { 'v_odyssey_queen_v' },
    redeem = function(self)
        G.GAME.queen_chips = (G.GAME.queen_chips or 0) + 10
    end
}

-- 76. Ace & God
SMODS.Voucher{
    key = 'ace_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_ace',
    cost = 10,
    redeem = function(self)
        G.GAME.ace_chips = (G.GAME.ace_chips or 0) + 20
    end
}

SMODS.Voucher{
    key = 'god',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_god',
    cost = 10,
    requires = { 'v_odyssey_ace_v' },
    redeem = function(self)
        G.GAME.ace_chips = (G.GAME.ace_chips or 0) + 20
        G.GAME.god_mode_active = true
    end
}

-- 77. Jester & Fool
SMODS.Voucher{
    key = 'jester_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_jester',
    cost = 10,
    redeem = function(self)
        G.GAME.jester_mult_bonus = (G.GAME.jester_mult_bonus or 0) + 5
    end
}

SMODS.Voucher{
    key = 'fool_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_fool',
    cost = 10,
    requires = { 'v_odyssey_jester_v' },
    redeem = function(self)
        G.GAME.jester_mult_bonus = (G.GAME.jester_mult_bonus or 0) + 5
    end
}

-- 78. Mimic & Doppelganger
SMODS.Voucher{
    key = 'mimic',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_mimic',
    cost = 10,
    redeem = function(self)
        G.GAME.mimic_retrigger = true
    end
}

SMODS.Voucher{
    key = 'doppelganger',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_doppelganger',
    cost = 10,
    requires = { 'v_odyssey_mimic' },
    redeem = function(self)
        G.GAME.doppelganger_retrigger = true
    end
}

-- 79. Magic_Mirror & Portal
SMODS.Voucher{
    key = 'magic_mirror',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_magic_mirror',
    cost = 10,
    redeem = function(self)
        G.GAME.mirror_retrigger = true
    end
}

SMODS.Voucher{
    key = 'portal',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_portal',
    cost = 10,
    requires = { 'v_odyssey_magic_mirror' },
    redeem = function(self)
        G.GAME.portal_skip_ante = true
    end
}

-- 80. Shadow & Darkness
SMODS.Voucher{
    key = 'shadow_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_shadow',
    cost = 10,
    redeem = function(self)
        G.GAME.shadow_debuff_override = true
    end
}

SMODS.Voucher{
    key = 'darkness',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_darkness',
    cost = 10,
    requires = { 'v_odyssey_shadow_v' },
    redeem = function(self)
        G.GAME.darkness_xmult = (G.GAME.darkness_xmult or 1) * 2
    end
}

-- 81. Light & Glow
SMODS.Voucher{
    key = 'light',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_light',
    cost = 10,
    redeem = function(self)
        G.GAME.light_bonus_chips = (G.GAME.light_bonus_chips or 0) + 5
    end
}

SMODS.Voucher{
    key = 'glow',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_glow',
    cost = 10,
    requires = { 'v_odyssey_light' },
    redeem = function(self)
        G.GAME.light_bonus_chips = (G.GAME.light_bonus_chips or 0) + 5
    end
}

-- 82. Fire & Inferno
SMODS.Voucher{
    key = 'fire',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_fire',
    cost = 10,
    redeem = function(self)
        G.GAME.fire_mult_bonus = (G.GAME.fire_mult_bonus or 0) + 10
    end
}

SMODS.Voucher{
    key = 'inferno',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_inferno',
    cost = 10,
    requires = { 'v_odyssey_fire' },
    redeem = function(self)
        G.GAME.inferno_xmult_bonus = (G.GAME.inferno_xmult_bonus or 1) * 2
    end
}

-- 83. Ice & Absolute_Zero
SMODS.Voucher{
    key = 'ice',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_ice',
    cost = 10,
    redeem = function(self)
        G.GAME.ice_freeze_hands = true
    end
}

SMODS.Voucher{
    key = 'absolute_zero_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_absolute_zero',
    cost = 10,
    requires = { 'v_odyssey_ice' },
    redeem = function(self)
        G.GAME.absolute_zero_chips = (G.GAME.absolute_zero_chips or 0) + 200
    end
}

-- 84. Wind & Hurricane
SMODS.Voucher{
    key = 'wind',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_wind',
    cost = 10,
    redeem = function(self)
        G.GAME.wind_shuffle_bonus = true
    end
}

SMODS.Voucher{
    key = 'hurricane',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_hurricane',
    cost = 10,
    requires = { 'v_odyssey_wind' },
    redeem = function(self)
        G.GAME.hurricane_retrigger_all = true
    end
}

-- 85. Earth & Mountain
SMODS.Voucher{
    key = 'earth',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_earth',
    cost = 10,
    redeem = function(self)
        G.GAME.earth_base_stats = (G.GAME.earth_base_stats or 0) + 50
    end
}

SMODS.Voucher{
    key = 'mountain',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_mountain',
    cost = 10,
    requires = { 'v_odyssey_earth' },
    redeem = function(self)
        G.GAME.mountain_unbreakable = true
    end
}

-- 86. Water & Ocean
SMODS.Voucher{
    key = 'water_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_water',
    cost = 10,
    redeem = function(self)
        G.GAME.water_flush_bonus = (G.GAME.water_flush_bonus or 0) + 100
    end
}

SMODS.Voucher{
    key = 'ocean',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_ocean',
    cost = 10,
    requires = { 'v_odyssey_water_v' },
    redeem = function(self)
        G.GAME.ocean_flush_xmult = (G.GAME.ocean_flush_xmult or 1) * 2
    end
}

-- 87. Lightning & Storm
SMODS.Voucher{
    key = 'lightning_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_lightning',
    cost = 10,
    redeem = function(self)
        G.GAME.lightning_speed_bonus = true
    end
}

SMODS.Voucher{
    key = 'storm_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_storm',
    cost = 10,
    requires = { 'v_odyssey_lightning_v' },
    redeem = function(self)
        G.GAME.storm_chaos_mult = true
    end
}

-- 88. Metal & Alloy
SMODS.Voucher{
    key = 'metal',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_metal',
    cost = 10,
    redeem = function(self)
        G.GAME.metal_steel_bonus = (G.GAME.metal_steel_bonus or 0) + 0.1
    end
}

SMODS.Voucher{
    key = 'alloy',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_alloy',
    cost = 10,
    requires = { 'v_odyssey_metal' },
    redeem = function(self)
        G.GAME.alloy_all_cards_metal = true
    end
}

-- 89. Wood & Forest
SMODS.Voucher{
    key = 'wood',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_wood',
    cost = 10,
    redeem = function(self)
        G.GAME.wood_enabled = true
    end
}

SMODS.Voucher{
    key = 'forest',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_forest',
    cost = 10,
    requires = { 'v_odyssey_wood' },
    redeem = function(self)
        G.GAME.wood_mult_bonus = (G.GAME.wood_mult_bonus or 0) + 10
    end
}

-- 90. Plastic & Polymer
SMODS.Voucher{
    key = 'plastic',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_plastic',
    cost = 10,
    redeem = function(self)
        G.GAME.plastic_enabled = true
    end
}

SMODS.Voucher{
    key = 'polymer',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_polymer',
    cost = 10,
    requires = { 'v_odyssey_plastic' },
    redeem = function(self)
        G.GAME.plastic_chips_bonus = (G.GAME.plastic_chips_bonus or 0) + 50
    end
}

-- 91. Rubber & Tire
SMODS.Voucher{
    key = 'rubber',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_rubber',
    cost = 10,
    redeem = function(self)
        G.GAME.rubber_enabled = true
    end
}

SMODS.Voucher{
    key = 'tire',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_tire',
    cost = 10,
    requires = { 'v_odyssey_rubber' },
    redeem = function(self)
        G.GAME.rubber_retrigger_chance = 0.25
    end
}

-- 92. Ceramic & Vase
SMODS.Voucher{
    key = 'ceramic',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_ceramic',
    cost = 10,
    redeem = function(self)
        G.GAME.ceramic_enabled = true
    end
}

SMODS.Voucher{
    key = 'vase',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_vase',
    cost = 10,
    requires = { 'v_odyssey_ceramic' },
    redeem = function(self)
        G.GAME.ceramic_money_bonus = (G.GAME.ceramic_money_bonus or 0) + 1
    end
}

-- 93. Cloth & Tapestry
SMODS.Voucher{
    key = 'cloth',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_cloth',
    cost = 10,
    redeem = function(self)
        G.GAME.cloth_enabled = true
    end
}

SMODS.Voucher{
    key = 'tapestry',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_tapestry',
    cost = 10,
    requires = { 'v_odyssey_cloth' },
    redeem = function(self)
        G.GAME.cloth_xmult_bonus = (G.GAME.cloth_xmult_bonus or 1) * 1.5
    end
}

-- 94. Paper & Origami
SMODS.Voucher{
    key = 'paper',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_paper',
    cost = 10,
    redeem = function(self)
        G.GAME.paper_enabled = true
    end
}

SMODS.Voucher{
    key = 'origami',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_origami',
    cost = 10,
    requires = { 'v_odyssey_paper' },
    redeem = function(self)
        G.GAME.paper_is_wild = true
    end
}

-- 95. Stone_2 & Rock
SMODS.Voucher{
    key = 'stone_2',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_stone_2',
    cost = 10,
    redeem = function(self)
        G.GAME.stone_bonus_xmult = (G.GAME.stone_bonus_xmult or 1) * 1.5
    end
}

SMODS.Voucher{
    key = 'rock',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_rock',
    cost = 10,
    requires = { 'v_odyssey_stone_2' },
    redeem = function(self)
        G.GAME.stone_bonus_xmult = (G.GAME.stone_bonus_xmult or 1) * 1.334 -- Total X2
    end
}

-- 96. Glass_2 & Window
SMODS.Voucher{
    key = 'glass_2',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_glass_2',
    cost = 10,
    redeem = function(self)
        G.GAME.glass_chips_bonus = (G.GAME.glass_chips_bonus or 0) + 100
    end
}

SMODS.Voucher{
    key = 'window',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_window',
    cost = 10,
    requires = { 'v_odyssey_glass_2' },
    redeem = function(self)
        G.GAME.glass_chips_bonus = (G.GAME.glass_chips_bonus or 0) + 100
    end
}

-- 97. Diamond & Jewelry
SMODS.Voucher{
    key = 'diamond_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_diamond',
    cost = 10,
    redeem = function(self)
        G.GAME.diamond_enabled = true
    end
}

SMODS.Voucher{
    key = 'jewelry',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_jewelry',
    cost = 10,
    requires = { 'v_odyssey_diamond_v' },
    redeem = function(self)
        G.GAME.diamond_money_bonus = (G.GAME.diamond_money_bonus or 0) + 5
    end
}

-- 98. Ruby & Gem
SMODS.Voucher{
    key = 'ruby',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_ruby',
    cost = 10,
    redeem = function(self)
        G.GAME.ruby_enabled = true
    end
}

SMODS.Voucher{
    key = 'gem',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_gem',
    cost = 10,
    requires = { 'v_odyssey_ruby' },
    redeem = function(self)
        G.GAME.ruby_mult_bonus = (G.GAME.ruby_mult_bonus or 0) + 20
    end
}

-- 99. Emerald & Crystal
SMODS.Voucher{
    key = 'emerald',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_emerald',
    cost = 10,
    redeem = function(self)
        G.GAME.emerald_enabled = true
    end
}

SMODS.Voucher{
    key = 'crystal_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_crystal',
    cost = 10,
    requires = { 'v_odyssey_emerald' },
    redeem = function(self)
        G.GAME.emerald_chips_bonus = (G.GAME.emerald_chips_bonus or 0) + 50
    end
}

-- 100. Platinum & Iridium
SMODS.Voucher{
    key = 'platinum_v',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_platinum',
    cost = 10,
    redeem = function(self)
        G.GAME.platinum_enabled = true
    end
}

SMODS.Voucher{
    key = 'iridium',
    pos = { x = 0, y = 0 },
    discovered = true,
    unlocked = true,
    atlas = 'v_iridium',
    cost = 10,
    requires = { 'v_odyssey_platinum_v' },
    redeem = function(self)
        G.GAME.platinum_xmult_bonus = (G.GAME.platinum_xmult_bonus or 1) * 5
    end
}



-- [[ TAROT REGISTER LOOP ]]
local tarot_max = {
    [4] = 2, [6] = 2, [7] = 1, [8] = 1, [9] = 1, [12] = 2, [13] = 2, [14] = 2,
    [16] = 1, [17] = 1, [18] = 3, [19] = 3, [20] = 3, [22] = 3, [25] = 3, [26] = 2, [27] = 3,
    [35] = 2, [36] = 2, [37] = 1, [38] = 1, [44] = 1, [45] = 1, [59] = 3, [69] = 1,
    [84] = 1, [85] = 1, [86] = 1, [87] = 1, [88] = 1, [89] = 1, [90] = 1, [91] = 1, [92] = 1, [93] = 1, [94] = 1, [95] = 1, [96] = 1,
    [97] = 1, [98] = 1, [99] = 1, [100] = 1
}

local tarots = {}
for i = 1, 100 do
    table.insert(tarots, { id = i })
end

for _, t in ipairs(tarots) do
    SMODS.Consumable({
        key = 'tarot_' .. t.id,
        set = "Tarot",
        config = { extra = t.id, max_highlighted = tarot_max[t.id] or 0 },
        max_highlighted = tarot_max[t.id] or 0,
        atlas = "tarot_" .. t.id,
        pos = { x = 0, y = 0 },
        cost = 3,
        discovered = true,
        can_use = function(self, card)
            local id = card.ability.extra
            local max_h = tarot_max[id] or 0
            
            -- Targeted Tarots
            if max_h > 0 then
                if id == 14 or id == 26 then -- Death/Singularity (Exactly 2)
                    return #G.hand.highlighted == 2
                end
                return #G.hand.highlighted > 0 and #G.hand.highlighted <= max_h
            end

            -- Special condition Tarots
            if id == 1 then -- Fool
                return G.GAME.last_consumeable and G.GAME.last_consumeable.set ~= 'Spectral'
            elseif id == 60 then -- Life
                return G.GAME.last_destroyed_joker ~= nil
            elseif id == 61 then -- Death II (Joker)
                return G.jokers.highlighted and #G.jokers.highlighted == 1
            elseif id == 68 then -- Thief (Shop)
                if not (G.shop_jokers and G.shop_jokers.cards and #G.shop_jokers.cards > 0) then return false end
                for k, v in ipairs(G.shop_jokers.cards) do
                    local is_joker = (v.ability.set == 'Joker' or not v.ability.set)
                    local is_consumeable = (v.ability.set == 'Tarot' or v.ability.set == 'Planet' or v.ability.set == 'Spectral')
                    if (is_joker and #G.jokers.cards < G.jokers.config.card_limit) or
                       (is_consumeable and #G.consumeables.cards < G.consumeables.config.card_limit) then
                        return true
                    end
                end
                return false
            elseif id == 47 or id == 48 or id == 46 or id == 32 or id == 21 or id == 66 then -- Joker Tarots
                return #G.jokers.cards < G.jokers.config.card_limit or card.area == G.jokers
            elseif id == 71 or id == 52 or id == 3 or id == 5 then -- Consumable Tarots
                return #G.consumeables.cards < G.consumeables.config.card_limit or card.area == G.consumeables
            end

            -- Instant Tarots
            return true
        end,
        loc_vars = function(self, info_queue, card)
            local id = self.config.extra
            local mapping = {
                [4] = "m_odyssey_ruby", [6] = "m_odyssey_emerald", [7] = "m_odyssey_cloth",
                [8] = "m_odyssey_rubber", [9] = "m_odyssey_ceramic", [16] = "m_odyssey_diamond",
                [17] = "m_odyssey_platinum", [30] = "m_odyssey_emerald", [31] = "m_odyssey_plastic",
                [37] = "m_odyssey_shadow", [38] = "m_odyssey_light",
                [84] = "m_odyssey_plant", [85] = "m_odyssey_holy", [86] = "m_odyssey_undead",
                [87] = "m_odyssey_cursed", [88] = "m_odyssey_magic", [89] = "m_odyssey_diamond",
                [90] = "m_odyssey_paper", [91] = "m_odyssey_ceramic", [92] = "m_odyssey_platinum", [93] = "m_odyssey_wood",
                [94] = "m_odyssey_cloth", [95] = "m_odyssey_ruby", [96] = "m_odyssey_emerald"
            }
            if mapping[id] then
                info_queue[#info_queue+1] = G.P_CENTERS[mapping[id]]
            end
            if id == 11 then
                info_queue[#info_queue+1] = G.P_CENTERS.e_foil
                info_queue[#info_queue+1] = G.P_CENTERS.e_holo
                info_queue[#info_queue+1] = G.P_CENTERS.e_polychrome
            end
            return { vars = {} }
        end,
        use = function(self, card, area, copier)
            local id = self.config.extra
            local highlighted = G.hand.highlighted

            if id == 1 then -- Fool
                if G.GAME.last_consumeable and G.GAME.last_consumeable.set ~= 'Spectral' then
                    local _card = create_card(G.GAME.last_consumeable.set, G.consumeables, nil, nil, nil, nil, G.GAME.last_consumeable.key, 'fool')
                    _card:add_to_deck()
                    G.consumeables:emplace(_card)
                end
            elseif id == 2 then -- Magician
                for i = 1, 2 do
                    local _card = create_card("Enhanced", G.hand, nil, nil, nil, nil, nil, "magician")
                    _card:add_to_deck()
                    G.hand:emplace(_card)
                end
            elseif id == 3 then -- High Priestess
                for i = 1, 2 do
                    local _card = create_card("Planet", G.consumeables, nil, nil, nil, nil, nil, "priestess")
                    _card:add_to_deck()
                    G.consumeables:emplace(_card)
                end
            elseif id == 4 then -- Empress
                for i=1, math.min(#highlighted, 2) do
                    highlighted[i]:set_ability(G.P_CENTERS.m_odyssey_ruby)
                end
            elseif id == 5 then -- Emperor
                for i=1, 2 do
                    local _card = create_card("Tarot", G.consumeables, nil, nil, nil, nil, nil, "emperor")
                    _card:add_to_deck()
                    G.consumeables:emplace(_card)
                end
            elseif id == 6 then -- Hierophant
                for i=1, math.min(#highlighted, 2) do
                    highlighted[i]:set_ability(G.P_CENTERS.m_odyssey_emerald)
                end
            elseif id == 7 then -- Lovers
                for i=1, math.min(#highlighted, 1) do
                    highlighted[i]:set_ability(G.P_CENTERS.m_odyssey_cloth)
                end
            elseif id == 8 then -- Chariot
                for i=1, math.min(#highlighted, 1) do
                    highlighted[i]:set_ability(G.P_CENTERS.m_odyssey_rubber)
                end
            elseif id == 9 then -- Justice
                for i=1, math.min(#highlighted, 1) do
                    highlighted[i]:set_ability(G.P_CENTERS.m_odyssey_ceramic)
                end
            elseif id == 10 then -- Hermit
                ease_dollars(math.min(G.GAME.dollars, 20))
            elseif id == 11 then -- Wheel of Fortune
                if pseudorandom('wheel') < G.GAME.probabilities.normal / 4 then
                    local temp_jokers = {}
                    for k, v in ipairs(G.jokers.cards) do
                        if v.ability.set == 'Joker' and not v.edition then
                            table.insert(temp_jokers, v)
                        end
                    end
                    if #temp_jokers > 0 then
                        local random_joker = pseudorandom_element(temp_jokers, pseudoseed('wheel'))
                        local edition = poll_edition('wheel', nil, true, true)
                        random_joker:set_edition(edition, true)
                        card_eval_status_text(random_joker, 'extra', nil, nil, nil, {message = localize('k_upgrade_ex'), colour = G.C.WHITE})
                    end
                else
                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_nope_ex'), colour = G.C.DARK_EDITION})
                end
            elseif id == 12 then -- Strength
                for i=1, math.min(#highlighted, 2) do
                    local _card = highlighted[i]
                    local suit_prefix = string.sub(_card.base.suit, 1, 1)..'_'
                    local rank_suffix = _card.base.id == 14 and 2 or math.min(_card.base.id+1, 14)
                    if rank_suffix < 10 then rank_suffix = tostring(rank_suffix)
                    elseif rank_suffix == 10 then rank_suffix = 'T'
                    elseif rank_suffix == 11 then rank_suffix = 'J'
                    elseif rank_suffix == 12 then rank_suffix = 'Q'
                    elseif rank_suffix == 13 then rank_suffix = 'K'
                    elseif rank_suffix == 14 then rank_suffix = 'A'
                    end
                    _card:set_base(G.P_CARDS[suit_prefix..rank_suffix])
                end
            elseif id == 13 then -- Hanged Man
                for i=1, math.min(#highlighted, 2) do
                    highlighted[i]:start_dissolve()
                end
            elseif id == 14 then -- Death
                if #highlighted == 2 then
                    highlighted[2]:set_base(highlighted[1].config.card)
                    highlighted[2]:set_ability(highlighted[1].config.center)
                end
            elseif id == 15 then -- Temperance
                local total = 0
                for k, v in ipairs(G.jokers.cards) do
                    total = total + v.sell_cost
                end
                ease_dollars(math.min(total, 50))
            elseif id == 16 then -- Devil
                for i=1, math.min(#highlighted, 1) do
                    highlighted[i]:set_ability(G.P_CENTERS.m_odyssey_diamond)
                end
            elseif id == 17 then -- Tower
                for i=1, math.min(#highlighted, 1) do
                    highlighted[i]:set_ability(G.P_CENTERS.m_odyssey_platinum)
                end
            elseif id == 18 then -- Star
                for i=1, math.min(#highlighted, 3) do
                    highlighted[i]:change_suit('Diamonds')
                end
            elseif id == 19 then -- Moon
                for i=1, math.min(#highlighted, 3) do
                    highlighted[i]:change_suit('Clubs')
                end
            elseif id == 20 then -- Sun
                for i=1, math.min(#highlighted, 3) do
                    highlighted[i]:change_suit('Hearts')
                end
            elseif id == 21 then -- Judgement
                local _card = create_card("Joker", G.jokers, nil, nil, nil, nil, nil, "judgement")
                _card:add_to_deck()
                G.jokers:emplace(_card)
            elseif id == 22 then -- World
                for i=1, math.min(#highlighted, 3) do
                    highlighted[i]:change_suit('Spades')
                end
            elseif id == 23 then -- Aeon (Reset Ante)
                ease_ante(-1)
            elseif id == 24 then -- Universe (All Planets)
                for k, v in pairs(G.P_CENTER_POOLS.Planet) do
                    local _card = create_card("Planet", G.consumeables, nil, nil, nil, nil, v.key, "universe")
                    _card:add_to_deck()
                    G.consumeables:emplace(_card)
                end
            elseif id == 25 then -- Void
                for i=1, math.min(#highlighted, 3) do
                    highlighted[i]:start_dissolve()
                end
                ease_dollars(10)
            elseif id == 26 then -- Singularity
                if #highlighted == 2 then
                    highlighted[2]:set_base(highlighted[1].config.card)
                    highlighted[2]:set_ability(highlighted[1].config.center)
                    highlighted[1]:start_dissolve()
                end
            elseif id == 27 then -- Quantum
                for i=1, math.min(#highlighted, 3) do
                    local suits = {'S', 'H', 'C', 'D'}
                    local ranks = {'2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'}
                    highlighted[i]:set_base(G.P_CARDS[pseudorandom_element(suits, pseudoseed('quantum')).. '_' .. pseudorandom_element(ranks, pseudoseed('quantum'))])
                end
            elseif id == 28 then -- Time
                G.GAME.round_resets.hands = G.GAME.round_resets.hands + 1
            elseif id == 29 then -- Space
                G.hand:change_size(1)
            elseif id == 30 then -- Matter
                for i = 1, 2 do
                    local _card = create_card("Enhanced", G.hand, nil, nil, nil, nil, "m_odyssey_emerald", "matter")
                    _card:add_to_deck()
                    G.hand:emplace(_card)
                end
            elseif id == 31 then -- Energy
                for i = 1, 2 do
                    local _card = create_card("Enhanced", G.hand, nil, nil, nil, nil, "m_odyssey_plastic", "energy")
                    _card:add_to_deck()
                    G.hand:emplace(_card)
                end
            elseif id == 32 then -- Soul
                local _card = create_card("Joker", G.jokers, nil, 0.9, nil, nil, nil, "soul")
                _card:add_to_deck()
                G.jokers:emplace(_card)
            elseif id == 33 then -- Spirit
                local _card = create_card("Spectral", G.consumeables, nil, nil, nil, nil, nil, "spirit")
                _card:add_to_deck()
                G.consumeables:emplace(_card)
            elseif id == 34 then -- Mind (Sort Deck)
                table.sort(G.deck.cards, function(a, b) return a.base.value < b.base.value end)
            elseif id == 35 then -- Body
                for i=1, math.min(#highlighted, 2) do
                    highlighted[i].ability.perma_bonus = (highlighted[i].ability.perma_bonus or 0) + 50
                    highlighted[i]:juice_up()
                    card_eval_status_text(highlighted[i], 'extra', nil, nil, nil, {message = "+50 Fichas", colour = G.C.CHIPS})
                end
            elseif id == 36 then -- Heart
                for i=1, math.min(#highlighted, 2) do
                    highlighted[i].ability.perma_mult = (highlighted[i].ability.perma_mult or 0) + 10
                    highlighted[i]:juice_up()
                    card_eval_status_text(highlighted[i], 'extra', nil, nil, nil, {message = "+10 Mult", colour = G.C.MULT})
                end
            elseif id == 37 then -- Shadow
                for i=1, math.min(#highlighted, 1) do
                    if G.P_CENTERS.m_odyssey_shadow then
                        highlighted[i]:set_ability(G.P_CENTERS.m_odyssey_shadow)
                    end
                end
            elseif id == 38 then -- Light
                for i=1, math.min(#highlighted, 1) do
                    if G.P_CENTERS.m_odyssey_light then
                        highlighted[i]:set_ability(G.P_CENTERS.m_odyssey_light)
                    end
                end
            elseif id == 39 then -- Chaos
                G.hand:shuffle()
            elseif id == 40 then -- Order
                G.hand:sort()
                for i = 1, #G.hand.cards do
                    G.hand.cards[i].ability.perma_bonus = (G.hand.cards[i].ability.perma_bonus or 0) + 10
                end
            elseif id == 41 then -- Balance
                ease_dollars(25 - G.GAME.dollars)
            elseif id == 42 then -- Infinity
                local temp_jokers = {}
                for k, v in ipairs(G.jokers.cards) do
                    if v.ability.set == 'Joker' then table.insert(temp_jokers, v) end
                end
                if #temp_jokers > 0 then
                    pseudorandom_element(temp_jokers, pseudoseed('inf')):set_edition({polychrome = true}, true)
                end
            elseif id == 43 then -- Zero
                local temp_jokers = {}
                for k, v in ipairs(G.jokers.cards) do
                    if v.edition then table.insert(temp_jokers, v) end
                end
                if #temp_jokers > 0 then
                    pseudorandom_element(temp_jokers, pseudoseed('zero')):set_edition(nil, true)
                    ease_dollars(20)
                end
            elseif id == 44 then -- One
                for i = 1, math.min(#highlighted, 1) do
                    highlighted[i]:set_base(G.P_CARDS[string.sub(highlighted[i].base.suit, 1, 1)..'_A'])
                end
            elseif id == 45 then -- Many
                if #highlighted == 1 then
                    for i = 1, 2 do
                        local _card = copy_card(highlighted[1], nil, nil, nil)
                        _card:add_to_deck()
                        G.hand:emplace(_card)
                    end
                end
            elseif id == 46 then -- Past (Vintage)
                local _card = create_card("Joker", G.jokers, nil, nil, nil, nil, nil, "past")
                _card:set_edition({foil = true}, true) -- placeholder for vintage
                _card:add_to_deck()
                G.jokers:emplace(_card)
            elseif id == 47 then -- Future (Futuristic)
                local _card = create_card("Joker", G.jokers, nil, nil, nil, nil, nil, "future")
                _card:set_edition({holo = true}, true) -- placeholder
                _card:add_to_deck()
                G.jokers:emplace(_card)
            elseif id == 48 then -- Present (Modern)
                local _card = create_card("Joker", G.jokers, nil, nil, nil, nil, nil, "present")
                _card:add_to_deck()
                G.jokers:emplace(_card)
            elseif id == 49 then -- Unknown (Random)
                local random_id = pseudorandom(pseudoseed('unknown'), 1, 22)
                self.config.extra = random_id
                self:use(card, area, copier)
                self.config.extra = id
            elseif id == 50 then -- Truth
                for k, v in ipairs(G.deck.cards) do v.facing = 'front' end
            elseif id == 51 then -- Lie
                for k, v in ipairs(G.hand.cards) do v.facing = 'back' end
                ease_dollars(5)
            elseif id == 52 then -- Dream
                local _card = create_card("Tarot", G.consumeables, nil, nil, nil, nil, nil, "dream")
                _card:add_to_deck()
                G.consumeables:emplace(_card)
            elseif id == 53 then -- Nightmare
                local _card = create_card("Spectral", G.consumeables, nil, nil, nil, nil, nil, "nightmare")
                _card:add_to_deck()
                G.consumeables:emplace(_card)
            elseif id == 54 then -- Hope
                ease_ante(1)
            elseif id == 55 then -- Despair
                ease_ante(-1)
            elseif id == 56 then -- Love
                local to_add = {}
                for k, v in ipairs(G.hand.cards) do
                    if v.base.suit == 'Hearts' then
                        table.insert(to_add, v)
                    end
                end
                for k, v in ipairs(to_add) do
                    local _card = copy_card(v, nil, nil, nil)
                    _card:add_to_deck()
                    G.hand:emplace(_card)
                end
            elseif id == 57 then -- Hate
                for i=#G.hand.cards, 1, -1 do
                    if G.hand.cards[i].base.suit == 'Spades' then
                        G.hand.cards[i]:start_dissolve()
                    end
                end
            elseif id == 58 then -- War
                local count = 0
                for i=#G.hand.cards, 1, -1 do
                    if G.hand.cards[i]:is_face() then
                        G.hand.cards[i]:start_dissolve()
                        count = count + 1
                    end
                end
                ease_dollars(count * 2)
            elseif id == 59 then -- Peace
                local suits = {Spades=0, Hearts=0, Clubs=0, Diamonds=0}
                for k, v in ipairs(G.deck.cards) do suits[v.base.suit] = suits[v.base.suit] + 1 end
                local max_suit = 'Spades'
                for k, v in pairs(suits) do if v > suits[max_suit] then max_suit = k end end
                for i=1, math.min(#highlighted, 3) do highlighted[i]:change_suit(max_suit) end
            elseif id == 60 then -- Life
                if G.GAME.last_destroyed_joker then
                    local _card = copy_card(G.P_CENTERS[G.GAME.last_destroyed_joker], nil, nil, nil)
                    _card:add_to_deck()
                    G.jokers:emplace(_card)
                end
            elseif id == 61 then -- Death II
                if #G.jokers.highlighted == 1 then
                    local _joker = G.jokers.highlighted[1]
                    ease_dollars(_joker.sell_cost * 2)
                    _joker:start_dissolve()
                end
            elseif id == 62 then -- King
                for i = 1, 2 do
                    local _card = create_card("Base", G.hand, nil, nil, nil, nil, "S_K", "king")
                    _card:add_to_deck()
                    G.hand:emplace(_card)
                end
            elseif id == 63 then -- Queen
                for i = 1, 2 do
                    local _card = create_card("Base", G.hand, nil, nil, nil, nil, "H_Q", "queen")
                    _card:add_to_deck()
                    G.hand:emplace(_card)
                end
            elseif id == 64 then -- Jack
                for i = 1, 2 do
                    local _card = create_card("Base", G.hand, nil, nil, nil, nil, "D_J", "jack")
                    _card:add_to_deck()
                    G.hand:emplace(_card)
                end
            elseif id == 65 then -- Ace
                for i = 1, 2 do
                    local _card = create_card("Base", G.hand, nil, nil, nil, nil, "C_A", "ace")
                    _card:add_to_deck()
                    G.hand:emplace(_card)
                end
            elseif id == 66 then -- Joker
                local _card = create_card("Joker", G.jokers, nil, nil, nil, nil, nil, "joker_t")
                _card:add_to_deck()
                G.jokers:emplace(_card)
            elseif id == 67 then -- Merchant
                G.E_MANAGER:add_event(Event({trigger = 'immediate', func = function()
                    G.FUNCS.reroll_shop()
                    return true
                end}))
            elseif id == 68 then -- Thief
                local pool = {}
                if G.shop_jokers and G.shop_jokers.cards then
                    for _, v in ipairs(G.shop_jokers.cards) do
                        local is_joker = (v.ability.set == 'Joker' or not v.ability.set)
                        local is_consumeable = (v.ability.set == 'Tarot' or v.ability.set == 'Planet' or v.ability.set == 'Spectral')
                        if (is_joker and #G.jokers.cards < G.jokers.config.card_limit) or
                           (is_consumeable and #G.consumeables.cards < G.consumeables.config.card_limit) then
                            table.insert(pool, v)
                        end
                    end
                end
                
                if #pool > 0 then
                    local _card = pseudorandom_element(pool, pseudoseed('thief'))
                    local area = (_card.ability.set == 'Joker' or not _card.ability.set) and G.jokers or G.consumeables
                    _card:add_to_deck()
                    area:emplace(_card)
                    _card:juice_up()
                end
            elseif id == 69 then -- Guardian
                if #highlighted == 1 then
                    highlighted[1].ability.eternal = true
                end
            elseif id == 70 then -- Sage
                level_up_hand(card, pseudorandom_element(G.GAME.hands, pseudoseed('sage')), nil, 1)
            elseif id == 71 then -- Fool II
                if G.GAME.last_consumeable and #G.consumeables.cards < G.consumeables.config.card_limit then
                    local _card = create_card(G.GAME.last_consumeable.set, G.consumeables, nil, nil, nil, nil, G.GAME.last_consumeable.key, 'fool_ii')
                    _card:add_to_deck()
                    G.consumeables:emplace(_card)
                end
            elseif id == 72 then -- Architect
                G.hand:change_size(1)
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "+1 Tam. Mo", colour = G.C.BLUE})
            elseif id == 73 then -- Builder
                G.GAME.round_resets.discards = G.GAME.round_resets.discards + 1
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "+1 Descarte", colour = G.C.RED})
            elseif id == 74 then -- Destroyer
                G.hand:change_size(-1)
                ease_dollars(20)
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "-1 Tam. Mo, +$20", colour = G.C.GOLD})
            elseif id == 75 then -- Creator
                local _card = create_card(pseudorandom_element({'Tarot', 'Planet', 'Spectral', 'Joker'}, pseudoseed('creator')), G.consumeables, nil, nil, nil, nil, nil, 'creator')
                _card:add_to_deck()
                G.consumeables:emplace(_card)
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_active_ex'), colour = G.C.FILTER})
            elseif id == 76 then -- Observer
                -- Revela o Boss: Na prtica do mod, troca o boss atual por um novo
                local new_blind = pseudorandom_element(G.P_CENTER_POOLS.Blind, pseudoseed('observer'))
                while not new_blind.boss or new_blind.key == G.GAME.blind.key do
                    new_blind = pseudorandom_element(G.P_CENTER_POOLS.Blind, pseudoseed('observer'))
                end
                G.GAME.blind:set_blind(new_blind)
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "Novo Boss!", colour = G.C.FILTER})
            elseif id == 77 then -- Traveler
                local boss_keys = {}
                for _, v in pairs(G.P_BLINDS) do
                    if v.boss and v.key ~= G.GAME.blind.key then
                        table.insert(boss_keys, v)
                    end
                end
                local new_blind = pseudorandom_element(#boss_keys > 0 and boss_keys or {G.P_BLINDS.bl_small}, pseudoseed('traveler'))
                G.GAME.blind:set_blind(new_blind)
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.4,
                    func = function()
                        G.GAME.blind:juice_up()
                        return true
                    end
                }))
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_active_ex'), colour = G.C.FILTER})
            elseif id == 78 then -- Pilgrim
                local tag = Tag(pseudorandom_element(G.P_TAGS, pseudoseed('pilgrim')).key)
                add_tag(tag)
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_active_ex'), colour = G.C.FILTER})
            elseif id == 79 then -- Monk
                for k, v in ipairs(G.hand.cards) do v.debuff = false end
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_active_ex'), colour = G.C.FILTER})
            elseif id == 80 then -- Warrior
                G.GAME.warrior_chips = (G.GAME.warrior_chips or 0) + 100
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "+100 Fichas", colour = G.C.CHIPS})
            elseif id == 81 then -- Magician II
                G.GAME.magician_mult = (G.GAME.magician_mult or 0) + 20
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "+20 Multi", colour = G.C.MULT})
            elseif id == 82 then -- Rogue
                G.GAME.rogue_x_mult = (G.GAME.rogue_x_mult or 1) * 2
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "X2 Multi", colour = G.C.MULT})
            elseif id == 83 then -- Bard
                G.GAME.bard_retrigger = (G.GAME.bard_retrigger or 0) + 1
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "+1 Reativar", colour = G.C.FILTER})
            elseif id >= 84 and id <= 96 then
                local enhancements = {
                    [84] = "m_odyssey_plant", [85] = "m_odyssey_holy", [86] = "m_odyssey_undead",
                    [87] = "m_odyssey_cursed", [88] = "m_odyssey_magic", [89] = "m_odyssey_diamond",
                    [90] = "m_odyssey_paper", [91] = "m_odyssey_ceramic", [92] = "m_odyssey_platinum", [93] = "m_odyssey_wood",
                    [94] = "m_odyssey_cloth", [95] = "m_odyssey_ruby", [96] = "m_odyssey_emerald"
                }
                local max_h = tarot_max[id] or 1
                for i=1, math.min(#highlighted, max_h) do
                    if G.P_CENTERS[enhancements[id]] then
                        highlighted[i]:set_ability(G.P_CENTERS[enhancements[id]])
                    end
                end
            elseif id == 97 then -- Duplicator
                if #highlighted == 1 then
                    local _card = copy_card(highlighted[1], nil, nil, nil)
                    _card:add_to_deck()
                    G.hand:emplace(_card)
                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_duplicated_ex'), colour = G.C.FILTER})
                end
            elseif id == 98 then -- Remover
                for i=1, math.min(#highlighted, 1) do
                    highlighted[i]:start_dissolve()
                end
            elseif id == 99 then -- Transformer
                if #highlighted == 1 then
                    local suits = {'S', 'H', 'C', 'D'}
                    local ranks = {'2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'}
                    highlighted[1]:set_base(G.P_CARDS[pseudorandom_element(suits, pseudoseed('trans_s')).. '_' .. pseudorandom_element(ranks, pseudoseed('trans_r'))])
                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_active_ex'), colour = G.C.FILTER})
                end
            elseif id == 100 then -- Enhancer
                if #highlighted == 1 then
                    local enhancements = {"m_odyssey_ruby", "m_odyssey_emerald", "m_odyssey_cloth", "m_odyssey_ceramic", "m_odyssey_rubber", "m_odyssey_platinum", "m_odyssey_diamond", "m_odyssey_wood", "m_odyssey_plant", "m_odyssey_holy", "m_odyssey_undead", "m_odyssey_cursed", "m_odyssey_magic"}
                    highlighted[1]:set_ability(G.P_CENTERS[pseudorandom_element(enhancements, pseudoseed('enhancer'))])
                end
            end
        end
    })
end



local planets = {
    { id = 1, key = "planet_1", name = "Mercrio", hand = "Pair" },
    { id = 2, key = "planet_2", name = "Vnus", hand = "Three of a Kind" },
    { id = 3, key = "planet_3", name = "Terra", hand = "Full House" },
    { id = 4, key = "planet_4", name = "Marte", hand = "Four of a Kind" },
    { id = 5, key = "planet_5", name = "Jpiter", hand = "Flush" },
    { id = 6, key = "planet_6", name = "Saturno", hand = "Straight" },
    { id = 7, key = "planet_7", name = "Urano", hand = "Two Pair" },
    { id = 8, key = "planet_8", name = "Netuno", hand = "Straight Flush" },
    { id = 9, key = "planet_9", name = "Pluto", hand = "High Card" },
    { id = 10, key = "planet_10", name = "Planeta X", hand = "Five of a Kind" },
    { id = 11, key = "planet_11", name = "Ceres", hand = "Flush House" },
    { id = 12, key = "planet_12", name = "Eris", hand = "Flush Five" },
    { id = 13, key = "planet_13", name = "Tit", hand = "Two Pair" },
    { id = 14, key = "planet_14", name = "Europa", hand = "Three of a Kind" },
    { id = 15, key = "planet_15", name = "Io", hand = "Straight" },
    { id = 16, key = "planet_16", name = "Ganimedes", hand = "Flush" },
    { id = 17, key = "planet_17", name = "Calisto", hand = "Full House" },
    { id = 18, key = "planet_18", name = "Fobos", hand = "Four of a Kind" },
    { id = 19, key = "planet_19", name = "Deimos", hand = "Straight Flush" },
    { id = 20, key = "planet_20", name = "Caronte", hand = "odyssey_royal_flush" },
    { id = 21, key = "planet_21", name = "Makemake", hand = "odyssey_wrap_around_straight" },
    { id = 22, key = "planet_22", name = "Haumea", hand = "odyssey_jump_straight" },
    { id = 23, key = "planet_23", name = "Sedna", hand = "odyssey_alternating_straight" },
    { id = 24, key = "planet_24", name = "Quaoar", hand = "odyssey_spectrum" },
    { id = 25, key = "planet_25", name = "Orcus", hand = "odyssey_corner_hand" },
    { id = 26, key = "planet_26", name = "Salacia", hand = "odyssey_middle_hand" },
    { id = 27, key = "planet_27", name = "Varda", hand = "odyssey_prime_hand" },
    { id = 28, key = "planet_28", name = "Ixion", hand = "odyssey_fibonacci_hand" },
    { id = 29, key = "planet_29", name = "Varuna", hand = "odyssey_even_hand" },
    { id = 30, key = "planet_30", name = "Caos", hand = "odyssey_odd_hand" },
    { id = 31, key = "planet_31", name = "Proxima", hand = "odyssey_red_hand" },
    { id = 32, key = "planet_32", name = "Alpha", hand = "odyssey_black_hand" },
    { id = 33, key = "planet_33", name = "Sirius", hand = "odyssey_face_hand" },
    { id = 34, key = "planet_34", name = "Vega", hand = "odyssey_number_hand" },
    { id = 35, key = "planet_35", name = "Betelgeuse", hand = "odyssey_low_hand" },
    { id = 36, key = "planet_36", name = "Rigel", hand = "odyssey_high_hand" },
    { id = 37, key = "planet_37", name = "Antares", hand = "odyssey_mega_straight" },
    { id = 38, key = "planet_38", name = "Aldebaran", hand = "odyssey_mega_flush" },
    { id = 39, key = "planet_39", name = "Spica", hand = "odyssey_mega_full_house" },
    { id = 40, key = "planet_40", name = "Pollux", hand = "odyssey_double_three_of_a_kind" },
    { id = 41, key = "planet_41", name = "Castor", hand = "odyssey_triple_pair" },
    { id = 42, key = "planet_42", name = "Deneb", hand = "odyssey_quadruple_pair" },
    { id = 43, key = "planet_43", name = "Altair", hand = "odyssey_quintuple_pair" },
    { id = 44, key = "planet_44", name = "Fomalhaut", hand = "odyssey_six_of_a_kind" },
    { id = 45, key = "planet_45", name = "Regulus", hand = "odyssey_seven_of_a_kind" },
    { id = 46, key = "planet_46", name = "Canopus", hand = "odyssey_eight_of_a_kind" },
    { id = 47, key = "planet_47", name = "Arcturus", hand = "odyssey_nine_of_a_kind" },
    { id = 48, key = "planet_48", name = "Capella", hand = "odyssey_ten_of_a_kind" },
    { id = 49, key = "planet_49", name = "Achernar", hand = "odyssey_flush_pair" },
    { id = 50, key = "planet_50", name = "Hadar", hand = "odyssey_flush_two_pair" },
    { id = 51, key = "planet_51", name = "Acrux", hand = "odyssey_flush_three_of_a_kind" },
    { id = 52, key = "planet_52", name = "Mimosa", hand = "odyssey_flush_four_of_a_kind" },
    { id = 53, key = "planet_53", name = "Gacrux", hand = "odyssey_flush_six_of_a_kind" },
    { id = 54, key = "planet_54", name = "Bellatrix", hand = "odyssey_flush_seven_of_a_kind" },
    { id = 55, key = "planet_55", name = "Elnath", hand = "odyssey_flush_eight_of_a_kind" },
    { id = 56, key = "planet_56", name = "Alnilam", hand = "odyssey_flush_nine_of_a_kind" },
    { id = 57, key = "planet_57", name = "Alnitak", hand = "odyssey_flush_ten_of_a_kind" },
    { id = 58, key = "planet_58", name = "Mintaka", hand = "odyssey_super_royal_flush" },
    { id = 59, key = "planet_59", name = "Saiph", hand = "odyssey_ultimate_flush" },
    { id = 60, key = "planet_60", name = "Kepler", hand = "odyssey_all_hands" },
    { id = 61, key = "planet_61", name = "Kepler-22b", hand = "Pair" },
    { id = 62, key = "planet_62", name = "Kepler-186f", hand = "Three of a Kind" },
    { id = 63, key = "planet_63", name = "Kepler-452b", hand = "Full House" },
    { id = 64, key = "planet_64", name = "Kepler-62f", hand = "Four of a Kind" },
    { id = 65, key = "planet_65", name = "TRAPPIST-1d", hand = "Flush" },
    { id = 66, key = "planet_66", name = "TRAPPIST-1e", hand = "Straight" },
    { id = 67, key = "planet_67", name = "TRAPPIST-1f", hand = "Two Pair" },
    { id = 68, key = "planet_68", name = "TRAPPIST-1g", hand = "Straight Flush" },
    { id = 69, key = "planet_69", name = "Gliese 581g", hand = "High Card" },
    { id = 70, key = "planet_70", name = "Gliese 667Cc", hand = "Five of a Kind" },
    { id = 71, key = "planet_71", name = "HD 40307g", hand = "Flush House" },
    { id = 72, key = "planet_72", name = "HD 85512b", hand = "Flush Five" },
    { id = 73, key = "planet_73", name = "Tau Ceti e", hand = "odyssey_royal_flush" },
    { id = 74, key = "planet_74", name = "Kapteyn b", hand = "odyssey_secret_hand_1" },
    { id = 75, key = "planet_75", name = "Wolf 1061c", hand = "odyssey_secret_hand_2" },
    { id = 76, key = "planet_76", name = "GJ 357 d", hand = "odyssey_secret_hand_3" },
    { id = 77, key = "planet_77", name = "LHS 1140 b", hand = "odyssey_secret_hand_4" },
    { id = 78, key = "planet_78", name = "Teegarden b", hand = "odyssey_secret_hand_5" },
    { id = 79, key = "planet_79", name = "Ross 128 b", hand = "odyssey_secret_hand_6" },
    { id = 80, key = "planet_80", name = "Luyten b", hand = "odyssey_secret_hand_7" },
    { id = 81, key = "planet_81", name = "K2-18b", hand = "odyssey_secret_hand_8" },
    { id = 82, key = "planet_82", name = "TOI-700 d", hand = "odyssey_secret_hand_9" },
    { id = 83, key = "planet_83", name = "Kepler-1649c", hand = "odyssey_secret_hand_10" },
    { id = 84, key = "planet_84", name = "Kepler-442b", hand = "odyssey_secret_hand_11" },
    { id = 85, key = "planet_85", name = "Kepler-1638b", hand = "odyssey_secret_hand_12" },
    { id = 86, key = "planet_86", name = "Kepler-296f", hand = "odyssey_secret_hand_13" },
    { id = 87, key = "planet_87", name = "Kepler-174d", hand = "odyssey_secret_hand_14" },
    { id = 88, key = "planet_88", name = "Kepler-62e", hand = "odyssey_secret_hand_15" },
    { id = 89, key = "planet_89", name = "Kepler-1229b", hand = "odyssey_secret_hand_16" },
    { id = 90, key = "planet_90", name = "Kepler-1544b", hand = "odyssey_secret_hand_17" },
    { id = 91, key = "planet_91", name = "Kepler-1652b", hand = "odyssey_secret_hand_18" },
    { id = 92, key = "planet_92", name = "Kepler-1410b", hand = "odyssey_secret_hand_19" },
    { id = 93, key = "planet_93", name = "Kepler-155c", hand = "odyssey_secret_hand_20" },
    { id = 94, key = "planet_94", name = "Kepler-283c", hand = "odyssey_secret_hand_21" },
    { id = 95, key = "planet_95", name = "Kepler-438b", hand = "odyssey_secret_hand_22" },
    { id = 96, key = "planet_96", name = "Kepler-440b", hand = "odyssey_secret_hand_23" },
    { id = 97, key = "planet_97", name = "Kepler-443b", hand = "odyssey_secret_hand_24" },
    { id = 98, key = "planet_98", name = "Kepler-296e", hand = "odyssey_secret_hand_25" },
    { id = 99, key = "planet_99", name = "Kepler-1653b", hand = "odyssey_secret_hand_26" },
    { id = 100, key = "planet_100", name = "Kepler-1512b", hand = "odyssey_secret_hand_27" },
}

for _, p in ipairs(planets) do
    local planet_def = {
        key = p.key,
        atlas = "planet_" .. p.id,
        pos = { x = 0, y = 0 },
        config = { hand_type = p.hand },
        discovered = true,
        set = "Planet",
        cost = 3,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { localize(p.hand, 'poker_hands') } }

        end
    }

    if p.id == 60 then
        planet_def.use = function(self, card, area, copier)
            local used_tarot = copier or card
            G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()
                for k, v in pairs(G.GAME.hands) do
                    level_up_hand(used_tarot, k, nil, 1)
                end
                return true
            end }))
        end
    end

    SMODS.Planet(planet_def)
end



local spectrals = {
    { id = 1, key = "spectral_1", name = "Supernova" },
    { id = 2, key = "spectral_2", name = "Buraco Negro" },
    { id = 3, key = "spectral_3", name = "Quasar" },
    { id = 4, key = "spectral_4", name = "Pulsar" },
    { id = 5, key = "spectral_5", name = "Nebulosa" },
    { id = 6, key = "spectral_6", name = "Raio Gama" },
    { id = 7, key = "spectral_7", name = "Raio X" },
    { id = 8, key = "spectral_8", name = "Raio Csmico" },
    { id = 9, key = "spectral_9", name = "Raio Vazio" },
    { id = 10, key = "spectral_10", name = "Antimatria" },
    { id = 11, key = "spectral_11", name = "Matria Escura" },
    { id = 12, key = "spectral_12", name = "Entropia" },
    { id = 13, key = "spectral_13", name = "Entalpia" },
    { id = 14, key = "spectral_14", name = "Zero Absoluto" },
    { id = 15, key = "spectral_15", name = "Planck" },
    { id = 16, key = "spectral_16", name = "Luz" },
    { id = 17, key = "spectral_17", name = "Dobra" },
    { id = 18, key = "spectral_18", name = "Minhoca" },
    { id = 19, key = "spectral_19", name = "Multiverso" },
    { id = 20, key = "spectral_20", name = "Paradoxo" },
    { id = 21, key = "spectral_21", name = "Singularidade" },
    { id = 22, key = "spectral_22", name = "Big Bang" },
    { id = 23, key = "spectral_23", name = "Salto" },
    { id = 24, key = "spectral_24", name = "Horizonte" },
    { id = 25, key = "spectral_25", name = "Poo" },
    { id = 26, key = "spectral_26", name = "Energia" },
    { id = 27, key = "spectral_27", name = "Vcuo" },
    { id = 28, key = "spectral_28", name = "Cordas" },
    { id = 29, key = "spectral_29", name = "Caos" },
    { id = 30, key = "spectral_30", name = "Borboleta" },
    { id = 31, key = "spectral_31", name = "Schrodinger" },
    { id = 32, key = "spectral_32", name = "Heisenberg" },
    { id = 33, key = "spectral_33", name = "Pauli" },
    { id = 34, key = "spectral_34", name = "Fermi" },
    { id = 35, key = "spectral_35", name = "Drake" },
    { id = 36, key = "spectral_36", name = "Hubble" },
    { id = 37, key = "spectral_37", name = "Webb" },
    { id = 38, key = "spectral_38", name = "Kepler" },
    { id = 39, key = "spectral_39", name = "Galileu" },
    { id = 40, key = "spectral_40", name = "Newton" },
    { id = 41, key = "spectral_41", name = "Einstein" },
    { id = 42, key = "spectral_42", name = "Hawking" },
    { id = 43, key = "spectral_43", name = "Sagan" },
    { id = 44, key = "spectral_44", name = "Tyson" },
    { id = 45, key = "spectral_45", name = "Kaku" },
    { id = 46, key = "spectral_46", name = "Greene" },
    { id = 47, key = "spectral_47", name = "Penrose" },
    { id = 48, key = "spectral_48", name = "Godel" },
    { id = 49, key = "spectral_49", name = "Turing" },
    { id = 50, key = "spectral_50", name = "Oppenheimer" },
    { id = 51, key = "spectral_51", name = "Feynman" },
    { id = 52, key = "spectral_52", name = "Bohr" },
    { id = 53, key = "spectral_53", name = "Curie" },
    { id = 54, key = "spectral_54", name = "Darwin" },
    { id = 55, key = "spectral_55", name = "Mendel" },
    { id = 56, key = "spectral_56", name = "Pasteur" },
    { id = 57, key = "spectral_57", name = "Fleming" },
    { id = 58, key = "spectral_58", name = "Tesla" },
    { id = 59, key = "spectral_59", name = "Edison" },
    { id = 60, key = "spectral_60", name = "Bell" },
    { id = 61, key = "spectral_61", name = "Marconi" },
    { id = 62, key = "spectral_62", name = "Wright" },
    { id = 63, key = "spectral_63", name = "Ford" },
    { id = 64, key = "spectral_64", name = "Babbage" },
    { id = 65, key = "spectral_65", name = "Lovelace" },
    { id = 66, key = "spectral_66", name = "Hopper" },
    { id = 67, key = "spectral_67", name = "Berners-Lee" },
    { id = 68, key = "spectral_68", name = "Jobs" },
    { id = 69, key = "spectral_69", name = "Gates" },
    { id = 70, key = "spectral_70", name = "Musk" },
    { id = 71, key = "spectral_71", name = "Bezos" },
    { id = 72, key = "spectral_72", name = "Zuckerberg" },
    { id = 73, key = "spectral_73", name = "Nakamoto" },
    { id = 74, key = "spectral_74", name = "Vitalik" },
    { id = 75, key = "spectral_75", name = "Armstrong" },
    { id = 76, key = "spectral_76", name = "Aldrin" },
    { id = 77, key = "spectral_77", name = "Collins" },
    { id = 78, key = "spectral_78", name = "Gagarin" },
    { id = 79, key = "spectral_79", name = "Tereshkova" },
    { id = 80, key = "spectral_80", name = "Laika" },
    { id = 81, key = "spectral_81", name = "Ham" },
    { id = 82, key = "spectral_82", name = "Shepard" },
    { id = 83, key = "spectral_83", name = "Glenn" },
    { id = 84, key = "spectral_84", name = "Leonov" },
    { id = 85, key = "spectral_85", name = "Ride" },
    { id = 86, key = "spectral_86", name = "Hadfield" },
    { id = 87, key = "spectral_87", name = "Kelly" },
    { id = 88, key = "spectral_88", name = "Pesquet" },
    { id = 89, key = "spectral_89", name = "Cristoforetti" },
    { id = 90, key = "spectral_90", name = "Gerst" },
    { id = 91, key = "spectral_91", name = "Peake" },
    { id = 92, key = "spectral_92", name = "Hoshide" },
    { id = 93, key = "spectral_93", name = "Yi" },
    { id = 94, key = "spectral_94", name = "Yang" },
    { id = 95, key = "spectral_95", name = "Sharma" },
    { id = 96, key = "spectral_96", name = "Al Mansoori" },
    { id = 97, key = "spectral_97", name = "Pontes" },
    { id = 98, key = "spectral_98", name = "Vostok" },
    { id = 99, key = "spectral_99", name = "Mercury" },
    { id = 100, key = "spectral_100", name = "Gemini" },
}

local spectral_logic = {
    [1] = function(card, area, copier) -- Supernova
        local cards = {}
        for i=1, #G.hand.cards do cards[#cards+1] = G.hand.cards[i] end
        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()
            for i=1, #cards do cards[i]:start_dissolve() end 
            G.GAME.odyssey_spectral_1_xmult = (G.GAME.odyssey_spectral_1_xmult or 1) * 3
            return true end }))
    end,
    [2] = function(card, area, copier) -- Buraco Negro
        local cards = {}
        for i=1, #G.hand.cards do cards[#cards+1] = G.hand.cards[i] end
        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()
            for i=1, #cards do cards[i]:start_dissolve() end 
            G.GAME.starting_params.hand_size = G.GAME.starting_params.hand_size + 1
            G.hand:change_size(1)
            return true end }))
    end,
    [3] = function(card, area, copier) -- Quasar
        if #G.jokers.cards > 0 then
            local target = pseudorandom_element(G.jokers.cards, pseudoseed('quasar'))
            for i=#G.jokers.cards, 1, -1 do
                if G.jokers.cards[i] ~= target then
                    G.jokers.cards[i]:start_dissolve()
                end
            end
            target:set_edition({polychrome = true}, true)
        end
    end,
    [4] = function(card, area, copier) -- Pulsar
        for i=1, #G.hand.cards do
            G.hand.cards[i]:set_edition({foil = true}, true)
        end
        G.GAME.starting_params.hand_size = (G.GAME.starting_params.hand_size or 8) - 1
        G.hand:change_size(-1)
    end,
    [5] = function(card, area, copier) -- Nebulosa
        for i=1, #G.hand.cards do
            G.hand.cards[i]:set_edition({holo = true}, true)
        end
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - 1
        ease_discard(-1)
    end,
    [6] = function(card, area, copier) -- Raio Gama
        for i=1, #G.hand.cards do
            G.hand.cards[i]:set_ability(G.P_CENTERS.m_odyssey_diamond, nil)
        end
        ease_dollars(-G.GAME.dollars, true)
    end,
    [7] = function(card, area, copier) -- Raio X
        for i=1, #G.hand.cards do
            G.hand.cards[i]:set_ability(G.P_CENTERS.m_odyssey_ceramic, nil)
        end
        ease_discard(-G.GAME.current_round.discards_left)
    end,
    [8] = function(card, area, copier) -- Raio Csmico
         for i=1, #G.hand.cards do
            G.hand.cards[i]:set_ability(G.P_CENTERS.m_odyssey_rubber, nil)
        end
        ease_hands_played(-(G.GAME.current_round.hands_left - 1))
    end,
    [9] = function(card, area, copier) -- Raio Vazio
        for i=1, #G.hand.cards do
            G.hand.cards[i]:set_ability(G.P_CENTERS.m_odyssey_platinum, nil)
        end
        for i=#G.jokers.cards, 1, -1 do
            G.jokers.cards[i]:start_dissolve()
        end
    end,
    [10] = function(card, area, copier) -- Antimatria
        if #G.jokers.cards > 0 then
            local target = pseudorandom_element(G.jokers.cards, pseudoseed('antimatter'))
            target:set_edition({negative = true}, true)
            ease_dollars(-G.GAME.dollars, true)
        end
    end,
    [11] = function(card, area, copier) -- Matria Escura
        if #G.consumeables.cards > 0 then
            local target = pseudorandom_element(G.consumeables.cards, pseudoseed('darkmatter'))
            target:set_edition({negative = true}, true)
            for i=#G.jokers.cards, 1, -1 do
                G.jokers.cards[i]:start_dissolve()
            end
        end
    end,
    [12] = function(card, area, copier) -- Entropia
        local ranks = {'2','3','4','5','6','7','8','9','T','J','Q','K','A'}
        for i=1, #G.playing_cards do
            local new_rank = pseudorandom_element(ranks, pseudoseed('entropy'..i))
            local suit_prefix = G.playing_cards[i].base.suit:sub(1,1)
            G.playing_cards[i]:set_base(G.P_CARDS[suit_prefix..'_'..new_rank])
        end
        ease_dollars(20)
    end,
    [13] = function(card, area, copier) -- Entalpia
        local suits = {'Spades', 'Hearts', 'Clubs', 'Diamonds'}
        for i=1, #G.playing_cards do
            local new_suit = pseudorandom_element(suits, pseudoseed('enthalpy'..i))
            local rank = G.playing_cards[i].base.value
            local suit_prefix = new_suit:sub(1,1)
            G.playing_cards[i]:set_base(G.P_CARDS[suit_prefix..'_'..rank])
        end
        ease_dollars(20)
    end,
    [14] = function(card, area, copier) -- Zero Absoluto
        G.GAME.odyssey_zero_absolute = true
        G.GAME.odyssey_spectral_14_xmult = (G.GAME.odyssey_spectral_14_xmult or 1) * 5
    end,
    [15] = function(card, area, copier) -- Planck
        G.GAME.starting_params.hand_size = 1
        G.hand:change_size(1 - G.hand.config.card_limit)
        G.GAME.odyssey_spectral_15_xmult = (G.GAME.odyssey_spectral_15_xmult or 1) * 10
    end,
    [16] = function(card, area, copier) -- Luz
        G.GAME.round_resets.discards = 0
        ease_discard(-G.GAME.current_round.discards_left)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + 5
        ease_hands_played(5)
    end,
    [17] = function(card, area, copier) -- Dobra
        G.E_MANAGER:add_event(Event({trigger = 'after', func = function()
            G.STATE = G.STATES.BLIND_SELECT
            G.STATE_COMPLETE = true
            return true
        end }))
    end,
    [18] = function(card, area, copier) -- Minhoca
        ease_ante(1)
        ease_dollars(-G.GAME.dollars, true)
    end,
    [19] = function(card, area, copier) -- Multiverso
         for i=1, math.min(2, #G.jokers.cards) do
             local joker = G.jokers.cards[i]
             local copy = copy_card(joker, nil, nil, nil, joker.edition)
             copy:set_perishable(true)
             copy:add_to_deck()
             G.jokers:emplace(copy)
         end
    end,
    [20] = function(card, area, copier) -- Paradoxo
        local score = G.GAME.last_round_score or 0
        local amount = math.min(100, score)
        ease_dollars(amount - G.GAME.dollars, true)
    end,
    [21] = function(card, area, copier) -- Singularidade
        if #G.jokers.cards >= 2 then
            for i=1, 2 do G.jokers.cards[1]:start_dissolve() end
            local card = create_card('Joker', G.jokers, nil, 3, nil, nil, nil, 'sing')
            card:set_edition({negative = true}, true)
            card:add_to_deck()
            G.jokers:emplace(card)
        end
    end,
    [23] = function(card, area, copier) -- Salto
        ease_ante(8 - G.GAME.round_resets.ante)
        ease_dollars(-G.GAME.dollars, true)
    end,
    [24] = function(card, area, copier) -- Horizonte
        for i=#G.playing_cards, 1, -1 do
            if G.playing_cards[i]:is_face() then
                G.playing_cards[i]:start_dissolve()
            end
        end
        G.jokers.config.card_limit = G.jokers.config.card_limit + 1
    end,
    [25] = function(card, area, copier) -- Poo
        for i=#G.playing_cards, 1, -1 do
            if not G.playing_cards[i]:is_face() then
                G.playing_cards[i]:start_dissolve()
            end
        end
        G.consumeables.config.card_limit = G.consumeables.config.card_limit + 1
    end,
    [26] = function(card, area, copier) -- Energia
        for i=1, #G.hand.cards do
            G.hand.cards[i]:set_edition({negative = true}, true)
        end
    end,
    [27] = function(card, area, copier) -- Vcuo
        for i=1, #G.playing_cards do
            G.playing_cards[i]:set_ability(G.P_CENTERS.c_base)
            G.playing_cards[i]:set_edition(nil, true)
        end
        ease_dollars(50)
    end,
    [29] = function(card, area, copier) -- Caos
        local editions = {nil, {foil = true}, {holo = true}, {polychrome = true}, {negative = true}}
        for i=1, #G.jokers.cards do
            local ed = pseudorandom_element(editions, pseudoseed('chaos'..i))
            G.jokers.cards[i]:set_edition(ed, true)
        end
    end,
    [30] = function(card, area, copier) -- Borboleta
        if G.hand.highlighted[1] then
            local c = G.hand.highlighted[1]
            local ranks = {'2','3','4','5','6','7','8','9','T','J','Q','K','A'}
            local suits = {'S','H','C','D'}
            local r = pseudorandom_element(ranks, pseudoseed('butt_r'))
            local s = pseudorandom_element(suits, pseudoseed('butt_s'))
            c:set_base(G.P_CARDS[s..'_'..r])
        end
    end,
    [31] = function(card, area, copier) -- Schrodinger
        if pseudorandom('schro') > 0.5 then
            ease_dollars(G.GAME.dollars)
        else
            ease_dollars(-G.GAME.dollars)
        end
    end,
    [33] = function(card, area, copier) -- Pauli
        local ranks = {}
        local has_pair = false
        for i=1, #G.hand.cards do
            local r = G.hand.cards[i].base.value
            if ranks[r] then has_pair = true; break end
            ranks[r] = true
        end
        if not has_pair then ease_dollars(20) end
    end,
    [34] = function(card, area, copier) -- Fermi
        local card = create_card('Joker', G.jokers, nil, 3, nil, nil, nil, 'fermi')
        card:set_edition({negative = true}, true)
        card:add_to_deck()
        G.jokers:emplace(card)
    end,
    [35] = function(card, area, copier) -- Drake
        G.GAME.odyssey_drake_active = true
    end,
    [38] = function(card, area, copier) -- Kepler
        for k, v in pairs(G.GAME.hands) do
            if v.level > 1 then
                update_hand_stats(k, {level = v.level})
            end
        end
    end,
    [39] = function(card, area, copier) -- Galileu
        G.GAME.odyssey_galileo_active = true
    end,
    [40] = function(card, area, copier) -- Newton
        G.GAME.odyssey_newton_active = true
    end,
    [41] = function(card, area, copier) -- Einstein
        G.GAME.odyssey_einstein_active = true
    end,
    [43] = function(card, area, copier) -- Sagan
        local count = 0
        for i=1, #G.playing_cards do
            if G.playing_cards[i].seal or G.playing_cards[i].edition then
                count = count + 1
            end
        end
        ease_dollars(count)
    end,
    [46] = function(card, area, copier) -- Greene
        local card = create_card('Joker', G.jokers, nil, 0.9, nil, nil, nil, 'greene')
        card:add_to_deck()
        G.jokers:emplace(card)
    end,
    [50] = function(card, area, copier) -- Oppenheimer
        for i=1, 5 do
            if #G.playing_cards > 0 then
                pseudorandom_element(G.playing_cards, pseudoseed('oppen')):start_dissolve()
            end
        end
        G.GAME.odyssey_spectral_50_next_xmult = 10
    end,
    [53] = function(card, area, copier) -- Curie
        G.GAME.odyssey_curie_active = true
    end,
    [54] = function(card, area, copier) -- Darwin
        G.GAME.odyssey_darwin_active = true
    end,
    [56] = function(card, area, copier) -- Pasteur
        for i=1, #G.playing_cards do
            G.playing_cards[i].ability.perma_debuff_immune = true
        end
    end,
    [57] = function(card, area, copier) -- Fleming
        for i=1, #G.playing_cards do
            G.playing_cards[i].debuff = false
        end
    end,
    [59] = function(card, area, copier) -- Edison
        local card = create_card('Joker', G.jokers, nil, nil, nil, nil, nil, 'edison')
        card:add_to_deck()
        G.jokers:emplace(card)
    end,
    [60] = function(card, area, copier) -- Bell
        local card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'bell')
        card:add_to_deck()
        G.consumeables:emplace(card)
    end,
    [63] = function(card, area, copier) -- Ford
         G.SETTINGS.GAMESPEED = 10
    end,
    [68] = function(card, area, copier) -- Jobs
        if G.hand.highlighted[1] then
            local c = G.hand.highlighted[1]
            local new_card = create_card('Base', G.deck, nil, nil, nil, nil, nil, 'jobs')
            c:set_base(new_card.config.center)
            new_card:remove()
        end
    end,
    [71] = function(card, area, copier) -- Bezos
        for i=1, 3 do
            local card = create_card('Joker', G.jokers, nil, nil, nil, nil, nil, 'bezos')
            card:add_to_deck()
            G.jokers:emplace(card)
        end
    end,
    [74] = function(card, area, copier) -- Vitalik
        G.GAME.odyssey_vitalik_active = true
    end,
    [75] = function(card, area, copier) -- Armstrong
        ease_ante(2)
    end,
    [76] = function(card, area, copier) -- Aldrin
        if #G.jokers.cards > 0 then
            local joker = G.jokers.cards[1]
            for i=2, #G.jokers.cards do
                if G.jokers.cards[i].config.center.rarity > joker.config.center.rarity then
                    joker = G.jokers.cards[i]
                end
            end
            local copy = copy_card(joker, nil, nil, nil, joker.edition)
            copy:add_to_deck()
            G.jokers:emplace(copy)
        end
    end,
    [78] = function(card, area, copier) -- Gagarin
        local card = create_card('Voucher', G.shop_vouchers, nil, nil, nil, nil, nil, 'gagarin')
        card:apply_to_run()
    end,
    [79] = function(card, area, copier) -- Tereshkova
        for i=1, #G.playing_cards do
            if G.playing_cards[i].base.value == 'Queen' then
                G.playing_cards[i]:set_edition({polychrome = true}, true)
            end
        end
    end,
    [82] = function(card, area, copier) -- Shepard
        if #G.playing_cards > 0 then
            local weak = G.playing_cards[1]
            for i=2, #G.playing_cards do
                if G.playing_cards[i].base.nominal < weak.base.nominal then
                    weak = G.playing_cards[i]
                end
            end
            weak:start_dissolve()
            ease_dollars(10)
        end
    end,
    [83] = function(card, area, copier) -- Glenn
        for k, v in pairs(G.GAME.hands) do
            v.level = 1
        end
        ease_dollars(100)
    end,
    [85] = function(card, area, copier) -- Ride
        add_tag(Tag('tag_coupon'))
        add_tag(Tag('tag_investment'))
    end,
    [88] = function(card, area, copier) -- Pesquet
        for i=1, #G.playing_cards do
            if G.playing_cards[i].base.suit == 'Hearts' then
                G.playing_cards[i]:set_ability(G.P_CENTERS.m_odyssey_ceramic, nil)
            end
        end
    end,
    [90] = function(card, area, copier) -- Gerst
        for i=1, #G.playing_cards do
            if G.playing_cards[i].base.suit == 'Clubs' then
                G.playing_cards[i]:set_ability(G.P_CENTERS.m_odyssey_rubber, nil)
            end
        end
    end,
    [92] = function(card, area, copier) -- Hoshide
        for i=1, #G.playing_cards do
            if G.playing_cards[i].base.suit == 'Diamonds' then
                G.playing_cards[i]:set_ability(G.P_CENTERS.m_odyssey_diamond, nil)
            end
        end
    end,
    [93] = function(card, area, copier) -- Yi
        local top_hands = {}
        for k, v in pairs(G.GAME.hands) do
            table.insert(top_hands, {key = k, level = v.level})
        end
        table.sort(top_hands, function(a, b) return a.level > b.level end)
        for i=1, math.min(3, #top_hands) do
            update_hand_stats(top_hands[i].key, {level = 2})
        end
    end,
    [94] = function(card, area, copier) -- Yang
        G.GAME.odyssey_yang_active = true
    end,
    [95] = function(card, area, copier) -- Sharma
        G.GAME.odyssey_sharma_active = true
    end,
    [96] = function(card, area, copier) -- Al Mansoori
        ease_dollars(100 - G.GAME.dollars, true)
        G.GAME.used_vouchers = {}
    end,
    [97] = function(card, area, copier) -- Pontes
        for i=1, #G.playing_cards do
            G.playing_cards[i]:set_ability(G.P_CENTERS.m_odyssey_cloth, nil)
        end
        ease_dollars(15)
    end,
    [98] = function(card, area, copier) -- Vostok
        G.GAME.odyssey_vostok_active = true
    end,
    [99] = function(card, area, copier) -- Mercury
        G.GAME.odyssey_mercury_vessel_active = true
    end,
    [100] = function(card, area, copier) -- Gemini
        G.GAME.odyssey_gemini_active = true
    end,
}

for _, s in ipairs(spectrals) do
    SMODS.Consumable({
        key = s.key,
        set = "Spectral",
        atlas = s.id <= 100 and ("spectral_" .. s.id) or nil,
        pos = { x = 0, y = 0 },
        cost = 4,
        discovered = true,
        can_use = function(self, card)
            return true
        end,
        use = function(self, card, area, copier)
            local id = tonumber(self.key:match("spectral_(%d+)"))
            if spectral_logic[id] then
                spectral_logic[id](card, area, copier)
            end
        end,
        loc_vars = function(self, info_queue, card)
            local id = tonumber(self.key:match("spectral_(%d+)"))
            local mapping = {
                [6] = "m_odyssey_diamond",
                [7] = "m_odyssey_ceramic",
                [8] = "m_odyssey_rubber",
                [9] = "m_odyssey_platinum",
                [88] = "m_odyssey_ceramic",
                [90] = "m_odyssey_rubber",
                [92] = "m_odyssey_diamond",
                [97] = "m_odyssey_cloth"
            }
            if mapping[id] then
                info_queue[#info_queue+1] = G.P_CENTERS[mapping[id]]
            end
            if id == 19 then
                info_queue[#info_queue+1] = {set = 'Other', key = 'perishable', vars = {G.GAME.perishable_rounds}}
            end
            if id == 10 or id == 11 or id == 26 then
                info_queue[#info_queue+1] = G.P_CENTERS.e_negative
            end
            if id == 3 then
                info_queue[#info_queue+1] = G.P_CENTERS.e_polychrome
            end
            if id == 4 then
                info_queue[#info_queue+1] = G.P_CENTERS.e_foil
            end
            if id == 5 then
                info_queue[#info_queue+1] = G.P_CENTERS.e_holo
            end
            return { vars = {} }
        end
    })
end


local blind_multipliers = {
    [3] = 4.0, [4] = 4.0, [5] = 4.0, [6] = 10.0, [7] = 4.0, [8] = 4.0, [9] = 4.0, [10] = 4.0,
    [11] = 4.0, [12] = 4.0, [13] = 4.0, [14] = 4.0, [15] = 4.0, [16] = 4.0, [17] = 4.0, [18] = 4.0, [19] = 4.0, [20] = 4.0,
    [21] = 20.0, [22] = 4.0, [23] = 4.0, [24] = 4.0, [25] = 4.0, [26] = 4.0, [27] = 4.0, [28] = 4.0, [29] = 4.0, [30] = 4.0,
    [31] = 4.0, [32] = 4.0, [33] = 4.0, [34] = 4.0, [35] = 4.0, [36] = 4.0, [37] = 4.0, [38] = 4.0, [39] = 4.0, [40] = 4.0,
    [41] = 40.0, [42] = 4.0, [43] = 4.0, [44] = 4.0, [45] = 4.0, [46] = 4.0, [47] = 4.0, [48] = 4.0, [49] = 4.0, [50] = 4.0,
    [51] = 4.0, [52] = 4.0, [53] = 4.0, [54] = 4.0, [55] = 4.0, [56] = 4.0, [57] = 4.0, [58] = 8.0, [59] = 4.0, [60] = 4.0,
    [61] = 4.0, [62] = 4.0, [63] = 4.0, [64] = 4.0, [65] = 4.0, [66] = 12.0, [67] = 15.0, [68] = 4.0, [69] = 4.0, [70] = 4.0,
    [71] = 12.0, [72] = 4.0, [73] = 4.0, [74] = 4.0, [75] = 4.0, [76] = 4.0, [77] = 4.0, [78] = 4.0, [79] = 4.0, [80] = 4.0,
    [81] = 4.0, [82] = 4.0, [83] = 4.0, [84] = 8.0, [85] = 4.0, [86] = 4.0, [87] = 4.0, [88] = 15.0, [89] = 15.0, [90] = 4.0,
    [91] = 4.0, [92] = 4.0, [93] = 4.0, [94] = 4.0, [95] = 4.0, [96] = 4.0, [97] = 4.0, [98] = 4.0, [99] = 4.0, [100] = 100.0,
}

local blinds = {
    { id = 3, key = "blind_3", name = "The Hook" },
    { id = 4, key = "blind_4", name = "The Ox" },
    { id = 5, key = "blind_5", name = "The House" },
    { id = 6, key = "blind_6", name = "The Wall" },
    { id = 7, key = "blind_7", name = "The Wheel" },
    { id = 8, key = "blind_8", name = "The Arm" },
    { id = 9, key = "blind_9", name = "The Club" },
    { id = 10, key = "blind_10", name = "The Fish" },
    { id = 11, key = "blind_11", name = "The Psychic" },
    { id = 12, key = "blind_12", name = "The Goad" },
    { id = 13, key = "blind_13", name = "The Water" },
    { id = 14, key = "blind_14", name = "The Window" },
    { id = 15, key = "blind_15", name = "The Manacle" },
    { id = 16, key = "blind_16", name = "The Eye" },
    { id = 17, key = "blind_17", name = "The Mouth" },
    { id = 18, key = "blind_18", name = "The Plant" },
    { id = 19, key = "blind_19", name = "The Serpent" },
    { id = 20, key = "blind_20", name = "The Pillar" },
    { id = 21, key = "blind_21", name = "A Muralha de Ao" },
    { id = 22, key = "blind_22", name = "O Vampiro" },
    { id = 23, key = "blind_23", name = "A Guilhotina" },
    { id = 24, key = "blind_24", name = "O Labirinto" },
    { id = 25, key = "blind_25", name = "A Nvoa" },
    { id = 26, key = "blind_26", name = "O Espelho Quebrado" },
    { id = 27, key = "blind_27", name = "A Areia Movedia" },
    { id = 28, key = "blind_28", name = "O Buraco Negro" },
    { id = 29, key = "blind_29", name = "A Supernova" },
    { id = 30, key = "blind_30", name = "O Quasar" },
    { id = 31, key = "blind_31", name = "O Pulsar" },
    { id = 32, key = "blind_32", name = "O m" },
    { id = 33, key = "blind_33", name = "O Prisma" },
    { id = 34, key = "blind_34", name = "O Vazio" },
    { id = 35, key = "blind_35", name = "O Tempo" },
    { id = 36, key = "blind_36", name = "O Espao" },
    { id = 37, key = "blind_37", name = "A Matria" },
    { id = 38, key = "blind_38", name = "A Energia" },
    { id = 39, key = "blind_39", name = "A Entropia" },
    { id = 40, key = "blind_40", name = "O Caos" },
    { id = 41, key = "blind_41", name = "A Fortaleza" },
    { id = 42, key = "blind_42", name = "O Tit" },
    { id = 43, key = "blind_43", name = "O Colosso" },
    { id = 44, key = "blind_44", name = "A Hidra" },
    { id = 45, key = "blind_45", name = "O Basilisco" },
    { id = 46, key = "blind_46", name = "A Quimera" },
    { id = 47, key = "blind_47", name = "O Grifo" },
    { id = 48, key = "blind_48", name = "O Kraken" },
    { id = 49, key = "blind_49", name = "O Leviat" },
    { id = 50, key = "blind_50", name = "O Behemoth" },
    { id = 51, key = "blind_51", name = "A Esfinge" },
    { id = 52, key = "blind_52", name = "O Fara" },
    { id = 53, key = "blind_53", name = "A Mmia" },
    { id = 54, key = "blind_54", name = "O Escaravelho" },
    { id = 55, key = "blind_55", name = "O Osis" },
    { id = 56, key = "blind_56", name = "A Tempestade de Areia" },
    { id = 57, key = "blind_57", name = "A Miragem" },
    { id = 58, key = "blind_58", name = "O Djinn" },
    { id = 59, key = "blind_59", name = "O Sulto" },
    { id = 60, key = "blind_60", name = "O Nmade" },
    { id = 61, key = "blind_61", name = "O Grande Atrator" },
    { id = 62, key = "blind_62", name = "A Singularidade" },
    { id = 63, key = "blind_63", name = "O Horizonte de Eventos" },
    { id = 64, key = "blind_64", name = "A Espaguetificao" },
    { id = 65, key = "blind_65", name = "A Radiao Hawking" },
    { id = 66, key = "blind_66", name = "O Big Bang" },
    { id = 67, key = "blind_67", name = "A Inflao Csmica" },
    { id = 68, key = "blind_68", name = "A Matria Escura" },
    { id = 69, key = "blind_69", name = "A Energia Escura" },
    { id = 70, key = "blind_70", name = "O Vcuo Quntico" },
    { id = 71, key = "blind_71", name = "O Multiverso" },
    { id = 72, key = "blind_72", name = "A Linha do Tempo Sagrada" },
    { id = 73, key = "blind_73", name = "O Paradoxo de Fermi" },
    { id = 74, key = "blind_74", name = "O Gato de Schrodinger" },
    { id = 75, key = "blind_75", name = "O Demnio de Maxwell" },
    { id = 76, key = "blind_76", name = "A Entropia Mxima" },
    { id = 77, key = "blind_77", name = "A Morte Trmica" },
    { id = 78, key = "blind_78", name = "O Big Crunch" },
    { id = 79, key = "blind_79", name = "O Big Rip" },
    { id = 80, key = "blind_80", name = "O Falso Vcuo" },
    { id = 81, key = "blind_81", name = "O Criador" },
    { id = 82, key = "blind_82", name = "O Destruidor" },
    { id = 83, key = "blind_83", name = "O Observador" },
    { id = 84, key = "blind_84", name = "O Arquiteto" },
    { id = 85, key = "blind_85", name = "O Guardio" },
    { id = 86, key = "blind_86", name = "A Verdade" },
    { id = 87, key = "blind_87", name = "A Mentira" },
    { id = 88, key = "blind_88", name = "O Infinito" },
    { id = 89, key = "blind_89", name = "O Zero" },
    { id = 90, key = "blind_90", name = "Alpha & Omega" },
    { id = 91, key = "blind_91", name = "O Cdigo" },
    { id = 92, key = "blind_92", name = "A Matriz" },
    { id = 93, key = "blind_93", name = "O Erro" },
    { id = 94, key = "blind_94", name = "O Crash" },
    { id = 95, key = "blind_95", name = "A Tela Azul" },
    { id = 96, key = "blind_96", name = "O Vrus" },
    { id = 97, key = "blind_97", name = "O Antivrus" },
    { id = 98, key = "blind_98", name = "O Firewall" },
    { id = 99, key = "blind_99", name = "O Hacker" },
    { id = 100, key = "blind_100", name = "A Odisseia Final" },
}

for _, b in ipairs(blinds) do
    local config = {
        key = b.key,
        name = b.name,
        atlas = "blind_" .. b.id,
        pos = { x = 0, y = 0 },
        dollars = 5,
        mult = blind_multipliers[b.id] or 4,
        vars = {},
        boss_colour = G.C.BLACK,
        discovered = true
    }
    
    config.boss = { min = 9, max = 99 }
    if b.id == 100 then -- Showdown
        config.boss.showdown = true
        config.boss.max = 100
        config.boss.min = 100
    end

    -- Lgica especfica para cada Blind
    if b.id == 43 then -- O Colosso: 2-9 no pontuam
        config.debuff_card = function(self, card, from_blind)
            if not self.disabled and card.area ~= G.jokers then
                local rank = card:get_id()
                if rank >= 2 and rank <= 9 then
                    card:set_debuff(true)
                    return true
                end
            end
            card:set_debuff(false)
        end
    elseif b.id == 24 then -- O Labirinto: Exatamente 3 cartas
        config.debuff_hand = function(self, cards, hand, handname, check)
            if not self.disabled and #cards ~= 3 then
                self.triggered = true
                return true
            end
            self.triggered = false
        end
    elseif b.id == 49 then -- O Leviat: Mos de 5 cartas proibidas
        config.debuff_hand = function(self, cards, hand, handname, check)
            if not self.disabled and #cards == 5 then
                self.triggered = true
                return true
            end
            self.triggered = false
        end
    elseif b.id == 50 then -- O Behemoth: Menos de 5 cartas proibidas
        config.debuff_hand = function(self, cards, hand, handname, check)
            if not self.disabled and #cards < 5 then
                self.triggered = true
                return true
            end
            self.triggered = false
        end
    elseif b.id == 18 then -- A Planta: Figuras debuffed
        config.debuff_card = function(self, card, from_blind)
            if not self.disabled and card.area ~= G.jokers and card:is_face() then
                card:set_debuff(true)
                return true
            end
            card:set_debuff(false)
        end
    elseif b.id == 47 then -- O Grifo: No pode jogar o mesmo tipo de mo duas vezes seguidas
        config.debuff_hand = function(self, cards, hand, handname, check)
            if not self.disabled and G.GAME.last_hand_type == handname then
                self.triggered = true
                return true
            end
            self.triggered = false
        end
    elseif b.id == 75 then -- O Demnio de Maxwell: Deve ordenar as cartas para pontuar
        config.debuff_hand = function(self, cards, hand, handname, check)
            if not self.disabled then
                local sorted = true
                -- Verificar se est em ordem crescente
                for i = 1, #cards - 1 do
                    if cards[i].base.id > cards[i+1].base.id then
                        sorted = false
                        break
                    end
                end
                -- Se no estiver em crescente, verificar decrescente
                if not sorted then
                    sorted = true
                    for i = 1, #cards - 1 do
                        if cards[i].base.id < cards[i+1].base.id then
                            sorted = false
                            break
                        end
                    end
                end
                
                if not sorted then
                    self.triggered = true
                    return true
                end
            end
            self.triggered = false
        end
    elseif b.id == 32 then -- O m: Apenas um naipe permitido
        config.debuff_hand = function(self, cards, hand, handname, check)
            if not self.disabled then
                local suit = nil
                for i = 1, #cards do
                    if not suit then suit = cards[i].base.suit
                    elseif cards[i].base.suit ~= suit then
                        self.triggered = true
                        return true
                    end
                end
            end
            self.triggered = false
        end
    elseif b.id == 23 then -- A Guilhotina: Destri a primeira carta jogada
        config.press_play = function(self)
            if not self.disabled and G.play.cards[1] then
                G.play.cards[1]:start_dissolve()
            end
        end
    end
    
    SMODS.Blind(config)
end


-- Custom Poker Hands for Balatro Odyssey

-- ID 21: Wrap-around Straight
SMODS.PokerHand({
    key = 'wrap_around_straight',
    chips = 33,
    mult = 4,
    l_chips = 22,
    l_mult = 2,
    example = {
        { 'S_Q', true }, { 'H_K', true }, { 'D_A', true }, { 'C_2', true }, { 'S_3', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        -- Sort hand by rank
        local ranks = {}
        for i = 1, #hand do
            local val = hand[i].base.id
            table.insert(ranks, val)
        end
        table.sort(ranks)

        -- Standard straight already handled by game, but we need to check wrap-arounds
        -- Wrap-around logic: Check all possible start points in a circular 1-13 range
        -- id: 2=2, ..., 10=10, 11=J, 12=Q, 13=K, 14=A
        -- Adjust A to 1 for wrap:
        local possible_straights = {
            {11, 12, 13, 14, 2}, -- J, Q, K, A, 2
            {12, 13, 14, 2, 3}, -- Q, K, A, 2, 3
            {13, 14, 2, 3, 4}, -- K, A, 2, 3, 4
            {14, 2, 3, 4, 5}   -- A, 2, 3, 4, 5 (Wait, this is a standard low straight?)
            -- Actually A, 2, 3, 4, 5 is already a straight in vanilla.
        }

        for _, ps in ipairs(possible_straights) do
            local match_count = 0
            local matched_cards = {}
            for _, r in ipairs(ps) do
                for _, c in ipairs(hand) do
                    if c.base.id == r then
                        match_count = match_count + 1
                        table.insert(matched_cards, c)
                        break
                    end
                end
            end
            if match_count == 5 then return {matched_cards} end
        end
    end
})

-- ID 28: Fibonacci Hand (A, 2, 3, 5, 8)
SMODS.PokerHand({
    key = 'fibonacci_hand',
    chips = 41,
    mult = 4,
    l_chips = 26,
    l_mult = 3,
    example = {
        { 'S_A', true }, { 'H_2', true }, { 'D_3', true }, { 'C_5', true }, { 'S_8', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        local fib_ranks = { [14] = true, [2] = true, [3] = true, [5] = true, [8] = true }
        local matched = {}
        local count = 0
        for i = 1, #hand do
            if fib_ranks[hand[i].base.id] then
                count = count + 1
                table.insert(matched, hand[i])
            else
                return
            end
        end
        if count == 5 then return {matched} end
    end
})

-- ID 27: Prime Hand (2, 3, 5, 7, J, K)
SMODS.PokerHand({
    key = 'prime_hand',
    chips = 47,
    mult = 5,
    l_chips = 31,
    l_mult = 3,
    example = {
        { 'S_2', true }, { 'H_3', true }, { 'D_5', true }, { 'C_7', true }, { 'S_J', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        local prime_ranks = { [2] = true, [3] = true, [5] = true, [7] = true, [11] = true, [13] = true }
        local matched = {}
        for i = 1, #hand do
            if not prime_ranks[hand[i].base.id] then return end
            table.insert(matched, hand[i])
        end
        return {matched}
    end
})

-- ID 31: Red Hand (Hearts, Diamonds)
SMODS.PokerHand({
    key = 'red_hand',
    chips = 21,
    mult = 2,
    l_chips = 17,
    l_mult = 2,
    example = {
        { 'H_2', true }, { 'H_5', true }, { 'D_8', true }, { 'D_J', true }, { 'H_A', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        local matched = {}
        for i = 1, #hand do
            if not (hand[i]:is_suit('Hearts') or hand[i]:is_suit('Diamonds')) then return end
            table.insert(matched, hand[i])
        end
        return {matched}
    end
})

-- ID 32: Black Hand (Spades, Clubs)
SMODS.PokerHand({
    key = 'black_hand',
    chips = 21,
    mult = 2,
    l_chips = 17,
    l_mult = 2,
    example = {
        { 'S_2', true }, { 'S_5', true }, { 'C_8', true }, { 'C_J', true }, { 'S_A', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        local matched = {}
        for i = 1, #hand do
            if not (hand[i]:is_suit('Spades') or hand[i]:is_suit('Clubs')) then return end
            table.insert(matched, hand[i])
        end
        return {matched}
    end
})

-- ID 22: Jump Straight (e.g., 2, 4, 6, 8, 10)
SMODS.PokerHand({
    key = 'jump_straight',
    chips = 33,
    mult = 4,
    l_chips = 22,
    l_mult = 2,
    example = {
        { 'S_2', true }, { 'H_4', true }, { 'D_6', true }, { 'C_8', true }, { 'S_T', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        local ranks = {}
        for i = 1, #hand do table.insert(ranks, hand[i].base.id) end
        table.sort(ranks)
        for i = 1, 4 do
            if ranks[i+1] ~= ranks[i] + 2 then return end
        end
        return {hand}
    end
})

-- ID 24: Spectrum (One of each suit + 1)
SMODS.PokerHand({
    key = 'spectrum',
    chips = 41,
    mult = 4,
    l_chips = 27,
    l_mult = 3,
    example = {
        { 'S_2', true }, { 'H_5', true }, { 'D_8', true }, { 'C_J', true }, { 'S_A', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        local suits = {}
        for i = 1, #hand do
            suits[hand[i].base.suit] = true
        end
        local count = 0
        for _ in pairs(suits) do count = count + 1 end
        if count >= 4 then return {hand} end
    end
})

-- ID 29: Even Hand (2, 4, 6, 8, 10, Q)
SMODS.PokerHand({
    key = 'even_hand',
    chips = 26,
    mult = 2,
    l_chips = 17,
    l_mult = 2,
    example = {
        { 'S_2', true }, { 'H_4', true }, { 'D_6', true }, { 'C_8', true }, { 'S_T', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        for i = 1, #hand do
            if hand[i].base.id % 2 ~= 0 then return end
        end
        return {hand}
    end
})

-- ID 30: Odd Hand (3, 5, 7, 9, J, K, A)
SMODS.PokerHand({
    key = 'odd_hand',
    chips = 26,
    mult = 2,
    l_chips = 17,
    l_mult = 2,
    example = {
        { 'S_3', true }, { 'H_5', true }, { 'D_7', true }, { 'C_9', true }, { 'S_J', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        for i = 1, #hand do
            if hand[i].base.id % 2 == 0 then return end
        end
        return {hand}
    end
})

-- ID 33: Face Hand (Jack, Queen, King)
SMODS.PokerHand({
    key = 'face_hand',
    chips = 34,
    mult = 3,
    l_chips = 23,
    l_mult = 2,
    example = {
        { 'S_J', true }, { 'H_Q', true }, { 'D_K', true }, { 'C_J', true }, { 'S_Q', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        for i = 1, #hand do
            if not hand[i]:is_face() then return end
        end
        return {hand}
    end
})

-- ID 34: Number Hand (2-10)
SMODS.PokerHand({
    key = 'number_hand',
    chips = 22,
    mult = 2,
    l_chips = 17,
    l_mult = 2,
    example = {
        { 'S_2', true }, { 'H_5', true }, { 'D_8', true }, { 'C_3', true }, { 'S_T', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        for i = 1, #hand do
            if hand[i]:is_face() then return end
        end
        return {hand}
    end
})

-- ID 35: Low Hand (2, 3, 4, 5)
SMODS.PokerHand({
    key = 'low_hand',
    chips = 17,
    mult = 1,
    l_chips = 11,
    l_mult = 1,
    example = {
        { 'S_2', true }, { 'H_3', true }, { 'D_4', true }, { 'C_5', true }
    },
    evaluate = function(parts, hand)
        if #hand < 4 then return end
        for i = 1, #hand do
            if hand[i].base.id > 5 then return end
        end
        return {hand}
    end
})

-- ID 36: High Hand (10, J, Q, K, A)
SMODS.PokerHand({
    key = 'high_hand',
    chips = 36,
    mult = 3,
    l_chips = 21,
    l_mult = 2,
    example = {
        { 'S_T', true }, { 'H_J', true }, { 'D_Q', true }, { 'C_K', true }, { 'S_A', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        for i = 1, #hand do
            if hand[i].base.id < 10 then return end
        end
        return {hand}
    end
})

-- ID 25: Corner Hand (2s and As)
SMODS.PokerHand({
    key = 'corner_hand',
    chips = 39,
    mult = 4,
    l_chips = 26,
    l_mult = 3,
    example = {
        { 'S_2', true }, { 'H_2', true }, { 'D_A', true }, { 'C_A', true }
    },
    evaluate = function(parts, hand)
        if #hand < 4 then return end
        for i = 1, #hand do
            if hand[i].base.id ~= 2 and hand[i].base.id ~= 14 then return end
        end
        return {hand}
    end
})

-- ID 26: Middle Hand (7s and 8s)
SMODS.PokerHand({
    key = 'middle_hand',
    chips = 31,
    mult = 3,
    l_chips = 22,
    l_mult = 2,
    example = {
        { 'S_7', true }, { 'H_7', true }, { 'D_8', true }, { 'C_8', true }
    },
    evaluate = function(parts, hand)
        if #hand < 4 then return end
        for i = 1, #hand do
            if hand[i].base.id ~= 7 and hand[i].base.id ~= 8 then return end
        end
        return {hand}
    end
})

-- ID 49: Flush Pair
SMODS.PokerHand({
    key = 'flush_pair',
    chips = 43,
    mult = 4,
    l_chips = 27,
    l_mult = 3,
    example = {
        { 'S_2', true }, { 'S_2', true }, { 'S_5', true }, { 'H_T', true }, { 'D_K', true }
    },
    evaluate = function(parts, hand)
        if #hand < 3 then return end
        local flush = get_flush(hand)
        local pairs = get_n_of_a_kind(hand, 2)
        if #flush > 0 and #pairs > 0 then
            return {hand}
        end
    end
})

-- ID 50: Flush Two Pair
SMODS.PokerHand({
    key = 'flush_two_pair',
    chips = 56,
    mult = 6,
    l_chips = 37,
    l_mult = 4,
    example = {
        { 'S_2', true }, { 'S_2', true }, { 'S_5', true }, { 'S_5', true }, { 'S_A', true }
    },
    evaluate = function(parts, hand)
        if #hand < 4 then return end
        local flush = get_flush(hand)
        local pairs = get_n_of_a_kind(hand, 2)
        if #flush > 0 and #pairs >= 2 then
            return {hand}
        end
    end
})

-- ID 51: Flush Three of a Kind
SMODS.PokerHand({
    key = 'flush_three_of_a_kind',
    chips = 67,
    mult = 7,
    l_chips = 43,
    l_mult = 5,
    example = {
        { 'H_3', true }, { 'H_3', true }, { 'H_3', true }, { 'H_K', true }, { 'H_J', true }
    },
    evaluate = function(parts, hand)
        if #hand < 4 then return end
        local flush = get_flush(hand)
        local threes = get_n_of_a_kind(hand, 3)
        if #flush > 0 and #threes > 0 then
            return {hand}
        end
    end
})

-- ID 52: Flush Four of a Kind
SMODS.PokerHand({
    key = 'flush_four_of_a_kind',
    chips = 103,
    mult = 11,
    l_chips = 63,
    l_mult = 8,
    example = {
        { 'D_7', true }, { 'D_7', true }, { 'D_7', true }, { 'D_7', true }, { 'D_Q', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        local flush = get_flush(hand)
        local fours = get_n_of_a_kind(hand, 4)
        if #flush > 0 and #fours > 0 then
            return {hand}
        end
    end
})

-- ID 23: Alternating Straight (Red-Black Straight)
SMODS.PokerHand({
    key = 'alternating_straight',
    chips = 49,
    mult = 5,
    l_chips = 33,
    l_mult = 3,
    example = {
        { 'H_2', true }, { 'S_3', true }, { 'H_4', true }, { 'S_5', true }, { 'H_6', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        local straight = get_straight(hand)
        if #straight == 0 then return end
        
        -- Check color alternation
        local last_color = nil
        for i = 1, #hand do
            local current_color = (hand[i]:is_suit('Hearts') or hand[i]:is_suit('Diamonds')) and 'Red' or 'Black'
            if last_color and current_color == last_color then return end
            last_color = current_color
        end
        return {hand}
    end
})

-- ID 37: Mega Straight (6 cards)
SMODS.PokerHand({
    key = 'mega_straight',
    chips = 82,
    mult = 8,
    l_chips = 53,
    l_mult = 5,
    example = {
        { 'S_2', true }, { 'H_3', true }, { 'D_4', true }, { 'C_5', true }, { 'S_6', true }, { 'H_7', true }
    },
    evaluate = function(parts, hand)
        if #hand < 6 then return end
        local straight = get_straight(hand)
        if #straight > 0 and #straight[1] >= 6 then
            return straight
        end
    end
})

-- ID 38: Mega Flush (6 cards)
SMODS.PokerHand({
    key = 'mega_flush',
    chips = 82,
    mult = 8,
    l_chips = 53,
    l_mult = 5,
    example = {
        { 'S_2', true }, { 'S_4', true }, { 'S_6', true }, { 'S_8', true }, { 'S_T', true }, { 'S_Q', true }
    },
    evaluate = function(parts, hand)
        if #hand < 6 then return end
        local flush = get_flush(hand)
        if #flush > 0 and #flush[1] >= 6 then
            return flush
        end
    end
})

-- ID 39: Mega Full House (6 cards: 3 of a kind + 3 of a kind)
SMODS.PokerHand({
    key = 'mega_full_house',
    chips = 107,
    mult = 11,
    l_chips = 62,
    l_mult = 6,
    example = {
        { 'S_2', true }, { 'H_2', true }, { 'D_2', true }, { 'C_5', true }, { 'S_5', true }, { 'H_5', true }
    },
    evaluate = function(parts, hand)
        if #hand < 6 then return end
        local threes = get_n_of_a_kind(hand, 3)
        if #threes >= 2 then
            local matched = {}
            for i = 1, 3 do table.insert(matched, threes[1][i]) end
            for i = 1, 3 do table.insert(matched, threes[2][i]) end
            return {matched}
        end
    end
})

-- ID 40: Double Three of a Kind
SMODS.PokerHand({
    key = 'double_three_of_a_kind',
    chips = 107,
    mult = 11,
    l_chips = 62,
    l_mult = 6,
    example = {
        { 'S_3', true }, { 'H_3', true }, { 'D_3', true }, { 'C_8', true }, { 'S_8', true }, { 'H_8', true }
    },
    evaluate = function(parts, hand)
        if #hand < 6 then return end
        local threes = get_n_of_a_kind(hand, 3)
        if #threes >= 2 then
            local matched = {}
            for i = 1, 3 do table.insert(matched, threes[1][i]) end
            for i = 1, 3 do table.insert(matched, threes[2][i]) end
            return {matched}
        end
    end
})

-- ID 41, 42, 43: Multi Pairs
for i = 3, 5 do
    local keys = { [3] = 'triple_pair', [4] = 'quadruple_pair', [5] = 'quintuple_pair' }
    local chip_vals = { [3] = 51, [4] = 69, [5] = 87 }
    local mult_vals = { [3] = 5, [4] = 7, [5] = 9 }
    
    local example_cards = {}
    for j = 1, i do
        local rank = (j-1) % 13 + 2
        local rank_str = tostring(rank)
        if rank == 10 then rank_str = 'T'
        elseif rank == 11 then rank_str = 'J'
        elseif rank == 12 then rank_str = 'Q'
        elseif rank == 13 then rank_str = 'K'
        elseif rank == 14 then rank_str = 'A'
        end
        table.insert(example_cards, { 'S_' .. rank_str, true })
        table.insert(example_cards, { 'H_' .. rank_str, true })
    end

    SMODS.PokerHand({
        key = keys[i],
        chips = chip_vals[i],
        mult = mult_vals[i],
        l_chips = 10 * i + (i == 4 and 3 or 0), -- Just a bit varied
        l_mult = i,
        example = example_cards,
        evaluate = function(parts, hand)
            if #hand < i * 2 then return end
            local pairs = get_n_of_a_kind(hand, 2)
            if #pairs >= i then
                local matched = {}
                for j = 1, i do
                    for k = 1, 2 do table.insert(matched, pairs[j][k]) end
                end
                return {matched}
            end
        end
    })
end

-- ID 44-48: 6-10 of a kind
for i = 6, 10 do
    local keys = { [6] = 'six_of_a_kind', [7] = 'seven_of_a_kind', [8] = 'eight_of_a_kind', [9] = 'nine_of_a_kind', [10] = 'ten_of_a_kind' }
    local chip_vals = { [6] = 123, [7] = 157, [8] = 192, [9] = 234, [10] = 278 }
    local mult_vals = { [6] = 13, [7] = 17, [8] = 21, [9] = 24, [10] = 29 }
    
    local example_cards = {}
    for j = 1, i do
        table.insert(example_cards, { 'S_2', true })
    end

    SMODS.PokerHand({
        key = keys[i],
        chips = chip_vals[i],
        mult = mult_vals[i],
        l_chips = 70 + (i * 2),
        l_mult = 10,
        example = example_cards,
        evaluate = function(parts, hand)
            if #hand < i then return end
            local n_of_a_kind = get_n_of_a_kind(hand, i)
            if #n_of_a_kind > 0 then return n_of_a_kind end
        end
    })
end

-- ID 53-57: Flush 6-10 of a kind
for i = 6, 10 do
    local keys = { [6] = 'flush_six_of_a_kind', [7] = 'flush_seven_of_a_kind', [8] = 'flush_eight_of_a_kind', [9] = 'flush_nine_of_a_kind', [10] = 'flush_ten_of_a_kind' }
    local chip_vals = { [6] = 201, [7] = 287, [8] = 376, [9] = 489, [10] = 612 }
    local mult_vals = { [6] = 21, [7] = 31, [8] = 43, [9] = 57, [10] = 73 }
    
    local example_cards = {}
    for j = 1, i do
        table.insert(example_cards, { 'S_2', true })
    end

    SMODS.PokerHand({
        key = keys[i],
        chips = chip_vals[i],
        mult = mult_vals[i],
        l_chips = 90 + (i * 3),
        l_mult = 15,
        example = example_cards,
        evaluate = function(parts, hand)
            if #hand < i then return end
            local flush = get_flush(hand)
            local n_of_a_kind = get_n_of_a_kind(hand, i)
            if #flush > 0 and #n_of_a_kind > 0 then
                -- Check if the n_of_a_kind is actually the same suit
                for _, group in ipairs(n_of_a_kind) do
                    local suit = group[1].base.suit
                    local all_same = true
                    for j = 2, #group do
                        if group[j].base.suit ~= suit then all_same = false break end
                    end
                    if all_same then return {group} end
                end
            end
        end
    })
end

-- ID 58: Super Royal Flush (6+ cards)
SMODS.PokerHand({
    key = 'super_royal_flush',
    chips = 267,
    mult = 27,
    l_chips = 143,
    l_mult = 15,
    example = {
        { 'S_A', true }, { 'S_K', true }, { 'S_Q', true }, { 'S_J', true }, { 'S_T', true }, { 'S_9', true }
    },
    evaluate = function(parts, hand)
        if #hand < 6 then return end
        local flush = get_flush(hand)
        if #flush == 0 then return end
        local straight = get_straight(hand)
        if #straight == 0 or #straight[1] < 6 then return end
        -- Check if it contains Ace, King, Queen, Jack, 10, 9
        local has_9_to_A = true
        local ranks = { [14]=true, [13]=true, [12]=true, [11]=true, [10]=true, [9]=true }
        for r, _ in pairs(ranks) do
            local found = false
            for _, card in ipairs(hand) do
                if card.base.id == r then found = true break end
            end
            if not found then has_9_to_A = false break end
        end
        if has_9_to_A then return {hand} end
    end
})

-- ID 59: Ultimate Flush (All 4 suits represented, 8+ cards)
SMODS.PokerHand({
    key = 'ultimate_flush',
    chips = 208,
    mult = 21,
    l_chips = 187,
    l_mult = 17,
    example = {
        { 'S_2', true }, { 'S_3', true }, { 'H_4', true }, { 'H_5', true }, { 'D_6', true }, { 'D_7', true }, { 'C_8', true }, { 'C_9', true }
    },
    evaluate = function(parts, hand)
        if #hand < 8 then return end
        local suits = {}
        for i = 1, #hand do suits[hand[i].base.suit] = true end
        local count = 0
        for _ in pairs(suits) do count = count + 1 end
        if count == 4 then
            -- Also need 8 cards of same suit? No, "Ultimate Flush" usually means representation of all or something.
            -- Let's make it 8 cards and all 4 suits.
            return {hand}
        end
    end
})

-- ID 73: Royal Flush
SMODS.PokerHand({
    key = 'royal_flush',
    chips = 134,
    mult = 14,
    l_chips = 68,
    l_mult = 8,
    example = {
        { 'S_A', true }, { 'S_K', true }, { 'S_Q', true }, { 'S_J', true }, { 'S_T', true }
    },
    evaluate = function(parts, hand)
        if #hand < 5 then return end
        local flush = get_flush(hand)
        if #flush == 0 then return end
        local straight = get_straight(hand)
        if #straight == 0 then return end
        
        -- Check if it contains Ace, King, Queen, Jack, 10
        local has_10_to_A = true
        local ranks = { [14]=true, [13]=true, [12]=true, [11]=true, [10]=true }
        for r, _ in pairs(ranks) do
            local found = false
            for _, card in ipairs(hand) do
                if card.base.id == r then found = true break end
            end
            if not found then has_10_to_A = false break end
        end
        if has_10_to_A then return {hand} end
    end
})

-- Secret Hands (IDs 74-100)
for i = 1, 27 do
    -- Define a variety of card counts for mystery hands (3 to 8)
    local card_count = 5
    if i % 7 == 0 then card_count = 8
    elseif i % 5 == 0 then card_count = 4
    elseif i % 3 == 0 then card_count = 6
    elseif i % 2 == 0 then card_count = 5
    else card_count = 3
    end

    local example_cards = {}
    for j = 1, card_count do
        table.insert(example_cards, { 'S_A', false })
    end

    SMODS.PokerHand({
        key = 'secret_hand_' .. i,
        chips = 78 + (i * 7),
        mult = 7 + math.floor(i * 1.2),
        l_chips = 41 + (i % 5),
        l_mult = 3 + (i % 3),
        example = example_cards,
        visible = false, -- Secret hands are invisible until played
        evaluate = function(parts, hand)
            -- These are placeholders, real logic would go here
            return nil
        end
    })
end

-- ID 60 Planet hand reference
SMODS.PokerHand({
    key = 'all_hands',
    chips = 0,
    mult = 0,
    l_chips = 0,
    l_mult = 0,
    example = {
        { 'S_2', true }, { 'H_3', true }, { 'D_5', true }, { 'C_7', true }, { 'S_J', true }
    },
    visible = false,
    evaluate = function(parts, hand) return end
})

-- ID 60: All Hands (This is usually a placeholder for something else or a special hand)
-- For now I'll just skip it or make it a "Five Card Random"



-- ============================================
-- SINGULARITY - Common (Jokers 1-16)
-- ============================================

-- 1. Solitary
SMODS.Joker({
    key = 'j_singularity_solitary',
    config = { extra = { mult = 12 } },
    rarity = 1,  -- Common
    atlas = 'j_singularity_solitary',  -- Custom sprite
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            -- Count active jokers
            local joker_count = 0
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] then
                    joker_count = joker_count + 1
                end
            end
            
            -- If only one joker exists
            if joker_count == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 2. Isolated
SMODS.Joker({
    key = 'j_singularity_isolated',
    atlas = 'j_singularity_isolated',
    config = { extra = { chips = 8 } },
    rarity = 1,
    pos = { x = 0, y = 0 }, -- Common
    
    
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local empty_slots = G.jokers.config.card_limit - #G.jokers.cards
            if empty_slots > 0 then
                local bonus = empty_slots * card.ability.extra.chips
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { bonus } },
                    chip_mod = bonus,
                    colour = G.C.CHIPS
                }
            end
        end
        return nil
    end
})

-- 3. Hermit
SMODS.Joker({
    key = 'j_singularity_hermit',
    atlas = 'j_singularity_hermit',
    config = { extra = { mult = 0, mult_gain = 2, bought_this_round = false } },
    rarity = 1,  -- Common
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        -- Aplica o Mult acumulado
        if context.joker_main then
            if card.ability.extra.mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
        
        -- No final da rodada, aumenta Mult se no comprou nada
        if context.end_of_round and not context.repetition and not context.other_card then
            if not card.ability.extra.bought_this_round then
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
            -- Reset tracker para prxima rodada
            card.ability.extra.bought_this_round = false
        end
        
        -- Rastreia compras na loja
        if context.buying_card then
            card.ability.extra.bought_this_round = true
        end
        
        return nil
    end
})

-- 4. Purist
SMODS.Joker({
    key = 'j_singularity_purist',
    atlas = 'j_singularity_purist',
    config = { extra = { mult = 15 } },
    rarity = 1,  -- Common
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local deck_size = #G.playing_cards
            if deck_size == 52 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 5. Minimalist
SMODS.Joker({
    key = 'j_singularity_minimalist',
    atlas = 'j_singularity_minimalist',
    config = { extra = { mult_per_missing = 4 } },
    rarity = 1,
    pos = { x = 0, y = 0 }, -- Common
    
    
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_per_missing } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local deck_size = #G.playing_cards
            local missing = math.max(0, 52 - deck_size)
            if missing > 0 then
                local bonus = missing * card.ability.extra.mult_per_missing
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { bonus } },
                    mult_mod = bonus,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 6. Unique
SMODS.Joker({
    key = 'j_singularity_unique',
    atlas = 'j_singularity_unique',
    config = { extra = { mult = 10 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local duplicates = 0
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] and G.jokers.cards[i] ~= card and G.jokers.cards[i].ability.name == card.ability.name then
                    duplicates = duplicates + 1
                end
            end
            
            if duplicates == 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 7. Singular
SMODS.Joker({
    key = 'j_singularity_singular',
    atlas = 'j_singularity_singular',
    config = { extra = { bought_rarities = {} } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        return { vars = {} }
    end,
    
    calculate = function(self, card, context)
        if context.buying_card and context.card and context.card.ability.set == 'Joker' then
            local rarity = context.card.config.center.rarity
            if rarity and not card.ability.extra.bought_rarities[rarity] then
                card.ability.extra.bought_rarities[rarity] = true
                ease_dollars(context.card.cost)
                return {
                    message = localize('k_val_up'),
                    colour = G.C.MONEY
                }
            end
        end
        return nil
    end
})

-- 8. Monopolist
SMODS.Joker({
    key = 'j_singularity_monopolist',
    atlas = 'j_singularity_monopolist',
    config = { extra = { xmult = 1.5, min_expensive = 3, cost_threshold = 8 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult .. '', extra.min_expensive, extra.cost_threshold } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local expensive_count = 0
            
            -- Conta quantos Jokers tm custo de compra de $8 ou mais
            for i = 1, #G.jokers.cards do
                local joker = G.jokers.cards[i]
                if joker and joker.cost >= card.ability.extra.cost_threshold then
                    expensive_count = expensive_count + 1
                end
            end
            
            -- Ativa se tiver pelo menos 3 Jokers caros
            if expensive_count >= card.ability.extra.min_expensive then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 9. Exclusivo
SMODS.Joker({
    key = 'j_singularity_exclusive',
    atlas = 'j_singularity_exclusive',
    config = { extra = { xmult = 1.5, limit = 3 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult .. '' } }

    
    end,
    
    can_use = function(self, card)
        -- Impede compra se j tem 3 ou mais jokers
        if G.jokers and #G.jokers.cards >= 3 then
            return false
        end
        return true
    end,
    
    add_to_deck = function(self, card, from_debuff)
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit - 2
        end
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit + 2
        end
    end,
    
    calculate = function(self, card, context)
        -- Aplica X1.5 Mult em TODOS os jokers
        if context.other_joker then
            -- Multiplica o resultado de outro joker por 1.5
            if context.other_joker ~= card then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 10. Solitrio Csmico
SMODS.Joker({
    key = 'j_singularity_cosmic_solitary',
    atlas = 'j_singularity_cosmic_solitary',
    config = { extra = { xmult = 2 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult .. '' } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if #G.jokers.cards == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 11. Asceta
SMODS.Joker({
    key = 'j_singularity_ascetic',
    atlas = 'j_singularity_ascetic',
    config = { extra = { mult = 10, money = 2, bought_something = false } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.buying_card then
            card.ability.extra.bought_something = true
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            if not card.ability.extra.bought_something then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
            card.ability.extra.bought_something = false
        end
        
        if context.joker_main and not card.ability.extra.bought_something then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        return nil
    end
})

-- 12. One Man Army
SMODS.Joker({
    key = 'j_singularity_one_man_army',
    atlas = 'j_singularity_one_man_army',
    config = { extra = { xmult = 2 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult .. '' } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and #G.jokers.cards == 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
        return nil
    end
})

-- 13. Isolamento Total
SMODS.Joker({
    key = 'j_singularity_total_isolation',
    atlas = 'j_singularity_total_isolation',
    config = { extra = { xmult = 3 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult .. '' } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 14. Sozinho no Espao
SMODS.Joker({
    key = 'j_singularity_alone_in_space',
    atlas = 'j_singularity_alone_in_space',
    config = { extra = { money = 2 } },
    rarity = 1,        pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            -- Calcula APENAS slots vazios de joker, NO cartas na mo
            local empty_slots = G.jokers.config.card_limit - #G.jokers.cards
            if empty_slots > 0 then
                local earnings = empty_slots * card.ability.extra.money
                ease_dollars(earnings)
                return {
                    message = localize('$') .. earnings,
                    colour = G.C.MONEY
                }
            end
        end
        return nil
    end
})

-- 15. Ermito Estelar
SMODS.Joker({
    key = 'j_singularity_stellar_hermit',
    atlas = 'j_singularity_stellar_hermit',
    config = { extra = { chips = 50, used_consumable = false } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.using_consumeable then
            card.ability.extra.used_consumable = true
        end
        
        if context.joker_main and not card.ability.extra.used_consumable then
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                chip_mod = card.ability.extra.chips,
                colour = G.C.CHIPS
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.used_consumable = false
        end
        return nil
    end
})

-- 16. Solido Csmica
SMODS.Joker({
    key = 'j_singularity_cosmic_solitude',
    atlas = 'j_singularity_cosmic_solitude',
    config = { extra = { xmult = 1, xmult_gain = 0.2, bought_joker = false } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult .. '', extra.xmult_gain .. '' } }

    
    end,
    
    calculate = function(self, card, context)
        if context.buying_card and context.card.ability.set == 'Joker' then
            card.ability.extra.bought_joker = true
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            -- S ativa no final do Boss Blind de cada Ante
            if G.GAME.blind and G.GAME.blind.boss then
                if not card.ability.extra.bought_joker then
                    card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_gain
                    card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_upgrade_ex'), colour = G.C.MULT })
                end
                card.ability.extra.bought_joker = false -- Reset para o prximo Ante
            end
        end
        
        if context.joker_main and card.ability.extra.xmult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
        return nil
    end
})


-- ============================================
-- SINGULARITY - Uncommon (Jokers 17-30)
-- ============================================

-- 17. Singularidade Crescente
SMODS.Joker({
    key = 'j_singularity_growing_singularity',
    atlas = 'j_singularity_growing_singularity',
    config = { extra = { xmult = 1, xmult_gain = 0.2 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult, extra.xmult_gain .. '' } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if #G.jokers.cards == 1 then
                card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_gain
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_upgrade_ex'), colour = G.C.MULT })
            end
        end
        
        if context.joker_main and card.ability.extra.xmult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
        return nil
    end
})

-- 18. Isolador Dimensional
SMODS.Joker({
    key = 'j_singularity_dimensional_isolator',
    atlas = 'j_singularity_dimensional_isolator',
    config = { extra = { mult = 50, xmult = 2 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            -- Encontra posio deste Joker
            local my_index = nil
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then
                    my_index = i
                    break
                end
            end
            
            if my_index then
                local has_left = my_index > 1
                local has_right = my_index < #G.jokers.cards
                
                -- S ativa se NO tiver adjacentes EM AMBOS os lados
                -- (pode ter 1 lado vazio, mas no pode ter os 2 lados ocupados)
                if not (has_left and has_right) then
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                        mult_mod = card.ability.extra.mult,
                        Xmult_mod = card.ability.extra.xmult,
                        colour = G.C.MULT
                    }
                end
            end
        end
        return nil
    end
})

-- 19. nica Esperana
SMODS.Joker({
    key = 'j_singularity_only_hope',
    atlas = 'j_singularity_only_hope',
    config = { extra = { xmult = 5 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G and G.GAME and G.GAME.current_round and 
               G.GAME.current_round.hands_left == 1 and 
               G.jokers and G.jokers.cards and #G.jokers.cards == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
        return nil
    end
})

-- 20. Monlito
SMODS.Joker({
    key = 'j_singularity_monolith',
    atlas = 'j_singularity_monolith',
    config = { extra = { xmult = 2.5, takes_slots = 2 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end,
    
    add_to_deck = function(self, card, from_debuff)
        -- Reduz limite de slots quando adicionado
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit - 1
        end
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        -- Restaura slot quando removido
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit + 1
        end
    end
})

-- 21. Solidificao
SMODS.Joker({
    key = 'j_singularity_solidification',
    atlas = 'j_singularity_solidification',
    config = { extra = { xmult = 2.5, rounds_required = 5, current_rounds = 0, last_pos = nil } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.current_rounds, extra.rounds_required, extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        -- Verifica posio no incio de cada rodada
        if context.end_of_round and not context.repetition and not context.other_card then
            -- Encontra posio atual
            local current_pos = nil
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then
                    current_pos = i
                    break
                end
            end
            
            if current_pos and card.ability.extra.last_pos == current_pos then
                card.ability.extra.current_rounds = card.ability.extra.current_rounds + 1
            else
                card.ability.extra.current_rounds = 0
                card.ability.extra.last_pos = current_pos
            end
            
            if card.ability.extra.current_rounds >= card.ability.extra.rounds_required then
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = 'Solidificado!', colour = G.C.MULT })
            end
        end
        
        if context.joker_main and card.ability.extra.current_rounds >= card.ability.extra.rounds_required then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 22. Universo Paralelo
SMODS.Joker({
    key = 'j_singularity_parallel_universe',
    atlas = 'j_singularity_parallel_universe',
    config = { extra = { mult = 20 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        
        -- No fim da rodada, se houver apenas 1, cria cpia
        if context.end_of_round and not context.repetition and not context.other_card then
            local count = 0
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i].ability.name == card.ability.name then
                    count = count + 1
                end
            end
            
            if count == 1 and #G.jokers.cards < G.jokers.config.card_limit then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local copy = copy_card(card, nil)
                        copy:add_to_deck()
                        G.jokers:emplace(copy)
                        return true
                    end
                }))
                return {
                    message = 'Espelhado!',
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 23. Ponto Zero
SMODS.Joker({
    key = 'j_singularity_point_zero',
    atlas = 'j_singularity_point_zero',
    config = { extra = { xmult = 3 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.dollars == 0 and #G.jokers.cards == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 24. Singularidade Negra
SMODS.Joker({
    key = 'j_singularity_black_singularity',
    atlas = 'j_singularity_black_singularity',
    config = { extra = { mult = 0, gain = 5 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.selling_card and context.card.ability.set == 'Joker' and context.card ~= card then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT,
                card = card
            }
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 25. Estrela Solitria
SMODS.Joker({
    key = 'j_singularity_lonely_star',
    atlas = 'j_singularity_lonely_star',
    config = { extra = { xmult = 1, gain = 0.2 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult, extra.gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card and #G.jokers.cards == 1 then
            card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
        
        if context.joker_main and card.ability.extra.xmult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 26. Individualismo
SMODS.Joker({
    key = 'j_singularity_individualism',
    atlas = 'j_singularity_individualism',
    config = { extra = { mult = 50 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 27. Vazio Primordial
SMODS.Joker({
    key = 'j_singularity_primordial_void',
    atlas = 'j_singularity_primordial_void',
    config = { extra = { xmult = 1, base_xmult = 5 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        if G.jokers and not from_debuff then
            local destroyed = false
            for i = #G.jokers.cards, 1, -1 do
                if G.jokers.cards[i] ~= card then
                    G.jokers.cards[i]:start_dissolve()
                    destroyed = true
                end
            end
            if destroyed then
                card.ability.extra.xmult = card.ability.extra.base_xmult
            end
        end
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and card.ability.extra.xmult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 28. Isolamento Quntico
SMODS.Joker({
    key = 'j_singularity_quantum_isolation',
    atlas = 'j_singularity_quantum_isolation',
    config = { extra = { mult = 20, chance = 4 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.chance } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            if #G.jokers.cards == 1 and pseudorandom('quantum_isolation') < G.GAME.probabilities.normal / card.ability.extra.chance then
                if #G.jokers.cards < G.jokers.config.card_limit then
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            local copy = copy_card(card, nil)
                            copy:add_to_deck()
                            G.jokers:emplace(copy)
                            return true
                        end
                    }))
                    return {
                        message = 'Duplicado!',
                        colour = G.C.MULT
                    }
                end
            end
        end
    end
})

-- 29. Monoplio Csmico
SMODS.Joker({
    key = 'j_singularity_cosmic_monopoly',
    atlas = 'j_singularity_cosmic_monopoly',
    config = { extra = { xmult = 3 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local same_rarity = true
            local first_rarity = nil
            for i = 1, #G.jokers.cards do
                local r = G.jokers.cards[i].config.center.rarity
                if not first_rarity then
                    first_rarity = r
                elseif first_rarity ~= r then
                    same_rarity = false
                    break
                end
            end
            
            if same_rarity and #G.jokers.cards > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 30. Singularidade Reversa
SMODS.Joker({
    key = 'j_singularity_reverse_singularity',
    atlas = 'j_singularity_reverse_singularity',
    config = { extra = { xmult_reduction = 0.8 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local joker_count = G.jokers and #G.jokers.cards or 0
        local total_xmult = ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_reduction ^ joker_count
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_reduction, joker_count, total_xmult } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local joker_count = #G.jokers.cards
            local total_xmult = card.ability.extra.xmult_reduction ^ joker_count
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { total_xmult } },
                Xmult_mod = total_xmult,
                colour = G.C.MULT
            }
        end
    end
})



-- ============================================
-- SINGULARITY - Rare (Jokers 31-38)
-- ============================================

-- 31. Buraco Negro
SMODS.Joker({
    key = 'j_singularity_black_hole',
    atlas = 'j_singularity_black_hole',
    config = { extra = { mult = 0, gain = 10, last_ante = 0 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card and G.GAME.blind.boss then
            local targets = {}
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] ~= card and not G.jokers.cards[i].ability.eternal then
                    table.insert(targets, G.jokers.cards[i])
                end
            end
            
            if #targets > 0 then
                local target = pseudorandom_element(targets, pseudoseed('black_hole'))
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
                target:start_dissolve()
                return {
                    message = 'Absorvido!',
                    colour = G.C.MULT
                }
            end
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 32. Singularidade Absoluta
SMODS.Joker({
    key = 'j_singularity_absolute_singularity',
    atlas = 'j_singularity_absolute_singularity',
    config = { extra = { xmult = 10 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local legendary_count = 0
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i].config.center.rarity == 4 then
                    legendary_count = legendary_count + 1
                end
            end
            
            if legendary_count == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 33. Ponto de No Retorno
SMODS.Joker({
    key = 'j_singularity_point_of_no_return',
    atlas = 'j_singularity_point_of_no_return',
    config = { extra = { xmult = 1, gain_per_destroyed = 5 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 15,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult, extra.gain_per_destroyed } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        if G.jokers and not from_debuff then
            local count = 0
            for i = #G.jokers.cards, 1, -1 do
                if G.jokers.cards[i] ~= card then
                    G.jokers.cards[i]:start_dissolve()
                    count = count + 1
                end
            end
            card.ability.extra.xmult = 1 + (count * card.ability.extra.gain_per_destroyed)
        end
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and card.ability.extra.xmult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 34. Colapso Estelar
SMODS.Joker({
    key = 'j_singularity_stellar_collapse',
    atlas = 'j_singularity_stellar_collapse',
    config = { extra = { } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        return { vars = { } }
    end,
    
    calculate = function(self, card, context)
        if context.selling_card and context.card.ability.set == 'Joker' and context.card ~= card then
            if #G.consumeables.cards < G.consumeables.config.card_limit then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, nil, 'collapse')
                        _card:add_to_deck()
                        G.consumeables:emplace(_card)
                        return true
                    end
                }))
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = 'Spectral!', colour = G.C.SECONDARY_SET.Spectral })
            end
        end
    end
})

-- 35. Singularidade Temporal
SMODS.Joker({
    key = 'j_singularity_temporal_singularity',
    atlas = 'j_singularity_temporal_singularity',
    config = { extra = { repetitions = 2 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 14,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.repetitions } }

    
    end,
    
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play and #G.jokers.cards == 1 then
            return {
                message = localize('k_again_ex'),
                repetitions = card.ability.extra.repetitions,
                card = card
            }
        end
    end
})

-- 36. Vcuo Perfeito
SMODS.Joker({
    key = 'j_singularity_perfect_vacuum',
    atlas = 'j_singularity_perfect_vacuum',
    config = { extra = { chips = 100 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play and #G.jokers.cards == 1 then
            return {
                chips = card.ability.extra.chips,
                card = card
            }
        end
    end
})

-- 37. Singularidade Inversa
SMODS.Joker({
    key = 'j_singularity_inverse_singularity',
    atlas = 'j_singularity_inverse_singularity',
    config = { extra = { xmult = 3 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.chips < G.GAME.blind.chips then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 38. Ponto mega
SMODS.Joker({
    key = 'j_singularity_omega_point',
    atlas = 'j_singularity_omega_point',
    config = { extra = { xmult_base = 1, gain = 0.5 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 14,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local current_xmult = 1 + (G.GAME.hands_played * ( (card and card.ability and card.ability.extra) or self.config.extra ).gain)
        return { vars = { current_xmult } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and #G.jokers.cards == 1 then
            local current_xmult = 1 + (G.GAME.hands_played * card.ability.extra.gain)
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { current_xmult } },
                Xmult_mod = current_xmult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- SINGULARITY - Legendary (Jokers 39-40)
-- ============================================

-- 39. Singularidade Primordial
SMODS.Joker({
    key = 'j_singularity_primordial',
    atlas = 'j_singularity_primordial',
    config = { extra = { xmult = 25 } },
    rarity = 4,
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if #G.jokers.cards == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 40. Big Bang Reverso
SMODS.Joker({
    key = 'j_singularity_reverse_big_bang',
    atlas = 'j_singularity_reverse_big_bang',
    config = { extra = { xmult = 10 } },
    rarity = 4,
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})



-- ============================================
-- QUANTUM - Common (Jokers 41-56)
-- ============================================

-- 41. Superposio
SMODS.Joker({
    key = 'j_quantum_superposition',
    config = { extra = { mult = 10, chips = 40 } },
    atlas = 'j_quantum_superposition',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('superposition') < 0.5 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- 42. Flutuao Quntica
SMODS.Joker({
    key = 'j_quantum_quantum_fluctuation',
    atlas = 'j_quantum_quantum_fluctuation',
    config = { extra = { mult = 15, min = 5, max = 25 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.min, extra.max } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.mult = math.floor(pseudorandom('fluctuation') * (card.ability.extra.max - card.ability.extra.min + 1) + card.ability.extra.min)
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_val_up'), colour = G.C.MULT })
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 43. Incerteza
SMODS.Joker({
    key = 'j_quantum_uncertainty',
    atlas = 'j_quantum_uncertainty',
    config = { extra = { mult = 50, money = 5, odds = 4 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('uncertainty') < G.GAME.probabilities.normal / card.ability.extra.odds then
                local outcome = math.floor(pseudorandom('uncertainty_outcome') * 3) + 1
                if outcome == 1 then
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                        mult_mod = card.ability.extra.mult,
                        colour = G.C.MULT
                    }
                elseif outcome == 2 then
                    ease_dollars(card.ability.extra.money)
                    return {
                        message = localize('$') .. card.ability.extra.money,
                        colour = G.C.MONEY
                    }
                else
                    G.GAME.current_round.free_rerolls = (G.GAME.current_round.free_rerolls or 0) + 1
                    return {
                        message = localize('k_plus_reroll'),
                        colour = G.C.GREEN
                    }
                end
            end
        end
    end
})

-- 44. Dualidade
SMODS.Joker({
    key = 'j_quantum_duality',
    atlas = 'j_quantum_duality',
    config = { extra = { mult = 15, chips = 50 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                chip_mod = card.ability.extra.chips,
                colour = G.C.MULT
            }
        end
    end
})

-- 45. Emaranhamento
SMODS.Joker({
    key = 'j_quantum_entanglement',
    atlas = 'j_quantum_entanglement',
    config = { extra = { mult = 15 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local bonus = 0
            -- Check joker to the right
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card and G.jokers.cards[i+1] then
                    local right_joker = G.jokers.cards[i+1]
                    if right_joker.ability.extra and type(right_joker.ability.extra) == 'table' then
                        -- Average all numeric values in extra
                        local sum, count = 0, 0
                        for _, v in pairs(right_joker.ability.extra) do
                            if type(v) == 'number' then
                                sum = sum + v
                                count = count + 1
                            end
                        end
                        if count > 0 then bonus = math.floor(sum / count) end
                    elseif type(right_joker.ability.extra) == 'number' then
                        bonus = right_joker.ability.extra
                    end
                end
            end
            
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult + bonus } },
                mult_mod = card.ability.extra.mult + bonus,
                colour = G.C.MULT
            }
        end
    end
})

-- 46. Salto Quntico
SMODS.Joker({
    key = 'j_quantum_quantum_leap',
    atlas = 'j_quantum_quantum_leap',
    config = { extra = { mult = 15, odyssey_debuff_adj = true } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 47. Probabilidade
SMODS.Joker({
    key = 'j_quantum_probability',
    atlas = 'j_quantum_probability',
    config = { extra = { mult_per_common = 5 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.jokers then
            for _, v in ipairs(G.jokers.cards) do
                if v.config.center.rarity == 1 then count = count + 1 end
            end
        end
        return { vars = { count * card.ability.extra.mult_per_common } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for _, v in ipairs(G.jokers.cards) do
                if v.config.center.rarity == 1 then count = count + 1 end
            end
            local tot = count * card.ability.extra.mult_per_common
            if tot > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { tot } },
                    mult_mod = tot,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 48. Gato de Schrdinger
SMODS.Joker({
    key = 'j_quantum_schrodinger',
    atlas = 'j_quantum_schrodinger',
    config = { extra = { mult = 25, chips = 100, money = 5, odds = 4 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.chips, extra.money, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            ease_dollars(card.ability.extra.money)
            return {
                message = 'Superposto!',
                mult_mod = card.ability.extra.mult,
                chip_mod = card.ability.extra.chips,
                colour = G.C.MULT
            }
        end
        
        if context.after and not context.blueprint and not context.repetition then
            if pseudorandom('schrodinger') < G.GAME.probabilities.normal / card.ability.extra.odds then
                if not card.ability.eternal then 
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            card:start_dissolve()
                            return true
                        end
                    }))
                end
                return {
                    message = 'Colapsou!',
                    colour = G.C.FILTER
                }
            end
        end
    end
})

-- 49. Colapso de Onda
SMODS.Joker({
    key = 'j_quantum_wave_collapse',
    atlas = 'j_quantum_wave_collapse',
    config = { extra = { mult = 20, chips = 100, money = 5, mode = 1 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.chips, extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.mode = (card.ability.extra.mode % 3) + 1
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_val_up'), colour = G.C.FILTER })
        end
        
        if context.joker_main then
            if card.ability.extra.mode == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            elseif card.ability.extra.mode == 2 then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            else
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 50. Tunelamento
SMODS.Joker({
    key = 'j_quantum_tunneling',
    atlas = 'j_quantum_tunneling',
    config = { extra = { mult = 15, odds = 20 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint and not context.repetition then
            if pseudorandom('tunneling') < G.GAME.probabilities.normal / card.ability.extra.odds then
                ease_discard(1)
                return {
                    message = localize('k_plus_discard'),
                    colour = G.C.BLUE
                }
            end
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 51. Estado Quntico
SMODS.Joker({
    key = 'j_quantum_quantum_state',
    atlas = 'j_quantum_quantum_state',
    config = { extra = { mult = 15, x_mult = 1.5, mode = 1 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.x_mult, extra.mode } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            card.ability.extra.mode = (card.ability.extra.mode % 2) + 1
            if card.ability.extra.mode == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 52. Observador
SMODS.Joker({
    key = 'j_quantum_observer',
    atlas = 'j_quantum_observer',
    config = { extra = { x_mult = 2, active = true } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.active = true
        end
        
        if context.joker_main and card.ability.extra.active then
            card.ability.extra.active = false
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 53. Antimatria
SMODS.Joker({
    key = 'j_quantum_antimatter',
    atlas = 'j_quantum_antimatter',
    config = { extra = { mult = 0, gain = 10 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint and not context.repetition then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 54. Entrelaado
SMODS.Joker({
    key = 'j_quantum_entangled',
    atlas = 'j_quantum_entangled',
    config = { extra = { x_mult = 2.5 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for _, v in ipairs(G.jokers.cards) do
                if v.config.center.key == card.config.center.key then count = count + 1 end
            end
            
            if count >= 2 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 55. Spin Quntico
SMODS.Joker({
    key = 'j_quantum_quantum_spin',
    atlas = 'j_quantum_quantum_spin',
    config = { extra = { mult = 30, odds = 3 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('spin') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 56. Partcula Virtual
SMODS.Joker({
    key = 'j_quantum_virtual_particle',
    atlas = 'j_quantum_virtual_particle',
    config = { extra = { x_mult = 3, rounds = 3 } },
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = false,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.rounds, extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.rounds = card.ability.extra.rounds - 1
            if card.ability.extra.rounds <= 0 then
                if not card.ability.eternal then card:start_dissolve() end
            else
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = card.ability.extra.rounds .. '', colour = G.C.FILTER })
            end
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- QUANTUM - Uncommon (Jokers 57-70)
-- ============================================

-- 57. Campo Quntico
SMODS.Joker({
    key = 'j_quantum_quantum_field',
    atlas = 'j_quantum_quantum_field',
    config = { extra = { mult_bonus = 20 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_bonus } }

    
    end,
    
    calculate = function(self, card, context)
        if context.other_joker and context.other_joker ~= card then
            -- Verifica se  adjacente
            local my_index = nil
            local other_index = nil
            
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then my_index = i end
                if G.jokers.cards[i] == context.other_joker then other_index = i end
            end
            
            if my_index and other_index and math.abs(my_index - other_index) == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult_bonus } },
                    mult_mod = card.ability.extra.mult_bonus,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 58. Decaimento
SMODS.Joker({
    key = 'j_quantum_decay',
    atlas = 'j_quantum_decay',
    config = { extra = { x_mult = 4, decay = 0.2 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.decay } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.x_mult = math.max(1, card.ability.extra.x_mult - card.ability.extra.decay)
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }, colour = G.C.MULT })
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 59. Fisso
SMODS.Joker({
    key = 'j_quantum_fission',
    atlas = 'j_quantum_fission',
    config = { extra = { mult = 30 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 60. Fuso
SMODS.Joker({
    key = 'j_quantum_fusion',
    atlas = 'j_quantum_fusion',
    config = { extra = { x_mult = 1, x_mult_gain = 1.5 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.x_mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local absorbed = false
            for i = #G.jokers.cards, 1, -1 do
                local other = G.jokers.cards[i]
                if other and other ~= card and other.config.center.key == card.config.center.key and not other.ability.eternal then
                    other:start_dissolve()
                    card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
                    absorbed = true
                end
            end
            if absorbed then
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_upgrade_ex'), colour = G.C.MULT })
            end
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 62. Dj Vu
SMODS.Joker({
    key = 'j_quantum_deja_vu',
    atlas = 'j_quantum_deja_vu',
    config = { extra = { x_mult = 2.5 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.last_hand_played == context.scoring_name then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 63. Loop Infinito
SMODS.Joker({
    key = 'j_quantum_infinite_loop',
    atlas = 'j_quantum_infinite_loop',
    config = { extra = { mult = 30, count = 0, trigger = 3 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.played, extra.trigger } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint and not context.repetition then
            card.ability.extra.played = (card.ability.extra.played % card.ability.extra.trigger) + 1
        end
        
        -- Se estiver no gatilho, repete todas as cartas
        if context.repetition and context.cardarea == G.play then
            if card.ability.extra.played == card.ability.extra.trigger then
                return {
                    message = 'Loop!',
                    repetitions = 1,
                    card = card
                }
            end
        end
        
        if context.joker_main then
            if card.ability.extra.played == card.ability.extra.trigger then
                return {
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 64. Rewind
SMODS.Joker({
    key = 'j_quantum_rewind',
    atlas = 'j_quantum_rewind',
    config = { extra = { } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        return { vars = { } }
    end,
    
    calculate = function(self, card, context)
        -- Reativa cartas jogadas na mo
        if context.repetition and context.cardarea == G.play then
            return {
                message = 'Rewind!',
                repetitions = 1,
                card = card
            }
        end
    end
})

-- 65. Acelerao Temporal
SMODS.Joker({
    key = 'j_quantum_time_acceleration',
    atlas = 'j_quantum_time_acceleration',
    config = { extra = { x_mult = 1, x_mult_gain = 0.1 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.x_mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint and not context.repetition then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 66. ncora Temporal
SMODS.Joker({
    key = 'j_quantum_time_anchor',
    atlas = 'j_quantum_time_anchor',
    config = { extra = { x_mult = 3, fixed_money = 15 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 15,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.fixed_money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local diff = card.ability.extra.fixed_money - G.GAME.dollars
            ease_dollars(diff)
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 67. Chrono Trigger
SMODS.Joker({
    key = 'j_quantum_chrono_trigger',
    atlas = 'j_quantum_chrono_trigger',
    config = { extra = { mult = 100, count = 0, trigger = 5 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.played, extra.trigger, extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint and not context.repetition then
            card.ability.extra.played = card.ability.extra.played + 1
        end
        
        if context.joker_main then
            if card.ability.extra.played >= card.ability.extra.trigger then
                card.ability.extra.played = 0
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 68. Entropia
SMODS.Joker({
    key = 'j_quantum_entropy',
    atlas = 'j_quantum_entropy',
    config = { extra = { mult = 25, x_mult = 1.5, chips = 50 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.x_mult, extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local effect = math.floor(pseudorandom('entropy') * 3) + 1
            if effect == 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            elseif effect == 2 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- 69. Viajante do Tempo
SMODS.Joker({
    key = 'j_quantum_time_traveler',
    atlas = 'j_quantum_time_traveler',
    config = { extra = { mult = 40 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 70. Teleportador
SMODS.Joker({
    key = 'j_quantum_slow_motion',
    atlas = 'j_quantum_slow_motion',
    config = { extra = { x_mult = 2, discards = 1 } },
    rarity = 2,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.discards } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards
        ease_discard(card.ability.extra.discards)
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards
        ease_discard(-card.ability.extra.discards)
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- ============================================
-- QUANTUM - Rare (Jokers 71-78)
-- ============================================

-- 71. Portal Dimensional
SMODS.Joker({
    key = 'j_quantum_dimensional_portal',
    atlas = 'j_quantum_dimensional_portal',
    config = { extra = { mult = 40, odds = 10 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local normal_prob = G.GAME and G.GAME.probabilities and G.GAME.probabilities.normal or 1
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult, '' .. normal_prob, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } }
    end,
    
    calculate = function(self, card, context)
        -- Chance to change suit after playing hand
        if context.after and not context.blueprint then
            if pseudorandom('portal_dimensional') < G.GAME.probabilities.normal / card.ability.extra.odds then
                -- Pick a random card from hand (remaining cards)
                if G.hand and G.hand.cards and #G.hand.cards > 0 then
                    local target_card = pseudorandom_element(G.hand.cards, pseudoseed('portal_card'))
                    
                    local suits = {'Hearts', 'Diamonds', 'Clubs', 'Spades'}
                    local current_suit = target_card.base.suit
                    local new_suit = pseudorandom_element(suits, pseudoseed('portal_suit'))
                    
                    -- Ensure suit changed
                    while new_suit == current_suit and #suits > 1 do
                        new_suit = pseudorandom_element(suits, pseudoseed('portal_suit'))
                    end
                    
                    target_card:set_base(G.P_CARDS[new_suit..'_'..target_card.base.value])
                    
                    card_eval_status_text(card, 'extra', nil, nil, nil, {
                        message = 'Portal!',
                        colour = G.C.PURPLE
                    })
                end
            end
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 72. Espelho
SMODS.Joker({
    key = 'j_quantum_mirror',
    atlas = 'j_quantum_mirror',
    config = { extra = { mult = 50, is_reflection = false } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        if not from_debuff and not card.ability.extra.is_reflection and not G.CONTROLLER.loading and #G.jokers.cards < G.jokers.config.card_limit then
            local copy = create_card('Joker', G.jokers, nil, nil, nil, nil, 'j_quantum_mirror')
            copy.ability.extra.mult = math.floor(card.ability.extra.mult / 2)
            copy.ability.extra.is_reflection = true
            copy:add_to_deck()
            G.jokers:emplace(copy)
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = 'Refletido!', colour = G.C.MULT })
        end
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 73. Yin Yang
SMODS.Joker({
    key = 'j_quantum_yin_yang',
    atlas = 'j_quantum_yin_yang',
    config = { extra = { mult = 80, chips = 150, is_mult = true } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.is_mult and 'Mult' or 'Fichas', extra.mult, extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.is_mult = not card.ability.extra.is_mult
            card_eval_status_text(card, 'extra', nil, nil, nil, { 
                message = card.ability.extra.is_mult and 'Mult!' or 'Fichas!', 
                colour = card.ability.extra.is_mult and G.C.MULT or G.C.CHIPS 
            })
        end
        
        if context.joker_main then
            if card.ability.extra.is_mult then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- 74. Dimenso Paralela
SMODS.Joker({
    key = 'j_quantum_parallel_dimension',
    atlas = 'j_quantum_parallel_dimension',
    config = { extra = { x_mult = 2.5 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        -- Condition: Hand must have exactly 2 or 4 cards (Parallel)
        if context.joker_main then
            if context.scoring_hand and (#context.scoring_hand == 2 or #context.scoring_hand == 4) then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 75. Dobra Espacial
SMODS.Joker({
    key = 'j_quantum_spatial_fold',
    atlas = 'j_quantum_spatial_fold',
    config = { extra = { mult = 50 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        -- Libera +1 slot (adjacentes compartilham espao)
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit + 1
        end
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        -- Remove o slot extra
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit - 1
        end
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 76. Wormhole
SMODS.Joker({
    key = 'j_quantum_wormhole',
    atlas = 'j_quantum_wormhole',
    config = { extra = { x_mult = 2.5, chance = 4 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local normal_prob = G.GAME and G.GAME.probabilities and G.GAME.probabilities.normal or 1
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult, '' .. normal_prob, ( (card and card.ability and card.ability.extra) or self.config.extra ).chance } }
    end,
    
    calculate = function(self, card, context)
        -- Behavior: X2.5 Mult and chance to re-trigger hand cards
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.repetition and context.cardarea == G.play then
            if pseudorandom('wormhole') < G.GAME.probabilities.normal / card.ability.extra.chance then
                return {
                    message = 'Tunnel!',
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- 77. Tesseract
SMODS.Joker({
    key = 'j_quantum_tesseract',
    atlas = 'j_quantum_tesseract',
    config = { extra = { mult_per = 20 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_per } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            local unique_suits = 0
            
            if context.scoring_hand then
                for _, v in ipairs(context.scoring_hand) do
                    if not suits[v.base.suit] then
                        suits[v.base.suit] = true
                        unique_suits = unique_suits + 1
                    end
                end
            end
            
            local mult = unique_suits * card.ability.extra.mult_per
            
            if mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                    mult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 78. Klein Bottle
SMODS.Joker({
    key = 'j_quantum_klein_bottle',
    atlas = 'j_quantum_klein_bottle',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        -- Marca que a inverso est ativa
        if not G.GAME.odyssey_klein_bottle_active then
            G.GAME.odyssey_klein_bottle_active = (G.GAME.odyssey_klein_bottle_active or 0) + 1
            -- Inverte a ordem dos Jokers visualmente e logicamente
            if G.jokers and G.jokers.cards then
                local reversed = {}
                for i = #G.jokers.cards, 1, -1 do
                    table.insert(reversed, G.jokers.cards[i])
                end
                G.jokers.cards = reversed
                -- Atualiza visualmente as posies
                for i = 1, #G.jokers.cards do
                    G.jokers.cards[i].T.x = G.jokers.T.x + (i-1)*G.CARD_W*1.1
                end
            end
        end
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        -- Remove a inverso quando vendido/removido
        if G.GAME.odyssey_klein_bottle_active then
            G.GAME.odyssey_klein_bottle_active = (G.GAME.odyssey_klein_bottle_active or 0) - 1
            -- Desinverte a ordem dos Jokers (inverte novamente)
            if G.jokers and G.jokers.cards then
                local reversed = {}
                for i = #G.jokers.cards, 1, -1 do
                    table.insert(reversed, G.jokers.cards[i])
                end
                G.jokers.cards = reversed
                for i = 1, #G.jokers.cards do
                    G.jokers.cards[i].T.x = G.jokers.T.x + (i-1)*G.CARD_W*1.1
                end
            end
        end
    end,
    
    calculate = function(self, card, context)
        -- Condition: X3 Mult if this Joker is at either end of the Joker lineup
        if context.joker_main then
            local is_at_end = (G.jokers and G.jokers.cards and (G.jokers.cards[1] == card or G.jokers.cards[#G.jokers.cards] == card))
            if is_at_end then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- ============================================
-- QUANTUM - Legendary (Jokers 79-80)
-- ============================================

-- 79. Planos Superiores
SMODS.Joker({
    key = 'j_quantum_higher_planes',
    atlas = 'j_quantum_higher_planes',
    config = { extra = { x_mult = 3, odds = 2 } },
    rarity = 4,
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local normal_prob = G.GAME and G.GAME.probabilities and G.GAME.probabilities.normal or 1
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult, '' .. normal_prob, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('higher_planes') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            else
                -- The other state: +100 Mult
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { 100 } },
                    mult_mod = 100,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 80. Hiperespao
SMODS.Joker({
    key = 'j_quantum_hyperspace',
    atlas = 'j_quantum_hyperspace',
    config = { extra = { x_mult = 10 } },
    rarity = 4,
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- TEMPORAL - Common (Jokers 81-96)
-- ============================================

-- 81. Bifurcao
SMODS.Joker({
    key = 'j_temporal_bifurcation',
    config = { extra = { x_mult = 1.5 } },
    atlas = 'j_temporal_bifurcation',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 82. Sobreposio
SMODS.Joker({
    key = 'j_temporal_overlap',
    config = { extra = { mult = 20 } },
    atlas = 'j_temporal_overlap',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 83. Camadas
SMODS.Joker({
    key = 'j_temporal_layers',
    config = { extra = { x_mult = 1.5 } },
    atlas = 'j_temporal_layers',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 84. Planolndia
SMODS.Joker({
    key = 'j_temporal_flatland',
    config = { extra = { mult_per = 4 } },
    atlas = 'j_temporal_flatland',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local hand_cards = 0
        if G.hand and G.hand.cards then
            hand_cards = #G.hand.cards
        end
        return { vars = { hand_cards * card.ability.extra.mult_per, card.ability.extra.mult_per } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local hand_cards = 0
            if G.hand and G.hand.cards then
                hand_cards = #G.hand.cards
            end
            
            local mult = hand_cards * card.ability.extra.mult_per
            
            if mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                    mult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 85. Vazio Entre Mundos
SMODS.Joker({
    key = 'j_temporal_void_between_worlds',
    config = { extra = { mult_per = 10 } },
    atlas = 'j_temporal_void_between_worlds',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        if G and G.jokers and G.jokers.config and G.jokers.cards then
            local empty_slots = G.jokers.config.card_limit - #G.jokers.cards
            return { vars = { empty_slots * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per, ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per } }
        end
        return { vars = { 0, card.ability.extra.mult_per } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G and G.jokers and G.jokers.config and G.jokers.cards then
                local empty_slots = G.jokers.config.card_limit - #G.jokers.cards
                local total_mult = empty_slots * card.ability.extra.mult_per
                if total_mult > 0 then
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { total_mult } },
                        mult_mod = total_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    end
})

-- 86. Dimenso Extra
SMODS.Joker({
    key = 'j_temporal_extra_dimension',
    config = { extra = { mult = 10 } },
    atlas = 'j_temporal_extra_dimension',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    add_to_deck = function(self, card, from_debuff)
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit + 1
        end
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        if G.jokers then
            G.jokers.config.card_limit = G.jokers.config.card_limit - 1
        end
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 87. Multiverso
SMODS.Joker({
    key = 'j_temporal_multiverse',
    config = { extra = { x_mult = 1.5 } },
    atlas = 'j_temporal_multiverse',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 88. Fenda
SMODS.Joker({
    key = 'j_temporal_rift',
    config = { extra = { mult = 50 } },
    atlas = 'j_rift',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        return nil
    end
})

-- 89. Board Circular
SMODS.Joker({
    key = 'j_temporal_circular_board',
    config = { extra = { x_mult = 1.5 } },
    atlas = 'j_temporal_circular_board',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 90. Reino das Sombras
SMODS.Joker({
    key = 'j_temporal_shadow_realm',
    config = { extra = { mult_per = 5, shadow_cards = 0 } },
    atlas = 'j_temporal_shadow_realm',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.shadow_cards, extra.mult_per } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            card.ability.extra.shadow_cards = card.ability.extra.shadow_cards + 1
        end
        
        if context.joker_main and card.ability.extra.shadow_cards > 0 then
            local total_mult = card.ability.extra.shadow_cards * card.ability.extra.mult_per
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { total_mult } },
                mult_mod = total_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 91. Nexus Dimensional
SMODS.Joker({
    key = 'j_temporal_dimensional_nexus',
    config = { extra = { x_mult = 2 } },
    atlas = 'j_temporal_dimensional_nexus',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 92. Dimenso de Bolso
SMODS.Joker({
    key = 'j_temporal_pocket_dimension',
    config = { extra = { mult_per = 10, stored_cards = 0 } },
    atlas = 'j_temporal_pocket_dimension',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.stored_cards * extra.mult_per, extra.mult_per } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            card.ability.extra.stored_cards = card.ability.extra.stored_cards + 1
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = 'Guardado!', colour = G.C.PURPLE })
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.stored_cards = 0
        end
        
        if context.joker_main then
            local total_mult = card.ability.extra.stored_cards * card.ability.extra.mult_per
            if total_mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { total_mult } },
                    mult_mod = total_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 93. Mudana de Fase
SMODS.Joker({
    key = 'j_temporal_phase_shift',
    config = { extra = { x_mult = 2, active = true } },
    atlas = 'j_temporal_phase_shift',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.active and localize('k_active_ex') or localize('k_inactive_ex') } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and card.ability.extra.active then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.after and not context.blueprint then
            card.ability.extra.active = not card.ability.extra.active
            local status = card.ability.extra.active and 'Slido!' or 'Fantasma!'
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = status, colour = G.C.FILTER })
        end
    end
})

-- 94. Espao Negativo
SMODS.Joker({
    key = 'j_temporal_negative_space',
    config = { extra = { mult = 15 } },
    atlas = 'j_temporal_negative_space',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 95. Plano Astral
SMODS.Joker({
    key = 'j_temporal_astral_plane',
    config = { extra = { x_mult = 2 } },
    atlas = 'j_temporal_astral_plane',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 96. Convergncia
SMODS.Joker({
    key = 'j_temporal_convergence',
    config = { extra = { x_mult = 2.5 } },
    atlas = 'j_temporal_convergence',
    rarity = 1,
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- ============================================
-- TEMPORAL - Uncommon (Jokers 97-110)
-- ============================================

-- 97. Limbo
SMODS.Joker({
    key = 'j_temporal_limbo',
    config = { extra = { x_mult = 3, odds = 2 } },
    rarity = 2,
    atlas = 'j_temporal_limbo',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, (G.GAME.probabilities.normal or 1), extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('limbo') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = 'Limbo...',
                    colour = G.C.UI.TEXT_INACTIVE
                }
            end
        end
    end
})

-- 98. Subspace
SMODS.Joker({
    key = 'j_temporal_subspace',
    config = { extra = { mult = 40 } },
    rarity = 2,
    atlas = 'j_temporal_subspace',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 99. Realidade Fraturada
SMODS.Joker({
    key = 'j_temporal_fractured_reality',
    config = { extra = { min_x_mult = 1, max_x_mult = 5 } },
    rarity = 2,
    atlas = 'j_temporal_fractured_reality',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.min_x_mult, extra.max_x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local range = card.ability.extra.max_x_mult - card.ability.extra.min_x_mult
            local x_mult = (pseudorandom('realidade_fraturada') * range) + card.ability.extra.min_x_mult
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { x_mult } },
                Xmult_mod = x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 100. Omniverso
SMODS.Joker({
    key = 'j_temporal_omniverse',
    config = { extra = { x_mult_per = 0.1 } },
    rarity = 2,
    atlas = 'j_temporal_omniverse',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.GAME and G.GAME.hands then
            for k, v in pairs(G.GAME.hands) do
                if v.played > 0 then count = count + 1 end
            end
        end
        local current_x_mult = 1 + (count * card.ability.extra.x_mult_per)
        return { vars = { current_x_mult, card.ability.extra.x_mult_per, count } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.GAME and G.GAME.hands then
                for k, v in pairs(G.GAME.hands) do
                    if v.played > 0 then count = count + 1 end
                end
            end
            local total_x_mult = 1 + (count * card.ability.extra.x_mult_per)
            if total_x_mult > 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { total_x_mult } },
                    Xmult_mod = total_x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 101. Relgio Csmico
SMODS.Joker({
    key = 'j_temporal_cosmic_clock',
    config = { extra = { rounds = 0, req_rounds = 3, x_mult = 1, x_mult_gain = 0.5 } },
    rarity = 2,
    atlas = 'j_temporal_cosmic_clock',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.rounds, extra.x_mult, extra.req_rounds, extra.x_mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.rounds = card.ability.extra.rounds + 1
            if card.ability.extra.rounds >= card.ability.extra.req_rounds then
                card.ability.extra.rounds = 0
                card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 102. Eco Temporal
SMODS.Joker({
    key = 'j_temporal_time_echo',
    config = { extra = { mult_per = 3 } },
    rarity = 2,
    atlas = 'j_temporal_time_echo',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_per } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local unused_discards = G.GAME.current_round.discards_left or 0
            if unused_discards > 0 then
                local bonus = unused_discards * card.ability.extra.mult_per
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { bonus } },
                    mult_mod = bonus,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 103. Viajante Temporal 2
SMODS.Joker({
    key = 'j_temporal_traveler_2',
    config = { extra = { first_hand_mult = 0, first_hand_chips = 0, hands_played = 0 } },
    rarity = 2,
    atlas = 'j_temporal_traveler_2',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        return { vars = {} }
    end,
    
    calculate = function(self, card, context)
        -- Incrementa contador
        if context.before and not context.blueprint then
            card.ability.extra.hands_played = (card.ability.extra.hands_played or 0) + 1
        end
        
        -- Primeira mo: captura valores atuais (Base + Cartas)
        if context.joker_main and card.ability.extra.hands_played == 1 then
            card.ability.extra.first_hand_mult = (G.mult or 1)
            card.ability.extra.first_hand_chips = (G.hand_chips or 0)
        end
        
        -- ltima mo: repete o bnus
        if context.joker_main and G.GAME.current_round.hands_left == 0 then
            local bonus_mult = card.ability.extra.first_hand_mult
            local bonus_chips = card.ability.extra.first_hand_chips
            
            if bonus_mult > 0 or bonus_chips > 0 then
                return {
                    message = 'Eco!',
                    mult_mod = bonus_mult > 0 and bonus_mult or nil,
                    chip_mod = bonus_chips > 0 and bonus_chips or nil,
                    colour = G.C.PURPLE
                }
            end
        end
        
        -- Reset no fim da rodada
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.hands_played = 0
            card.ability.extra.first_hand_mult = 0
            card.ability.extra.first_hand_chips = 0
        end
    end
})

-- 104. Paradoxo
SMODS.Joker({
    key = 'j_temporal_paradox',
    config = { extra = { odds = 4 } },
    rarity = 2,
    atlas = 'j_temporal_paradox',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { G.GAME.probabilities.normal or 1, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            if pseudorandom('viajante_temporal') < G.GAME.probabilities.normal / card.ability.extra.odds then
                if pseudorandom('viajante_temporal_2') < 0.5 then
                    ease_hands_played(1)
                    card_eval_status_text(card, 'extra', nil, nil, nil, { message = '+1 Mo!', colour = G.C.BLUE })
                else
                    ease_discard(1)
                    card_eval_status_text(card, 'extra', nil, nil, nil, { message = '+1 Descarte!', colour = G.C.RED })
                end
            end
        end
    end
})

-- 105. Linha Temporal Alternativa
SMODS.Joker({
    key = 'j_temporal_alternate_timeline',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_temporal_alternate_timeline',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            if G.GAME.current_round.hands_left > 1 then
                ease_hands_played(-1)
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = '-1 Mo', colour = G.C.RED })
            end
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 106. Estase
SMODS.Joker({
    key = 'j_temporal_stasis',
    config = { extra = { odds = 10, bonus_next_round = false } },
    rarity = 2,
    atlas = 'j_temporal_stasis',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { G.GAME.probabilities.normal or 1, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.blind and G.GAME.blind.chips_left and G.GAME.blind.chips_left <= 0 then
                if pseudorandom('stasis') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    card.ability.extra.bonus_next_round = true
                    card_eval_status_text(card, 'extra', nil, nil, nil, { message = 'Estase!', colour = G.C.PURPLE })
                end
            end
        end
        
        if context.setting_blind and not context.blueprint then
            if card.ability.extra.bonus_next_round then
                card.ability.extra.bonus_next_round = false
                ease_hands_played(1)
                card_eval_status_text(card, 'extra', nil, nil, nil, { message = '+1 Mo!', colour = G.C.BLUE })
            end
        end
    end
})

-- 107. Momento Congelado
SMODS.Joker({
    key = 'j_temporal_frozen_moment',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_temporal_frozen_moment',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_hand then
            local ranks = {}
            for i = 1, #context.scoring_hand do
                local rank = context.scoring_hand[i].base.value
                ranks[rank] = (ranks[rank] or 0) + 1
            end
            
            for rank, count in pairs(ranks) do
                if count >= 2 then
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                        mult_mod = card.ability.extra.mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    end
})

-- 108. Futuro Incerto
SMODS.Joker({
    key = 'j_temporal_uncertain_future',
    config = { extra = { stored_mult = 0, stored_chips = 0, hands_played = 0, x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_temporal_uncertain_future',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.hands_played = (card.ability.extra.hands_played or 0) + 1
        end
        
        -- Primeira mo: armazena os valores
        if context.joker_main and card.ability.extra.hands_played == 1 then
            card.ability.extra.stored_mult = (G.mult or 1)
            card.ability.extra.stored_chips = (G.hand_chips or 0)
        end
        
        -- ltima mo: aplica XMult e bnus guardado
        if context.joker_main and G.GAME.current_round.hands_left == 0 then
            return {
                message = 'Futuro!',
                mult_mod = card.ability.extra.stored_mult > 0 and card.ability.extra.stored_mult or nil,
                chip_mod = card.ability.extra.stored_chips > 0 and card.ability.extra.stored_chips or nil,
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.PURPLE
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.hands_played = 0
            card.ability.extra.stored_mult = 0
            card.ability.extra.stored_chips = 0
        end
    end
})

-- 109. Cronmetro
SMODS.Joker({
    key = 'j_temporal_chronometer',
    config = { extra = { mult = 0, mult_gain = 2 } },
    rarity = 2,
    atlas = 'j_temporal_chronometer',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT,
                card = card
            }
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 110. Dilatao Temporal
SMODS.Joker({
    key = 'j_temporal_time_dilation',
    config = { extra = { x_mult = 1.5, last_hand = '', is_same = false } },
    rarity = 2,
    atlas = 'j_temporal_time_dilation',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and context.scoring_name then
            local current_hand = context.scoring_name
            card.ability.extra.is_same = (current_hand == card.ability.extra.last_hand)
            card.ability.extra.last_hand = current_hand
        end
        
        if context.joker_main and card.ability.extra.is_same then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- ============================================
-- TEMPORAL - Rare (Jokers 111-118)
-- ============================================

-- 111. Horizonte de Eventos Temporal
SMODS.Joker({
    key = 'j_temporal_event_horizon',
    config = { extra = { min = 5, max = 50 } },
    rarity = 3,
    atlas = 'j_temporal_event_horizon',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.min, extra.max } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local mult = pseudorandom('horizonte') * (card.ability.extra.max - card.ability.extra.min) + card.ability.extra.min
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                mult_mod = mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 112. Rewind Temporal
SMODS.Joker({
    key = 'j_temporal_rewind',
    config = { extra = { mult_per = 10 } },
    rarity = 3,
    atlas = 'j_temporal_rewind',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_per } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local hands_played = G.GAME.current_round.hands_played or 0
            local bonus = hands_played * card.ability.extra.mult_per
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { bonus } },
                mult_mod = bonus,
                colour = G.C.MULT
            }
        end
    end
})

-- 113. Repetio Temporal
SMODS.Joker({
    key = 'j_temporal_repetition',
    config = { extra = { dollars = 3, interval = 5, hands_count = 0 } },
    rarity = 3,
    atlas = 'j_temporal_repetition',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.dollars, extra.interval } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.hands_count = (card.ability.extra.hands_count or 0) + 1
            if card.ability.extra.hands_count >= card.ability.extra.interval then
                card.ability.extra.hands_count = 0
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = '$' .. card.ability.extra.dollars,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 114. Dj Vu Infinito
SMODS.Joker({
    key = 'j_temporal_infinite_deja_vu',
    config = { extra = { chips = 25 } },
    rarity = 3,
    atlas = 'j_temporal_infinite_deja_vu',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local discards = G.GAME.current_round.discards_left or 0
            local bonus = discards * card.ability.extra.chips
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { bonus } },
                chip_mod = bonus,
                colour = G.C.CHIPS
            }
        end
    end
})

-- 115. Futuro Promissor
SMODS.Joker({
    key = 'j_temporal_promising_future',
    config = { extra = { x_mult = 3, mult = 25, odds = 5 } },
    rarity = 3,
    atlas = 'j_temporal_promising_future',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.odds, extra.x_mult, extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('promising_future') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 116. Presente Eterno
SMODS.Joker({
    key = 'j_temporal_eternal_present',
    config = { extra = { x_mult = 1.5 } },
    rarity = 3,
    atlas = 'j_temporal_eternal_present',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local initial_discards = G.GAME.round_resets.discards or 0
            local current_discards = G.GAME.current_round.discards_left or 0
            if initial_discards == current_discards then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 117. Passado Perdido
SMODS.Joker({
    key = 'j_temporal_forgotten_past',
    config = { extra = { odds = 5 } },
    rarity = 3,
    atlas = 'j_temporal_forgotten_past',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { G.GAME.probabilities.normal or 1, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and context.game_over and not context.repetition and not context.other_card then
            if pseudorandom('forgotten_past') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize('k_saved_ex'),
                    saved = true,
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

-- 118. Crescimento Temporal
SMODS.Joker({
    key = 'j_temporal_growth',
    config = { extra = { mult = 0, mult_gain = 1 } },
    rarity = 3,
    atlas = 'j_temporal_growth',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT,
                card = card
            }
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- TEMPORAL - Legendary (Jokers 119-120)
-- ============================================

-- 119. Mo Dupla
SMODS.Joker({
    key = 'j_temporal_double_hand',
    config = { extra = { first_hand = true, triggered = false } },
    rarity = 4,
    atlas = 'j_temporal_double_hand',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        return { vars = {} }
    end,
    
    calculate = function(self, card, context)
        -- Reset flag at start of blind
        if context.setting_blind and not context.blueprint then
            card.ability.extra.first_hand = true
            card.ability.extra.triggered = false
        end
        
        -- Before playing hand: check if it's first hand
        if context.before and not context.blueprint and card.ability.extra.first_hand and not card.ability.extra.triggered then
            card.ability.extra.triggered = true
            card_eval_status_text(card, 'extra', nil, nil, nil, { 
                message = localize('k_again_ex'), 
                colour = G.C.PURPLE 
            })
        end
        
        -- During play: retrigger all played cards if first hand
        if context.repetition and context.cardarea == G.play then
            if card.ability.extra.first_hand and card.ability.extra.triggered then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = context.other_card
                }
            end
        end
        
        -- After hand: disable first_hand flag
        if context.after and not context.blueprint and card.ability.extra.first_hand then
            card.ability.extra.first_hand = false
        end
    end
})

-- 120. Loop Eterno
SMODS.Joker({
    key = 'j_temporal_eternal_loop',
    config = { extra = { x_mult = 3, count = 0, last_hand = '' } },
    rarity = 4,
    atlas = 'j_temporal_eternal_loop',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.played, extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and context.scoring_name then
            local hand_type = context.scoring_name
            if hand_type == card.ability.extra.last_hand then
                card.ability.extra.played = card.ability.extra.played + 1
            else
                card.ability.extra.played = 1
                card.ability.extra.last_hand = hand_type
            end
        end
        
        if context.joker_main and card.ability.extra.played >= 3 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- DIMENSIONS - Common (Jokers 121-136)
-- ============================================

-- 121. Legado
SMODS.Joker({
    key = 'j_dimensions_legacy',
    config = { extra = { mult_per_joker = 5, jokers_sold = 0 } },
    rarity = 1,
    atlas = 'j_dimensions_legacy',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.jokers_sold * extra.mult_per_joker } }

    
    end,
    
    calculate = function(self, card, context)
        if context.selling_card and not context.blueprint then
            card.ability.extra.jokers_sold = card.ability.extra.jokers_sold + 1
        end
        
        if context.joker_main then
            local mult = card.ability.extra.jokers_sold * card.ability.extra.mult_per_joker
            if mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                    mult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 122. Crescimento Infinito
SMODS.Joker({
    key = 'j_dimensions_infinite_growth',
    config = { extra = { x_mult = 1, x_mult_gain = 0.05 } },
    rarity = 1,
    atlas = 'j_dimensions_infinite_growth',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.x_mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.blind and G.GAME.blind.chips_left and G.GAME.blind.chips_left <= 0 then
                card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 123. Acumulao
SMODS.Joker({
    key = 'j_dimensions_accumulation',
    config = { extra = { mult = 0, cards_played = 0 } },
    rarity = 1,
    atlas = 'j_dimensions_accumulation',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play and not context.blueprint then
            card.ability.extra.cards_played = (card.ability.extra.cards_played or 0) + 1
            if card.ability.extra.cards_played >= 2 then
                card.ability.extra.cards_played = 0
                card.ability.extra.mult = card.ability.extra.mult + 1
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 124. ltima Hora
SMODS.Joker({
    key = 'j_dimensions_last_hour',
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    atlas = 'j_dimensions_last_hour',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_left == 0 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 125. Scaling Linear
SMODS.Joker({
    key = 'j_dimensions_linear_scaling',
    config = { extra = { x_mult_per_ante = 0.2 } },
    rarity = 1,
    atlas = 'j_dimensions_linear_scaling',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)
        local antes = G.GAME.round_resets.ante or 1
        local x_mult = 1 + (antes * ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_per_ante)
        return { vars = { x_mult } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local antes = G.GAME.round_resets.ante or 1
            local x_mult = 1 + (antes * card.ability.extra.x_mult_per_ante)
            
            if x_mult > 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { x_mult } },
                    Xmult_mod = x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 126. Momentum
SMODS.Joker({
    key = 'j_dimensions_momentum',
    config = { extra = { mult_gain = 3 } },
    rarity = 1,
    atlas = 'j_dimensions_momentum',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            card.ability.extra.temp_mult = (card.ability.extra.temp_mult or 0) + card.ability.extra.mult_gain
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.temp_mult } },
                mult = card.ability.extra.temp_mult,
                colour = G.C.MULT
            }
        end
        
        if context.after and not context.blueprint then
            card.ability.extra.temp_mult = 0
        end
    end
})

-- 127. Sacrifcio
SMODS.Joker({
    key = 'j_dimensions_sacrifice',
    config = { extra = { x_mult = 1, x_mult_gain = 1.5, odds = 10 } },
    rarity = 1,
    atlas = 'j_dimensions_sacrifice',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { G.GAME.probabilities.normal or 1, extra.odds, extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play and not context.blueprint then
            if pseudorandom('sacrifice') < G.GAME.probabilities.normal / card.ability.extra.odds then
                if not context.other_card.ability.eternal then
                    card.ability.extra.x_mult = card.ability.extra.x_mult * card.ability.extra.x_mult_gain
                    if not context.other_card.ability.eternal then context.other_card:start_dissolve() end
                    return {
                        message = 'Sacrificado!',
                        colour = G.C.PURPLE
                    }
                end
            end
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 128. Nmero da Sorte
SMODS.Joker({
    key = 'j_dimensions_lucky_number',
    config = { extra = { x_mult = 2, req_cards = 4 } },
    rarity = 1,
    atlas = 'j_dimensions_lucky_number',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.req_cards, extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_left == 0 then
            if #G.hand.cards == card.ability.extra.req_cards then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 129. Bonus Aleatrio
SMODS.Joker({
    key = 'j_dimensions_random_bonus',
    config = { extra = { money = 2 } },
    rarity = 1,
    atlas = 'j_dimensions_random_bonus',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            if pseudorandom('random_bonus') < 0.15 then
                if pseudorandom('random_bonus_2') < 0.5 then
                    ease_dollars(card.ability.extra.money)
                    return {
                        message = localize('$') .. card.ability.extra.money,
                        colour = G.C.MONEY
                    }
                else
                    ease_discard(1)
                    return {
                        message = '+1',
                        colour = G.C.RED
                    }
                end
            end
        end
    end
})

-- 130. Cumulativo
SMODS.Joker({
    key = 'j_dimensions_cumulative',
    config = { extra = { x_mult = 1, x_mult_gain = 0.1 } },
    rarity = 1,
    atlas = 'j_dimensions_cumulative',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.x_mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.blind and G.GAME.chips >= G.GAME.blind.chips then
                card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 131. Sequncia
SMODS.Joker({
    key = 'j_dimensions_streak',
    config = { extra = { mult_per_hand = 10, streak = 0 } },
    rarity = 1,
    atlas = 'j_dimensions_streak',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.streak * extra.mult_per_hand } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.streak = card.ability.extra.streak + 1
        end
        
        if context.discard and not context.blueprint then
            card.ability.extra.streak = 0
        end
        
        if context.joker_main and card.ability.extra.streak > 0 then
            local mult = card.ability.extra.streak * card.ability.extra.mult_per_hand
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                mult_mod = mult,
                colour = G.C.MULT
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.streak = 0
        end
    end
})

-- 132. Queima Rpida
SMODS.Joker({
    key = 'j_dimensions_fast_burn',
    config = { extra = { x_mult = 2, decay = 0.2 } },
    rarity = 1,
    atlas = 'j_dimensions_fast_burn',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.x_mult = math.max(1, card.ability.extra.x_mult - card.ability.extra.decay)
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 133. Tesouro Escondido
SMODS.Joker({
    key = 'j_dimensions_hidden_treasure',
    config = { extra = { money = 5, used_discard = false } },
    rarity = 1,
    atlas = 'j_dimensions_hidden_treasure',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            card.ability.extra.used_discard = true
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            if not card.ability.extra.used_discard then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
            card.ability.extra.used_discard = false
        end
    end
})

-- 134. Primeiras Trs
SMODS.Joker({
    key = 'j_dimensions_first_three',
    config = { extra = { mult = 15, hands_played = 0, max_hands = 3 } },
    rarity = 1,
    atlas = 'j_dimensions_first_three',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.max_hands, extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.hands_played = card.ability.extra.hands_played + 1
        end
        
        if context.joker_main and card.ability.extra.hands_played <= card.ability.extra.max_hands then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.hands_played = 0
        end
    end
})

-- 135. ltimas Trs
SMODS.Joker({
    key = 'j_dimensions_last_three',
    config = { extra = { mult = 20, max_hands = 3 } },
    rarity = 1,
    atlas = 'j_dimensions_last_three',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.max_hands, extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local hands_left = G.GAME.current_round.hands_left or 0
            if hands_left < card.ability.extra.max_hands then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 136. Melhor Jogada
SMODS.Joker({
    key = 'j_dimensions_best_play',
    config = { extra = { best_mult = 0, best_chips = 0 } },
    rarity = 1,
    atlas = 'j_dimensions_best_play',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,

    loc_vars = function(self, info_queue, card)


        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )


        return { vars = { extra.best_mult, extra.best_chips } }


    end,

    calculate = function(self, card, context)
        if context.after and not context.blueprint then
            local current_mult = G.mult or 1
            local current_chips = G.hand_chips or 0
            
            if current_mult > card.ability.extra.best_mult then
                card.ability.extra.best_mult = current_mult
            end
            if current_chips > card.ability.extra.best_chips then
                card.ability.extra.best_chips = current_chips
            end
        end

        if context.joker_main and G.GAME.current_round.hands_left == 0 then
            if card.ability.extra.best_mult > 0 or card.ability.extra.best_chips > 0 then
                return {
                    message = 'Melhor!',
                    mult_mod = card.ability.extra.best_mult,
                    chip_mod = card.ability.extra.best_chips,
                    colour = G.C.MULT
                }
            end
        end

        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.best_mult = 0
            card.ability.extra.best_chips = 0
        end
    end
})

-- ============================================
-- DIMENSIONS - Uncommon (Jokers 137-150)
-- ============================================

-- 137. Aprendizado
SMODS.Joker({
    key = 'j_dimensions_learning',
    config = { extra = { mult = 0, mult_gain = 5 } },
    rarity = 2,
    atlas = 'j_dimensions_learning',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local hands_played = G.GAME.current_round.hands_played or 0
            local won = G.GAME.blind and G.GAME.blind.chips_left and G.GAME.blind.chips_left <= 0
            
            if hands_played > 1 and won then
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 138. Memria
SMODS.Joker({
    key = 'j_dimensions_memory',
    config = { extra = { mult_per_card = 2, discarded_cards = {} } },
    rarity = 2,
    atlas = 'j_dimensions_memory',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_per_card } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            for i = 1, #context.full_hand do
                local id = context.full_hand[i].unique_val
                card.ability.extra.discarded_cards[id] = true
            end
        end
        
        if context.individual and context.cardarea == G.play then
            local id = context.other_card.unique_val
            if card.ability.extra.discarded_cards[id] then
                return {
                    mult = card.ability.extra.mult_per_card,
                    card = card
                }
            end
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.discarded_cards = {}
        end
    end
})

-- 139. Sorte Grande
SMODS.Joker({
    key = 'j_dimensions_big_luck',
    config = { extra = { odds = 4 } },
    rarity = 2,
    atlas = 'j_dimensions_big_luck',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { G.GAME.probabilities.normal or 1, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.after and not context.blueprint then
             if pseudorandom('big_luck') < G.GAME.probabilities.normal / card.ability.extra.odds then
                ease_hands_played(1)
                return {
                    message = 'Sorte!',
                    colour = G.C.BLUE
                }
             end
        end
    end
})

-- 140. Sinergia Temporal
SMODS.Joker({
    key = 'j_dimensions_temporal_synergy',
    config = { extra = { mult_per_joker = 3 } },
    rarity = 2,
    atlas = 'j_dimensions_temporal_synergy',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.jokers and G.jokers.cards then
            for i = 1, #G.jokers.cards do
                local key = G.jokers.cards[i].config.center.key
                if (string.find(key, 'temporal') or string.find(key, 'relogio') or 
                   string.find(key, 'tempo') or string.find(key, 'paradoxo') or
                   string.find(key, 'futuro') or string.find(key, 'passado') or
                   string.find(key, 'odyssey_j_temporal')) and G.jokers.cards[i] ~= card then
                    count = count + 1
                end
            end
        end
        return { vars = { card.ability.extra.mult_per_joker, count * card.ability.extra.mult_per_joker } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.jokers and G.jokers.cards then
                for i = 1, #G.jokers.cards do
                    local key = G.jokers.cards[i].config.center.key
                    if (string.find(key, 'temporal') or string.find(key, 'relogio') or 
                       string.find(key, 'tempo') or string.find(key, 'paradoxo') or
                       string.find(key, 'futuro') or string.find(key, 'passado') or
                       string.find(key, 'odyssey_j_temporal')) and G.jokers.cards[i] ~= card then
                        count = count + 1
                    end
                end
            end
            
            local mult = count * card.ability.extra.mult_per_joker
            if mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                    mult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 141. Estabilidade Suprema
SMODS.Joker({
    key = 'j_dimensions_ultimate_stability',
    config = { extra = { mult = 20, fixed_hands = 0, fixed_discards = 0 } },
    rarity = 3, -- Changed to Rare
    atlas = 'j_dimensions_ultimate_stability',
    pos = { x = 0, y = 0 },
    cost = 10,  -- Increased cost
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            card.ability.extra.fixed_hands = G.GAME.round_resets.hands
            card.ability.extra.fixed_discards = G.GAME.round_resets.discards
        end
        
        if context.before and not context.blueprint then
            -- Reset hands and discards to fixed values before playing/discarding
            G.GAME.current_round.hands_left = card.ability.extra.fixed_hands
            G.GAME.current_round.discards_left = card.ability.extra.fixed_discards
            
            card_eval_status_text(card, 'extra', nil, nil, nil, { message = 'Estvel!', colour = G.C.FILTER })
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 142. Catico
SMODS.Joker({
    key = 'j_dimensions_chaotic',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_dimensions_chaotic',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if pseudorandom('chaotic') < 0.5 then
                card.ability.extra.mult = card.ability.extra.mult * 2
                return {
                    message = 'Dobrou!',
                    colour = G.C.MULT,
                    card = card
                }
            else
                card.ability.extra.mult = 0
                return {
                    message = 'Zerou!',
                    colour = G.C.RED,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 143. Primeira Carta
SMODS.Joker({
    key = 'j_dimensions_first_card',
    config = { extra = { chips = 50, first_card = true } },
    rarity = 2,
    atlas = 'j_dimensions_first_card',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.first_card = true
        end
        
        if context.individual and context.cardarea == G.play and card.ability.extra.first_card then
            card.ability.extra.first_card = false
            return {
                chips = card.ability.extra.chips,
                card = card
            }
        end
    end
})

-- 144. ltima Carta
SMODS.Joker({
    key = 'j_dimensions_last_card',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_dimensions_last_card',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card == context.scoring_hand[#context.scoring_hand] then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 145. Duplo Processamento
SMODS.Joker({
    key = 'j_dimensions_double_processing',
    config = { extra = { money_loss = 2 } },
    rarity = 2,
    atlas = 'j_dimensions_double_processing',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.money_loss } }

    
    end,
    
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            return {
                message = localize('k_again_ex'),
                repetitions = 1,
                card = context.other_card
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            ease_dollars(-card.ability.extra.money_loss)
            return {
                message = '-$' .. card.ability.extra.money_loss,
                colour = G.C.RED
            }
        end
    end
})

-- 146. Comeo de Ante
SMODS.Joker({
    key = 'j_dimensions_ante_start',
    config = { extra = { x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_dimensions_ante_start',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.round_resets.blind_states.Small == 'Current' then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 147. Lutador de Chefes
SMODS.Joker({
    key = 'j_dimensions_boss_fighter',
    config = { extra = { x_mult = 2, mult = 15 } },
    rarity = 2,
    atlas = 'j_dimensions_boss_fighter',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.round_resets.blind_states.Boss == 'Current' then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 148. Observador de Blind
SMODS.Joker({
    key = 'j_dimensions_blind_watcher',
    config = { extra = { mult = 0, mult_gain = 10 } },
    rarity = 2,
    atlas = 'j_dimensions_blind_watcher',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT,
                card = card
            }
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 149. Ordem Reversa
SMODS.Joker({
    key = 'j_dimensions_reverse_order',
    config = { extra = { chips = 15 } },
    rarity = 2,
    atlas = 'j_dimensions_reverse_order',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            return {
                chips = card.ability.extra.chips,
                card = card
            }
        end
    end
})

-- 150. Sacrifcio Final
SMODS.Joker({
    key = 'j_dimensions_final_sacrifice',
    config = { extra = { x_mult = 1, x_mult_gain = 0.1 } },
    rarity = 2,
    atlas = 'j_dimensions_final_sacrifice',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, extra.x_mult_gain } }

    
    end,
    
    calculate = function(self, card, context)
        -- Quando qualquer Joker  vendido (no blueprint)
        if context.selling_card and not context.blueprint then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
            card_eval_status_text(card, 'extra', nil, nil, nil, { 
                message = localize('k_upgrade_ex'), 
                colour = G.C.MULT 
            })
        end
        
        -- Aplica multiplicador
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- DIMENSIONS - Rare (Jokers 151-158)
-- ============================================

-- 151. Fuso Dimensional
SMODS.Joker({
    key = 'j_dimensions_merge',
    config = { extra = {} },
    rarity = 3,
    atlas = 'j_dimensions_merge',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    -- Mecnica implementada em 03_vanilla_override.lua
    calculate = function(self, card, context)
        if context.joker_main then
            if context.scoring_name == 'Four of a Kind' then
                local has_two_pair = false
                -- Verificar se as cartas marcadas originalmente continham dois pares
                -- Mas o override j mudou o nome da mo para Four of a Kind.
            end
        end
    end
})

-- 152. Universo de Bolso
SMODS.Joker({
    key = 'j_dimensions_pocket_universe',
    config = { extra = {} },
    rarity = 3,
    atlas = 'j_dimensions_pocket_universe',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.selling_card and context.card.ability.set == 'Joker' then
            if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Planet', G.consumeables, nil, nil, nil, nil, nil, 'pocket_universe')
                        new_card:add_to_deck()
                        G.consumeables:emplace(new_card)
                        G.GAME.consumeable_buffer = 0
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_planet'),
                    colour = G.C.SECONDARY_SET.Planet,
                    card = card
                }
            end
        end
    end
})

-- 153. Senhor Dimensional
SMODS.Joker({
    key = 'j_dimensions_lord',
    config = { extra = { x_mult_per_slot = 0.5 } },
    rarity = 3,
    atlas = 'j_dimensions_lord',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local empty_slots = 0
        if G.jokers then
            empty_slots = G.jokers.config.card_limit - #G.jokers.cards
        end
        local current_x_mult = 1 + (empty_slots * card.ability.extra.x_mult_per_slot)
        return { vars = { current_x_mult } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local empty_slots = G.jokers.config.card_limit - #G.jokers.cards
            local x_mult = 1 + (empty_slots * card.ability.extra.x_mult_per_slot)
            if x_mult > 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { x_mult } },
                    Xmult_mod = x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 154. Ruptura da Realidade
SMODS.Joker({
    key = 'j_dimensions_reality_breach',
    config = { extra = { mult = 0, mult_gain = 1 } },
    rarity = 3,
    atlas = 'j_dimensions_reality_breach',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        -- Reset after Boss
        if context.end_of_round and G.GAME.blind.boss and not context.repetition and not context.other_card then
            card.ability.extra.mult = 0
            return {
                message = localize('k_reset'),
                colour = G.C.RED
            }
        end

        -- Destroy discarded cards
        if context.discard then
            if context.other_card then
                -- Trigger dissolve
                if not context.other_card.ability.eternal then context.other_card:start_dissolve() end
                
                -- Add Mult
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult_gain } },
                    colour = G.C.MULT,
                    card = card
                }
            end
        end

        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 155. Onipresente
SMODS.Joker({
    key = 'j_dimensions_omnipresent',
    config = { extra = {} },
    rarity = 3,
    atlas = 'j_dimensions_omnipresent',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            return {
                message = localize('k_again_ex'),
                repetitions = 1,
                card = context.other_card
            }
        end
    end
})

-- 156. Colapso Dimensional
SMODS.Joker({
    key = 'j_dimensions_collapse',
    config = { extra = { active = false, xmult = 3, current_ante = 0 } },
    rarity = 3,
    atlas = 'j_dimensions_collapse',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.active and "Sim" or "No" } }

    
    end,
    
    calculate = function(self, card, context)
        -- Reset if Ante changed
        if G.GAME.round_resets.ante > card.ability.extra.current_ante then
            card.ability.extra.current_ante = G.GAME.round_resets.ante
            card.ability.extra.active = false
        end

        -- Trigger on Boss Blind selection
        if context.setting_blind and not card.ability.extra.active then
            if G.GAME.blind.boss then
                local available_jokers = {}
                for i = 1, #G.jokers.cards do
                    if G.jokers.cards[i] ~= card and not G.jokers.cards[i].ability.eternal then
                        table.insert(available_jokers, G.jokers.cards[i])
                    end
                end
                
                if #available_jokers > 0 then
                    local victim = pseudorandom_element(available_jokers, pseudoseed('dimensions_collapse'))
                    victim:start_dissolve()
                    card.ability.extra.active = true
                    return {
                        message = localize('k_active_ex'),
                        colour = G.C.RED
                    }
                end
            end
        end

        if context.joker_main and card.ability.extra.active then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 157. Navegador do Multiverso
SMODS.Joker({
    key = 'j_dimensions_multiverse_navigator',
    config = { extra = {} },
    rarity = 3,
    atlas = 'j_dimensions_multiverse_navigator',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.before and context.scoring_name == 'Flush' then
            if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'multiverse_navigator')
                        new_card:add_to_deck()
                        G.consumeables:emplace(new_card)
                        G.GAME.consumeable_buffer = 0
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_tarot'),
                    colour = G.C.SECONDARY_SET.Tarot,
                    card = card
                }
            end
        end
    end
})

-- 158. Transcendncia Dimensional
SMODS.Joker({
    key = 'j_dimensions_transcendence',
    config = { extra = { joker_slots = 1, hand_size = 1 } },
    rarity = 3,
    atlas = 'j_dimensions_transcendence',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    add_to_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.joker_slots
        G.hand:change_size(-card.ability.extra.hand_size)
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.joker_slots
        G.hand:change_size(card.ability.extra.hand_size)
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- ============================================
-- DIMENSIONS - Legendary (Jokers 159-160)
-- ============================================

-- 159. Mestre do Espao
SMODS.Joker({
    key = 'j_dimensions_master_of_space',
    config = { extra = {} },
    rarity = 4,
    atlas = 'j_dimensions_master_of_space',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    -- Logic handled in overrides or context.before
    calculate = function(self, card, context)
        -- Placeholder for visual feedback
        if context.joker_main then
            return {
                message = localize('k_active_ex'),
                colour = G.C.PURPLE
            }
        end
    end
})

-- 160. Onidimensional
SMODS.Joker({
    key = 'j_dimensions_omnidimensional',
    config = { extra = { xmult = 5 } },
    rarity = 4,
    atlas = 'j_dimensions_omnidimensional',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    add_to_deck = function(self, card, from_debuff)
        ease_ante(-1)
    end,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                Xmult_mod = card.ability.extra.xmult,
                colour = G.C.MULT
            }
        end
    end
})


-- ============================================
-- CELESTIAL - Common (Jokers 161-176)
-- ============================================

-- 161. Estrela Cadente
SMODS.Joker({
    key = 'j_celestial_shooting_star',
    config = { extra = { mult = 4, mult_gain = 2 } },
    rarity = 1,
    atlas = 'j_celestial_shooting_star',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.using_consumeable and not context.blueprint then
            if context.consumeable.ability.set == 'Planet' then
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 162. Constelao
SMODS.Joker({
    key = 'j_celestial_constellation',
    config = { extra = { xmult = 1.5, req_faces = 3 } },
    rarity = 1,
    atlas = 'j_celestial_constellation',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult, extra.req_faces } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local faces = 0
            for _, v in ipairs(context.scoring_hand) do
                if v:is_face() then
                    faces = faces + 1
                end
            end
            
            if faces >= card.ability.extra.req_faces then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 163. Lua Nova
SMODS.Joker({
    key = 'j_celestial_new_moon',
    config = { extra = { odds = 4 } },
    rarity = 1,
    atlas = 'j_celestial_new_moon',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { G.GAME.probabilities.normal or 1, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card:is_face() then
                if pseudorandom('new_moon') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    return {
                        message = localize('k_again_ex'),
                        repetitions = 1,
                        card = context.other_card
                    }
                end
            end
        end
    end
})

-- 164. Sol Nascente
SMODS.Joker({
    key = 'j_celestial_rising_sun',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_celestial_rising_sun',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.current_round.hands_played == 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 165. Nebulosa
SMODS.Joker({
    key = 'j_celestial_nebula',
    config = { extra = {} },
    rarity = 1,
    atlas = 'j_celestial_nebula',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.before and context.scoring_name == 'High Card' then
            if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Planet', G.consumeables, nil, nil, nil, nil, nil, 'nebula')
                        new_card:add_to_deck()
                        G.consumeables:emplace(new_card)
                        G.GAME.consumeable_buffer = 0
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_planet'),
                    colour = G.C.SECONDARY_SET.Planet,
                    card = card
                }
            end
        end
    end
})

-- 166. Cometa
SMODS.Joker({
    key = 'j_celestial_comet',
    config = { extra = { chips_per_card = 10 } },
    rarity = 1,
    atlas = 'j_celestial_comet',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local deck_size = G.playing_cards and #G.playing_cards or 0
        return { vars = { deck_size * ( (card and card.ability and card.ability.extra) or self.config.extra ).chips_per_card } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local deck_size = G.playing_cards and #G.playing_cards or 0
            local chips = deck_size * card.ability.extra.chips_per_card
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { chips } },
                chip_mod = chips,
                colour = G.C.CHIPS
            }
        end
    end
})

-- 167. Asteroide
SMODS.Joker({
    key = 'j_celestial_asteroid',
    config = { extra = { base_chips = 50, penalty = 5, current_chips = 50 } },
    rarity = 1,
    atlas = 'j_celestial_asteroid',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.current_chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local cards_played = #context.full_hand
            card.ability.extra.current_chips = math.max(0, card.ability.extra.current_chips - (cards_played * card.ability.extra.penalty))
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.current_chips } },
                chip_mod = card.ability.extra.current_chips,
                colour = G.C.CHIPS
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current_chips = card.ability.extra.base_chips
        end
    end
})

-- 168. Pulsar
SMODS.Joker({
    key = 'j_celestial_pulsar',
    config = { extra = { mult = 10, mult_gain = 10, hands_counter = 0, req_hands = 3 } },
    rarity = 1,
    atlas = 'j_celestial_pulsar',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            card.ability.extra.hands_counter = card.ability.extra.hands_counter + 1
            if card.ability.extra.hands_counter >= card.ability.extra.req_hands then
                card.ability.extra.hands_counter = 0
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        
        if context.end_of_round and G.GAME.blind.boss and not context.repetition and not context.other_card then
            card.ability.extra.mult = 10
            card.ability.extra.hands_counter = 0
            return {
                message = localize('k_reset'),
                colour = G.C.RED
            }
        end
    end
})

-- 169. Quasar
SMODS.Joker({
    key = 'j_celestial_quasar',
    config = { extra = { base_chips = 40, chips_per_discard = 5, current_chips = 40 } },
    rarity = 1,
    atlas = 'j_celestial_quasar',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.current_chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            card.ability.extra.current_chips = card.ability.extra.current_chips + card.ability.extra.chips_per_discard
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.CHIPS,
                card = card
            }
        end
        
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.current_chips } },
                chip_mod = card.ability.extra.current_chips,
                colour = G.C.CHIPS
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current_chips = card.ability.extra.base_chips
        end
    end
})

-- 170. Supernova
SMODS.Joker({
    key = 'j_celestial_supernova',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_celestial_supernova',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.after and context.scoring_name == 'High Card' and not context.blueprint then
            card.ability.extra.x_mult = 1
            return {
                message = localize('k_reset'),
                colour = G.C.RED
            }
        end
    end
})

-- 171. Buraco de Minhoca (Comum)
SMODS.Joker({
    key = 'j_celestial_wormhole_common',
    config = { extra = { money = 1 } },
    rarity = 1,
    atlas = 'j_celestial_wormhole',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            if context.other_card:is_face() then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 172. Satlite
SMODS.Joker({
    key = 'j_celestial_satellite',
    config = { extra = { money_per_10 = 1, max_money = 5 } },
    rarity = 1,
    atlas = 'j_celestial_satellite',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.money_per_10, extra.max_money } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local bonus = math.min(card.ability.extra.max_money, math.floor(G.GAME.dollars / 10) * card.ability.extra.money_per_10)
            if bonus > 0 then
                ease_dollars(bonus)
                return {
                    message = localize('$') .. bonus,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 173. Eclipse
SMODS.Joker({
    key = 'j_celestial_eclipse',
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    atlas = 'j_celestial_eclipse',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local has_face = false
            for _, v in ipairs(context.scoring_hand) do
                if v:is_face() then
                    has_face = true
                    break
                end
            end
            
            if not has_face then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 174. Meteoro
SMODS.Joker({
    key = 'j_celestial_meteor',
    config = { extra = { base_chips = 40, chips_per_card = 4 } },
    rarity = 1,
    atlas = 'j_celestial_meteor',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.base_chips, extra.chips_per_card } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local held_cards = #G.hand.cards
            local chips = card.ability.extra.base_chips + (held_cards * card.ability.extra.chips_per_card)
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { chips } },
                chip_mod = chips,
                colour = G.C.CHIPS
            }
        end
    end
})

-- 175. Poeira Csmica
SMODS.Joker({
    key = 'j_celestial_cosmic_dust',
    config = { extra = { mult_per_card = 2 } },
    rarity = 1,
    atlas = 'j_celestial_cosmic_dust',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local deck_size = G.playing_cards and #G.playing_cards or 0
        local excess = math.max(0, deck_size - 52)
        return { vars = { excess * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_card } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local deck_size = G.playing_cards and #G.playing_cards or 0
            local excess = math.max(0, deck_size - 52)
            local mult = excess * card.ability.extra.mult_per_card
            if mult > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                    mult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 176. Radiao Estelar
SMODS.Joker({
    key = 'j_celestial_stellar_radiation',
    config = { extra = { chips = 5 } },
    rarity = 1,
    atlas = 'j_celestial_stellar_radiation',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            return {
                chips = card.ability.extra.chips,
                card = context.other_card
            }
        end
    end
})

-- ============================================
-- CELESTIAL - Uncommon (Jokers 177-190)
-- ============================================

-- 177. Alinhamento Planetrio
SMODS.Joker({
    key = 'j_celestial_planetary_alignment',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_celestial_planetary_alignment',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if #context.scoring_hand == 4 then
                local suits = {}
                for _, v in ipairs(context.scoring_hand) do
                    suits[v.base.suit] = true
                end
                
                local count = 0
                for _ in pairs(suits) do count = count + 1 end
                
                if count == 4 then
                    return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    end
})

-- 178. Chuva de Meteoros
SMODS.Joker({
    key = 'j_celestial_meteor_shower',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_celestial_meteor_shower',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card == context.scoring_hand[1] then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = context.other_card
                }
            end
        end
    end
})

-- 179. Tempestade Solar
SMODS.Joker({
    key = 'j_celestial_solar_storm',
    config = { extra = { mult = 0, mult_gain = 3 } },
    rarity = 2,
    atlas = 'j_celestial_solar_storm',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            if context.other_card:is_suit('Spades') then
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.mult = 0
        end
    end
})

-- 180. Anis de Saturno
SMODS.Joker({
    key = 'j_celestial_rings_of_saturn',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_celestial_rings_of_saturn',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:get_id() == 8 then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 181. Gravidade Zero
SMODS.Joker({
    key = 'j_celestial_zero_gravity',
    config = { extra = { x_mult = 3, odyssey_wraparound_straight = true } },
    rarity = 2,
    atlas = 'j_celestial_zero_gravity',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Straight" then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                x_mult = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 182. Campo Estelar
SMODS.Joker({
    key = 'j_celestial_stellar_field',
    config = { extra = { xmult = 2 } },
    rarity = 2,
    atlas = 'j_celestial_stellar_field',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.xmult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if #context.scoring_hand == 5 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } },
                    Xmult_mod = card.ability.extra.xmult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 183. Fuso Nuclear
SMODS.Joker({
    key = 'j_celestial_nuclear_fusion',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_celestial_nuclear_fusion',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.before and context.scoring_name == 'Pair' and not context.blueprint then
            local destroyed_cards = {}
            for _, v in ipairs(context.scoring_hand) do
                destroyed_cards[#destroyed_cards+1] = v
                v:start_dissolve()
            end
            
            if #destroyed_cards > 0 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Default', G.hand, nil, nil, nil, nil, 'm_odyssey_emerald', 'nuclear_fusion')
                        new_card:add_to_deck()
                        G.hand:emplace(new_card)
                        return true
                    end
                }))
                return {
                    message = localize('k_fusion'),
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 184. Vento Solar
SMODS.Joker({
    key = 'j_celestial_solar_wind',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_celestial_solar_wind',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card == context.scoring_hand[#context.scoring_hand] then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = context.other_card
                }
            end
        end
    end
})

-- 185. Mar Gravitacional
SMODS.Joker({
    key = 'j_celestial_gravitational_tide',
    config = { extra = { hand_size = 1, discards = 1 } },
    rarity = 2,
    atlas = 'j_celestial_gravitational_tide',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    add_to_deck = function(self, card, from_debuff)
        G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 186. Horizonte de Eventos
SMODS.Joker({
    key = 'j_celestial_event_horizon',
    config = { extra = { mult = 0, mult_gain = 3, destroyed_this_round = false } },
    rarity = 2,
    atlas = 'j_celestial_event_horizon',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.discard and not context.blueprint and not card.ability.extra.destroyed_this_round then
            if context.other_card == context.full_hand[1] then -- First card in discard selection
                card.ability.extra.destroyed_this_round = true
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
                if not context.other_card.ability.eternal then context.other_card:start_dissolve() end
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
        
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.destroyed_this_round = false
        end
    end
})

-- 187. Singularidade Estelar
SMODS.Joker({
    key = 'j_celestial_stellar_singularity',
    config = { extra = { x_mult_per_slot = 0.2 } },
    rarity = 2,
    atlas = 'j_celestial_stellar_singularity',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)
        local empty_slots = (G.jokers and G.jokers.config and G.jokers.cards) and math.max(0, G.jokers.config.card_limit - #G.jokers.cards) or 0
        local total_x_mult = 1 + (empty_slots * ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_per_slot)
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_per_slot, empty_slots, total_x_mult } }
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local empty_slots = math.max(0, G.jokers.config.card_limit - #G.jokers.cards)
            local total_x_mult = 1 + (empty_slots * card.ability.extra.x_mult_per_slot)
            if total_x_mult > 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { total_x_mult } },
                    Xmult_mod = total_x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 188. Nebulosa Planetria
SMODS.Joker({
    key = 'j_celestial_planetary_nebula',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_celestial_planetary_nebula',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.end_of_round and G.GAME.blind.boss and not context.repetition and not context.other_card then
            if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Planet', G.consumeables, nil, nil, nil, nil, nil, 'planetary_nebula')
                        new_card:add_to_deck()
                        G.consumeables:emplace(new_card)
                        G.GAME.consumeable_buffer = 0
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_planet'),
                    colour = G.C.SECONDARY_SET.Planet,
                    card = card
                }
            end
        end
    end
})

-- 189. Proto-estrela
SMODS.Joker({
    key = 'j_celestial_protostar',
    config = { extra = { x_mult = 1, x_mult_gain = 0.1 } },
    rarity = 2,
    atlas = 'j_celestial_protostar',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.x_mult_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT,
                card = card
            }
        end
        
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 190. An Branca
SMODS.Joker({
    key = 'j_celestial_white_dwarf',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_celestial_white_dwarf',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played == 0 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- ============================================
-- CELESTIAL - Rare (Jokers 191-198)
-- ============================================

-- 191. Big Bang
SMODS.Joker({
    key = 'j_celestial_big_bang',
    rarity = 3,
    atlas = 'j_celestial_big_bang',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = false,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.selling_self then
            -- Destroy all other jokers
            local jokers_to_destroy = {}
            for _, v in ipairs(G.jokers.cards) do
                if v ~= card then
                    jokers_to_destroy[#jokers_to_destroy+1] = v
                end
            end
            
            for _, v in ipairs(jokers_to_destroy) do
                v:start_dissolve()
            end
            
            -- Create 5 random common jokers
            G.E_MANAGER:add_event(Event({
                func = function()
                    for i = 1, 5 do
                        local card = create_card('Joker', G.jokers, nil, 0, nil, nil, nil, 'celestial_big_bang')
                        card:add_to_deck()
                        G.jokers:emplace(card)
                    end
                    return true
                end
            }))
            return {
                message = localize('k_big_bang'),
                colour = G.C.RED
            }
        end
    end
})

-- 192. Buraco Negro Supermassivo
SMODS.Joker({
    key = 'j_celestial_supermassive_black_hole',
    config = { extra = { x_mult = 4 } },
    rarity = 3,
    atlas = 'j_celestial_supermassive_black_hole',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.after and not context.blueprint then
            if #G.hand.cards > 0 then
                local random_card = pseudorandom_element(G.hand.cards, pseudoseed('celestial_supermassive'))
                if random_card then
                    if not random_card.ability.eternal then random_card:start_dissolve() end
                    return {
                        message = localize('k_destroyed'),
                        colour = G.C.RED,
                        card = card
                    }
                end
            end
        end
    end
})

-- 193. Exploso de Raios Gama
SMODS.Joker({
    key = 'j_celestial_gamma_ray_burst',
    config = { extra = { x_mult = 10 } },
    rarity = 3,
    atlas = 'j_celestial_gamma_ray_burst',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = false,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.after and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                func = function()
                    if not card.ability.eternal then card:start_dissolve() end
                    return true
                end
            }))
            return {
                message = localize('k_destroyed'),
                colour = G.C.RED
            }
        end
    end
})

-- 194. Matria Escura
SMODS.Joker({
    key = 'j_celestial_dark_matter',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_celestial_dark_matter',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.current_round.discards_left == 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 195. Energia Escura
SMODS.Joker({
    key = 'j_celestial_dark_energy',
    rarity = 3,
    atlas = 'j_celestial_dark_energy',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    add_to_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit + 1
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 196. Inflao Csmica
SMODS.Joker({
    key = 'j_celestial_cosmic_inflation',
    config = { extra = { max_gain = 50 } },
    rarity = 3,
    atlas = 'j_celestial_cosmic_inflation',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local gain = math.min(G.GAME.dollars, card.ability.extra.max_gain)
            if gain > 0 then
                ease_dollars(gain)
                return {
                    message = localize('$') .. gain,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 197. Falso Vcuo
SMODS.Joker({
    key = 'j_celestial_false_vacuum',
    config = { extra = { x_mult = 5, odds = 20 } },
    rarity = 3,
    atlas = 'j_celestial_false_vacuum',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.end_of_round and not context.repetition and not context.other_card then
            if pseudorandom('celestial_false_vacuum') < G.GAME.probabilities.normal / card.ability.extra.odds then
                ease_dollars(-G.GAME.dollars)
                return {
                    message = localize('k_reset'),
                    colour = G.C.RED,
                    card = card
                }
            end
        end
    end
})


-- 198. Esfera de Dyson
SMODS.Joker({
    key = 'j_celestial_dyson_sphere',
    rarity = 3,
    atlas = 'j_celestial_dyson_sphere',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    
    add_to_deck = function(self, card, from_debuff)
        G.GAME.interest_cap = 100
    end,
    
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.interest_cap = 25
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- ============================================
-- CELESTIAL - Legendary (Jokers 199-200)
-- ============================================

-- 199. Gerador de Universos
SMODS.Joker({
    key = 'j_celestial_universe_generator',
    rarity = 4,
    atlas = 'j_celestial_universe_generator',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = false,
    perishable_compat = true,
    
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                func = function()
                    local legendary = create_card('Joker', G.jokers, true, 4, nil, nil, nil, 'celestial_universe_generator')
                    legendary:add_to_deck()
                    G.jokers:emplace(legendary)
                    if not card.ability.eternal then card:start_dissolve() end
                    return true
                end
            }))
            return {
                message = localize('k_universe'),
                colour = G.C.LEGENDARY
            }
        end
    end
})

-- 200. Entidade Csmica
SMODS.Joker({
    key = 'j_celestial_cosmic_entity',
    config = { extra = { x_mult = 4 } },
    rarity = 4,
    atlas = 'j_celestial_cosmic_entity',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        
        if context.repetition and context.cardarea == G.play then
            return {
                message = localize('k_again_ex'),
                repetitions = 1,
                card = context.other_card
            }
        end
    end
})


-- ============================================
-- CHAOS - Common (Jokers 201-216)
-- ============================================

-- 201. Dado Viciado (Loaded Die)
SMODS.Joker({
    key = 'j_chaos_loaded_die',
    config = { extra = { mult = 30, odds = 6 } },
    rarity = 1,
    atlas = 'j_chaos_loaded_die',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('j_chaos_loaded_die') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 202. Moeda da Sorte (Lucky Coin)
SMODS.Joker({
    key = 'j_chaos_lucky_coin',
    config = { extra = { mult = 15, odds = 2 } },
    rarity = 1,
    atlas = 'j_chaos_lucky_coin',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('j_chaos_lucky_coin') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 203. Roleta (Roulette)
SMODS.Joker({
    key = 'j_chaos_roulette',
    config = { extra = { x_mult = 4, odds = 20 } },
    rarity = 1,
    atlas = 'j_chaos_roulette',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('j_chaos_roulette') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 204. Imprevisvel (Unpredictable)
SMODS.Joker({
    key = 'j_chaos_unpredictable',
    config = { extra = { max_mult = 20 } },
    rarity = 1,
    atlas = 'j_chaos_unpredictable',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.max_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local rand_mult = pseudorandom('j_chaos_unpredictable') * card.ability.extra.max_mult
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { math.floor(rand_mult) } },
                mult_mod = rand_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 205. Caos Controlado (Controlled Chaos)
SMODS.Joker({
    key = 'j_chaos_controlled_chaos',
    config = { extra = { mult = 10, chips = 50 } },
    rarity = 1,
    atlas = 'j_chaos_controlled_chaos',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local is_red = false
            for _, c in ipairs(context.scoring_hand) do
                if c:is_suit('Hearts') or c:is_suit('Diamonds') then
                    is_red = true
                    break
                end
            end

            if is_red then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 206. Entropia Menor (Minor Entropy)
SMODS.Joker({
    key = 'j_chaos_minor_entropy',
    config = { extra = { mult = 4 } },
    rarity = 1,
    atlas = 'j_chaos_minor_entropy',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local odd_count = 0
            for _, c in ipairs(G.hand.cards) do
                if not c.debuff and (c:get_id() == 14 or c:get_id() == 3 or c:get_id() == 5 or c:get_id() == 7 or c:get_id() == 9) then
                    odd_count = odd_count + 1
                end
            end
            if odd_count > 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult * odd_count } },
                    mult_mod = card.ability.extra.mult * odd_count,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 207. Embaralhador (Shuffler)
SMODS.Joker({
    key = 'j_chaos_shuffler',
    config = { extra = { chips = 50 } },
    rarity = 1,
    atlas = 'j_chaos_shuffler',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                chip_mod = card.ability.extra.chips,
                colour = G.C.CHIPS
            }
        end
        if context.after and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.1,
                func = function()
                    G.hand:shuffle('j_chaos_shuffler')
                    return true
                end
            }))
            return {
                message = localize('k_shuffled'),
                colour = G.C.ORANGE
            }
        end
    end
})

-- 208. Coringa Selvagem (Wild Joker)
SMODS.Joker({
    key = 'j_chaos_wild_joker',
    config = { extra = { mult = 10, odds = 5 } },
    rarity = 1,
    atlas = 'j_chaos_wild_joker',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        if context.before and not context.blueprint then
            for _, c in ipairs(context.scoring_hand) do
                if pseudorandom('j_chaos_wild_joker') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    local suits = {'Spades', 'Hearts', 'Clubs', 'Diamonds'}
                    local new_suit = suits[pseudorandom('j_chaos_wild_joker_suit', 1, 4)]
                    c:change_suit(new_suit)
                    card_eval_status_text(c, 'extra', nil, nil, nil, {message = localize(new_suit, 'suits_singular'), colour = G.C.SUITS[new_suit]})
                end
            end
        end
    end
})

-- 209. Sorte de Principiante (Beginner's Luck)
SMODS.Joker({
    key = 'j_chaos_beginners_luck',
    config = { extra = { x_mult = 2, odds = 3 } },
    rarity = 1,
    atlas = 'j_chaos_beginners_luck',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played == 0 then
            if pseudorandom('j_chaos_beginners_luck') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize('k_nope_ex'),
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 210. Aposta Alta (High Stakes)
SMODS.Joker({
    key = 'j_chaos_high_stakes',
    config = { extra = { mult = 20, dollars = 1 } },
    rarity = 1,
    atlas = 'j_chaos_high_stakes',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, extra.dollars } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            if not context.blueprint then
                ease_dollars(-card.ability.extra.dollars)
            end
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 211. Risco Calculado (Calculated Risk)
SMODS.Joker({
    key = 'j_chaos_calculated_risk',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_chaos_calculated_risk',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_left == 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 212. Frenesi (Frenzy)
SMODS.Joker({
    key = 'j_chaos_frenzy',
    config = { extra = { mult_gain = 5, current_mult = 0 } },
    rarity = 1,
    atlas = 'j_chaos_frenzy',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult_gain, extra.current_mult } }

    
    end,
    
    calculate = function(self, card, context)
        if context.cardarea == G.jokers and context.before and not context.blueprint then
            card.ability.extra.current_mult = card.ability.extra.current_mult + card.ability.extra.mult_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.current_mult } },
                mult_mod = card.ability.extra.current_mult,
                colour = G.C.MULT
            }
        end
        if context.discard and not context.blueprint and not context.other_card then
            card.ability.extra.current_mult = 0
            return {
                message = localize('k_reset'),
                colour = G.C.RED
            }
        end
        if context.end_of_round and not context.blueprint and not context.repetition and not context.other_card then
            card.ability.extra.current_mult = 0
        end
    end
})

-- 213. Disperso (Scatter)
SMODS.Joker({
    key = 'j_chaos_scatter',
    config = { extra = { max_chips = 10 } },
    rarity = 1,
    atlas = 'j_chaos_scatter',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.max_chips } }

    
    end,
    
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local rand_chips = pseudorandom('j_chaos_scatter') * card.ability.extra.max_chips
            return {
                chips = rand_chips,
                card = context.other_card
            }
        end
    end
})

-- 214. Rudo Branco (White Noise)
SMODS.Joker({
    key = 'j_chaos_white_noise',
    config = { extra = { mult = 10, odds = 10 } },
    rarity = 1,
    atlas = 'j_chaos_white_noise',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        if context.before and not context.blueprint then
            for _, c in ipairs(context.scoring_hand) do
                if pseudorandom('j_chaos_white_noise') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    c:set_ability(G.P_CENTERS.m_odyssey_emerald)
                    card_eval_status_text(c, 'extra', nil, nil, nil, {message = localize('k_stone'), colour = G.C.GREY})
                end
            end
        end
    end
})

-- 215. Turbulncia (Turbulence)
SMODS.Joker({
    key = 'j_chaos_turbulence',
    config = { extra = { chips = 40, penalty = 10 } },
    rarity = 1,
    atlas = 'j_chaos_turbulence',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.chips, extra.penalty } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            local chips = card.ability.extra.chips
            if #context.scoring_hand == 5 then
                chips = chips - card.ability.extra.penalty
            end
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { chips } },
                chip_mod = chips,
                colour = G.C.CHIPS
            }
        end
    end
})

-- 216. Instvel (Unstable)
SMODS.Joker({
    key = 'j_chaos_unstable',
    config = { extra = { x_mult = 1.5, odds = 10 } },
    rarity = 1,
    atlas = 'j_chaos_unstable',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    
    loc_vars = function(self, info_queue, card)

    
        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

    
        return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds } }

    
    end,
    
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        if context.end_of_round and not context.blueprint and not context.repetition and not context.other_card then
            if pseudorandom('j_chaos_unstable') < G.GAME.probabilities.normal / card.ability.extra.odds then
                if not card.ability.eternal then
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            card:start_dissolve()
                            return true
                        end
                    }))
                    return {
                        message = localize('k_destroyed'),
                        colour = G.C.RED
                    }
                end
            end
        end
    end
})

-- 217. Chaos Theory
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_theory',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_chaos_theory',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            local suit_count = 0
            for i = 1, #context.scoring_hand do
                local s = (context.scoring_hand[i]:get_id() > 0 or context.scoring_hand[i].config.center.key == 'j_odyssey_j_chaos_butterfly_effect') and context.scoring_hand[i].base.suit or 'None'
                if s ~= 'None' and not suits[s] then
                    suits[s] = true
                    suit_count = suit_count + 1
                end
            end
            
            if suit_count >= 4 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 218. Butterfly Effect
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_butterfly_effect',
    config = {},
    rarity = 2,
    atlas = 'j_chaos_butterfly_effect',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local first_card = context.scoring_hand[1]
            if first_card then
                local target_suit = first_card.base.suit
                card.ability.extra_original_suits = {}
                for i = 2, #context.scoring_hand do
                   local c = context.scoring_hand[i]
                   card.ability.extra_original_suits[c] = c.base.suit
                   c:change_suit(target_suit)
                end
                return {
                    message = localize('k_active_ex'),
                    card = card
                }
            end
        end
        if context.after and not context.blueprint and card.ability.extra_original_suits then
            for c, original_suit in pairs(card.ability.extra_original_suits) do
                c:change_suit(original_suit)
            end
            card.ability.extra_original_suits = nil
        end
    end
})

-- 219. Pandemonium
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_pandemonium',
    config = { extra = { repetitions = 3 } },
    rarity = 2,
    atlas = 'j_chaos_pandemonium',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
           if #G.hand.cards > 0 then
               local rng = pseudorandom('j_chaos_pandemonium')
               local idx = math.ceil(rng * #G.hand.cards)
               card.ability.extra.target_card = G.hand.cards[idx]
           else
               card.ability.extra.target_card = nil
           end
        end
        
        if context.repetition and context.cardarea == G.hand then
             if card.ability.extra.target_card and context.other_card == card.ability.extra.target_card then
                 return {
                     message = localize('k_again_ex'),
                     repetitions = card.ability.extra.repetitions,
                     card = context.other_card
                 }
             end
        end
    end
})

-- 220. Discord
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_discord',
    config = { extra = { mult = 30 } },
    rarity = 2,
    atlas = 'j_chaos_discord',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local played_hand = context.scoring_name
            local max_played = 0
            local most_played_hand = ''
            
            for k, v in pairs(G.GAME.hands) do
                if v.played > max_played then
                    max_played = v.played
                    most_played_hand = k
                end
            end
            
            if played_hand ~= most_played_hand then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 221. Anarchy
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_anarchy',
    config = { extra = { min = 0.5, max = 3 } },
    rarity = 2,
    atlas = 'j_chaos_anarchy',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.min, extra.max } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local x_mult = card.ability.extra.min + (pseudorandom('j_chaos_anarchy') * (card.ability.extra.max - card.ability.extra.min))
            -- Round to 1 decimal like in DOC
            x_mult = math.floor(x_mult * 10) / 10
             return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { x_mult } },
                Xmult_mod = x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 222. Mana Vortex
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_mana_vortex',
    loc_txt = {
        name = "Mana Vortex",
        text = {
            "Creates a random {C:tarot}Tarot{} card,",
            "but destroys a random {C:attention}Common Joker{}",
            "(if any) at end of round"
        }
    },
    config = {},
    rarity = 2,
    atlas = 'j_chaos_mana_vortex',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            -- Create Tarot
            if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local tarot = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'j_chaos_mana_vortex')
                        tarot:add_to_deck()
                        G.consumeables:emplace(tarot)
                        return true
                    end
                }))
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_plus_tarot'), colour = G.C.PURPLE})
            end
            
            -- Destroy Common Joker
            local commons = {}
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] ~= card and G.jokers.cards[i].config.center.rarity == 1 and not G.jokers.cards[i].ability.eternal then
                    commons[#commons + 1] = G.jokers.cards[i]
                end
            end
            
            if #commons > 0 then
                local victim = pseudorandom_element(commons, pseudorandom('j_chaos_mana_vortex'))
                G.E_MANAGER:add_event(Event({
                    func = function()
                        victim:start_dissolve()
                        return true
                    end
                }))
                 card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_destroyed'), colour = G.C.RED})
            end
        end
    end
})

-- 223. Transmutation
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_transmutation',
    loc_txt = {
        name = "Transmutation",
        text = {
            "When sold, transforms into",
            "a random {C:attention}Uncommon Joker{}"
        }
    },
    config = {},
    rarity = 2,
    atlas = 'j_chaos_transmutation',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = false,
    eternal_compat = false,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.selling_self then
             G.E_MANAGER:add_event(Event({
                func = function()
                    local joker = create_card('Joker', G.jokers, nil, 0.9, nil, nil, nil, 'j_chaos_transmutation')
                    joker:add_to_deck()
                    G.jokers:emplace(joker)
                    joker:start_materialize()
                    return true
                end
            }))
             return {
                message = localize('k_transmuted'),
                colour = G.C.PURPLE
            }     
        end
    end
})

-- 224. Unstable Alchemy
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_unstable_alchemy',
    loc_txt = {
        name = "Unstable Alchemy",
        text = {
            "Earn {C:money}$#1#{} when playing a {C:attention}Flush{}.",
            "{C:green}#2# in #3#{} chance to transform",
            "the Flush into {C:diamonds}Diamonds{}"
        }
    },
    config = { extra = { dollars = 4, odds = 4 } },
    rarity = 2,
    atlas = 'j_chaos_unstable_alchemy',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars, G.GAME.probabilities.normal, extra.odds } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'Flush' then
            G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + card.ability.extra.dollars
            G.E_MANAGER:add_event(Event({func = function() G.GAME.dollars = G.GAME.dollars + card.ability.extra.dollars; G.GAME.dollar_buffer = G.GAME.dollar_buffer - card.ability.extra.dollars; return true end}))
            
            if pseudorandom('j_chaos_unstable_alchemy') < G.GAME.probabilities.normal / card.ability.extra.odds then
                 for i = 1, #context.scoring_hand do
                    local c = context.scoring_hand[i]
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            c:change_suit('Diamonds')
                            c:juice_up()
                            return true
                        end
                    }))
                 end
                 return {
                    message = localize('k_alchemy'), 
                    colour = G.C.DIAMONDS
                }
            else
                 return {
                    message = localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 225. Chain Reaction
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_chain_reaction',
    loc_txt = {
        name = "Chain Reaction",
        text = {
            "{C:mult}+#1#{} Mult for each time a",
            "Joker ability activated this hand"
        }
    },
    config = { extra = { mult_per_trigger = 5 } },
    rarity = 2,
    atlas = 'j_chaos_chain_reaction',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult_per_trigger } }

    end,
    calculate = function(self, card, context)
        -- Counting triggers is hard, so we estimate based on jokers count if we can't get official count.
        -- But for now, we'll use a safer proxy: +5 Mult for each Joker you own.
        -- Actually, let's use the intended mechanic if possible.
        if context.joker_main then
            local count = #G.jokers.cards
            -- Simplified to +5 per Joker for now to avoid crashes with non-existent global counters
            local mult = count * card.ability.extra.mult_per_trigger
             return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                mult_mod = mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 226. Will-o'-the-Wisp
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_will_o_the_wisp',
    loc_txt = {
        name = "Will-o'-the-Wisp",
        text = {
            "Create a {C:dark_edition}Negative{} copy",
            "of a random consumable",
            "when you defeat a {C:attention}Boss Blind{}"
        }
    },
    config = {},
    rarity = 2,
    atlas = 'j_chaos_will_o_the_wisp',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.blind.boss then
                 local card_type = pseudorandom_element({'Tarot', 'Planet', 'Spectral'}, pseudorandom('j_chaos_will_o_the_wisp'))
                 G.E_MANAGER:add_event(Event({
                    func = function()
                        local consum = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, 'j_chaos_will_o_the_wisp')
                        consum:set_edition('e_negative', true)
                        consum:add_to_deck()
                        G.consumeables:emplace(consum)
                        return true
                    end
                }))
                 return {
                    message = localize('k_wisp'),
                    colour = G.C.DARK_EDITION
                 }
            end
        end
    end
})

-- 227. Pandora's Box
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_pandoras_box',
    loc_txt = {
        name = "Pandora's Box",
        text = {
            "When bought, gain {C:money}$#1#{}.",
            "Sets your Mult to {C:attention}0{}",
            "on the next hand played"
        }
    },
    config = { extra = { money = 20 } },
    rarity = 2,
    atlas = 'j_chaos_pandoras_box',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = false,
    eternal_compat = false,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.buying_card and context.card == card then
            G.GAME.dollars = G.GAME.dollars + card.ability.extra.money
             card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('$')..card.ability.extra.money, colour = G.C.MONEY})
             card.ability.extra.active_debuff = true
        end
        
        if context.joker_main and card.ability.extra.active_debuff then
            card.ability.extra.active_debuff = false
            return {
                message = localize('k_pandora'),
                mult_mod = -100000,
                Xmult_mod = 0
            }
        end
    end
})

-- 228. Bad Omen
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_bad_omen',
    config = { extra = { x_mult = 3, odds = 4, severe_x_mult = 0.5 } },
    rarity = 2,
    atlas = 'j_chaos_bad_omen',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds, extra.severe_x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('j_chaos_bad_omen') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.severe_x_mult } },
                    Xmult_mod = card.ability.extra.severe_x_mult,
                    colour = G.C.RED
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 229. Leap of Faith
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_leap_of_faith',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_chaos_leap_of_faith',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.current_round.hands_left == 0 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})


-- 230. Dissonance
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_dissonance',
    loc_txt = {
        name = "Dissonance",
        text = {
            "{C:chips}+#1#{} Chips if played cards",
            "do not form any poker hand",
            "({C:attention}High Card{})"
        }
    },
    config = { extra = { chips = 100 } },
    rarity = 2,
    atlas = 'j_chaos_dissonance',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if context.scoring_name == 'High Card' then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- 231. Agent of Chaos
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_agent_of_chaos',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_chaos_agent_of_chaos',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        if context.before and not context.blueprint then
            if #G.hand.cards > 0 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local victim = pseudorandom_element(G.hand.cards, pseudorandom('j_chaos_agent'))
                        G.hand:add_to_highlighted(victim)
                        return true
                    end
                }))
            end
        end
    end
})

-- 232. Improbability Drive
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_improbability_drive',
    config = { extra = { odds = 100, dollars = 100 } },
    rarity = 3,
    atlas = 'j_chaos_improbability_drive',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.odds } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('j_chaos_improbability_drive') < G.GAME.probabilities.normal / card.ability.extra.odds then
                G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + card.ability.extra.dollars
                G.E_MANAGER:add_event(Event({func = function() G.GAME.dollars = G.GAME.dollars + card.ability.extra.dollars; G.GAME.dollar_buffer = G.GAME.dollar_buffer - card.ability.extra.dollars; return true end}))
                return {
                    message = localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 233. Chance Nexus
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_chance_nexus',
    loc_txt = {
        name = "Chance Nexus",
        text = {
            "Increases probabilities list in",
            "other Jokers by {C:attention}25%{}",
            "{C:inactive}(e.g. 1 in 4 becomes 1 in 3){}"
        }
    },
    config = { extra = { percentage = 1.25 } },
    rarity = 3,
    atlas = 'j_chaos_chance_nexus',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    -- Implementing this by multiplying G.GAME.probabilities.normal
    add_to_deck = function(self, card, from_debuff)
        G.GAME.probabilities.normal = G.GAME.probabilities.normal * card.ability.extra.percentage
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.probabilities.normal = G.GAME.probabilities.normal / card.ability.extra.percentage
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 234. Primal Form
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_primal_form',
    config = {},
    rarity = 3,
    atlas = 'j_chaos_primal_form',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    eternal_compat = false,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            for i = 1, #G.hand.cards do
                local c = G.hand.cards[i]
                c:set_base(G.P_CARDS[c.base.suit..'_A'])
            end
            G.E_MANAGER:add_event(Event({
                func = function()
                    if not card.ability.eternal then card:start_dissolve() end
                    return true
                end
            }))
            return {
                message = localize('k_primal'),
                colour = G.C.FILTER
            }
        end
    end
})

-- 235. Maximum Entropy
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_maximum_entropy',
    config = { extra = { x_mult = 4 } },
    rarity = 3,
    atlas = 'j_chaos_maximum_entropy',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            local victim = pseudorandom_element(G.jokers.cards, pseudorandom('maximum_entropy'))
            if victim then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        victim:start_dissolve()
                        return true
                    end
                }))
            end
        end
    end
})

-- 236. Heart of Chaos
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_heart_of_chaos',
    config = { extra = { copy_target = nil } },
    rarity = 3,
    atlas = 'j_chaos_heart_of_chaos',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local right_jokers = {}
            local my_pos = nil
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then my_pos = i end
            end
            if my_pos then
                for i = my_pos + 1, #G.jokers.cards do
                    right_jokers[#right_jokers+1] = G.jokers.cards[i]
                end
            end
            if #right_jokers > 0 then
                card.ability.extra.copy_target = pseudorandom_element(right_jokers, pseudorandom('j_chaos_heart'))
            else
                card.ability.extra.copy_target = nil
            end
        end
        
        if card.ability.extra.copy_target then
            local other_joker = card.ability.extra.copy_target
            context.blueprint = true
            local ret = other_joker:calculate_joker(context)
            if ret then
                ret.card = card
                return ret
            end
        end
    end
})

-- 237. Warp Storm
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_warp_storm',
    config = { extra = { mult_per_suit = 10 } },
    rarity = 3,
    atlas = 'j_chaos_warp_storm',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult_per_suit } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            local suit_count = 0
            for i = 1, #G.playing_cards do
                local s = G.playing_cards[i].base.suit
                if not suits[s] then
                    suits[s] = true
                    suit_count = suit_count + 1
                end
            end
            local mult = suit_count * card.ability.extra.mult_per_suit
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                mult_mod = mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 238. The Great Filter
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_the_great_filter',
    config = { extra = { x_mult = 1 } },
    rarity = 3,
    atlas = 'j_chaos_the_great_filter',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if card.ability.extra.x_mult > 1 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
        if context.before and not context.blueprint then
            if context.scoring_name == '5 of a Kind' and card.ability.extra.x_mult < 5 then
                card.ability.extra.x_mult = 5
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT
                }
            end
        end
    end
})


-- 239. Azathoth
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_azathoth',
    config = { extra = { x_mult = 10 } },
    rarity = 4,
    atlas = 'j_chaos_azathoth',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        if context.end_of_round and not context.blueprint and not context.repetition and not context.other_card then
            if G.playing_cards and #G.playing_cards > 0 then
                local target = G.playing_cards[pseudorandom('j_chaos_azathoth', 1, #G.playing_cards)]
                G.E_MANAGER:add_event(Event({
                    func = function()
                        play_sound('tarot1')
                        target:start_dissolve()
                        return true
                    end
                }))
                return {
                    message = localize('k_eaten_ex'),
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 240. Crawling Chaos
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_chaos_crawling_chaos',
    config = { extra = { x_mult = 2, gain = 0.5 } },
    rarity = 4,
    atlas = 'j_chaos_crawling_chaos',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.gain } }

    end,
    calculate = function(self, card, context)
        if context.cardarea == G.jokers and context.before and not context.blueprint then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 241. Visual Bug
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_visual_bug',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_glitch_visual_bug',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        if context.before and not context.blueprint then
            -- Visual effect: flip cards face down only for this hand
            for k, v in ipairs(context.scoring_hand) do
                v.facing = 'back'
                v.sprite_facing = 'back'
            end
        end
        if context.after and not context.blueprint then
            -- Reset visual effect
            for k, v in ipairs(G.play.cards) do
                v.facing = 'front'
                v.sprite_facing = 'front'
            end
        end
    end
})

-- 242. Syntax Error
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_syntax_error',
    config = { extra = { chips = 50, money = 2 } },
    rarity = 1,
    atlas = 'j_glitch_syntax_error',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                chip_mod = card.ability.extra.chips,
                colour = G.C.CHIPS
            }
        end
        if context.before and context.scoring_name == 'High Card' and not context.blueprint then
            ease_dollars(card.ability.extra.money)
            return {
                message = localize('$')..card.ability.extra.money,
                colour = G.C.MONEY,
                card = card
            }
        end
    end
})

-- 243. Lag
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_lag',
    config = { extra = { mult = 20, active = false } },
    rarity = 1,
    atlas = 'j_glitch_lag',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if card.ability.extra.active then
                card.ability.extra.active = false
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            else
                card.ability.extra.active = true
                return {
                    message = 'Lag...',
                    colour = G.C.ATTENTION
                }
            end
        end
    end
})

-- 244. Dead Pixel
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_dead_pixel',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_glitch_dead_pixel',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        if context.before and not context.blueprint then
            local available_cards = {}
            for k, v in ipairs(G.hand.cards) do
                if not v.debuff then table.insert(available_cards, v) end
            end
            if #available_cards > 0 then
                local target = pseudorandom_element(available_cards, pseudorandom('dead_pixel'))
                target:set_debuff(true)
                return {
                    message = 'Dead Pixel!',
                    colour = G.C.RED,
                    card = card
                }
            end
        end
    end
})

-- 245. Money Glitch
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_money_glitch',
    config = { extra = { odds = 10, money = 5 } },
    rarity = 1,
    atlas = 'j_glitch_money_glitch',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money, G.GAME.probabilities.normal, extra.odds } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('money_glitch') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize('$')..card.ability.extra.money,
                    dollars = card.ability.extra.money,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 246. Overflow
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_overflow',
    config = { extra = { threshold = 100, mult = 10 } },
    rarity = 1,
    atlas = 'j_glitch_overflow',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.threshold, extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local chips = G.GAME.hands[context.scoring_name].chips
            if chips > card.ability.extra.threshold then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 247. Underflow
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_underflow',
    config = { extra = { threshold = 20, mult = 30 } },
    rarity = 1,
    atlas = 'j_glitch_underflow',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.threshold, extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local chips = G.GAME.hands[context.scoring_name].chips
            if chips < card.ability.extra.threshold then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 248. Clipping
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_clipping',
    config = { extra = {} },
    rarity = 1,
    atlas = 'j_glitch_clipping',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.hand.config.highlighted_limit = G.hand.config.highlighted_limit + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.hand.config.highlighted_limit = G.hand.config.highlighted_limit - 1
    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            if #context.full_hand > 5 then
                local rightmost = context.full_hand[#context.full_hand]
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function() 
                        draw_card(G.play, G.discard, 90, 'down', nil, rightmost)
                        return true 
                    end
                }))
                return {
                    message = 'Clipped!',
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 249. Corrupted
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_corrupted',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_glitch_corrupted',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
        if context.before and not context.blueprint then
            local suits = {'Spades', 'Hearts', 'Clubs', 'Diamonds'}
            for k, v in ipairs(context.scoring_hand) do
                local new_suit = suits[pseudorandom('corrupted', 1, 4)]
                v:change_suit(new_suit)
            end
            return {
                message = 'Corrupted!',
                colour = G.C.PURPLE
            }
        end
    end
})

-- 250. MissingNo
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_missingno',
    config = { extra = { min = 1, max = 3 } },
    rarity = 1,
    atlas = 'j_glitch_missingno',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local xmult = card.ability.extra.min + (pseudorandom('missingno') * (card.ability.extra.max - card.ability.extra.min))
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { string.format("%.2f", xmult) } },
                Xmult_mod = xmult,
                colour = G.C.MULT
            }
        end
    end
})

-- 251. Blue Screen
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_blue_screen',
    config = { extra = { money = 4 } },
    rarity = 1,
    atlas = 'j_glitch_blue_screen',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.discard then
            if #context.full_hand == 5 then
                local suit = context.full_hand[1].base.suit
                local all_same = true
                for k, v in ipairs(context.full_hand) do
                    if v.base.suit ~= suit then all_same = false; break end
                end
                
                if all_same then
                    ease_dollars(card.ability.extra.money)
                    return {
                        message = localize('$')..card.ability.extra.money,
                        colour = G.C.MONEY,
                        card = card
                    }
                end
            end
        end
    end
})

-- 252. Error 404
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_error_404',
    config = { extra = { chips = 40, mult = 40 } },
    rarity = 1,
    atlas = 'j_glitch_error_404',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if context.scoring_name == 'High Card' then
                return {
                    message = localize('k_val_up'),
                    chip_mod = card.ability.extra.chips,
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- 253. Infinite Loop
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_infinite_loop',
    loc_txt = {
        name = "Infinite Loop",
        text = {
            "{C:mult}+5{} Mult.",
            "Increases by {C:mult}+1{} Mult",
            "each time it triggers in a round",
            "{C:inactive}(Currently {C:mult}+#1#{}{C:inactive} Mult){}"
        }
    },
    config = { extra = { mult = 5, gain = 1, current = 5 } },
    rarity = 1,
    atlas = 'j_glitch_infinite_loop',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.current } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local current = card.ability.extra.current
            card.ability.extra.current = current + card.ability.extra.gain
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { current } },
                mult_mod = current,
                colour = G.C.MULT
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current = card.ability.extra.mult
        end
    end
})

-- 254. Stack Overflow
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_stack_overflow',
    loc_txt = {
        name = "Stack Overflow",
        text = {
            "{C:mult}+4{} Mult for each",
            "card in your {C:attention}hand{}"
        }
    },
    config = { extra = { mult_per_card = 4 } },
    rarity = 1,
    atlas = 'j_glitch_stack_overflow',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult_per_card } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local cards_in_hand = #G.hand.cards
            local mult = cards_in_hand * card.ability.extra.mult_per_card
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                mult_mod = mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 255. Memory Leak
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_memory_leak',
    loc_txt = {
        name = "Memory Leak",
        text = {
            "{C:mult}+20{} Mult.",
            "{C:red}-1{} Discard"
        }
    },
    config = { extra = { mult = 20 } },
    rarity = 1,
    atlas = 'j_glitch_memory_leak',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + 1
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 256. Patch
SMODS.Joker({
    unlocked = true,
    discovered = true,
    key = 'j_glitch_patch',
    loc_txt = {
        name = "Patch",
        text = {
            "{C:mult}+10{} Mult for each",
            "{C:attention}debuffed Joker{} you have"
        }
    },
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_glitch_patch',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local debuffed_count = 0
            for k, v in ipairs(G.jokers.cards) do
                if v.debuff then debuffed_count = debuffed_count + 1 end
            end
            
            if debuffed_count > 0 then
                local mult = debuffed_count * card.ability.extra.mult
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } },
                    mult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})


local local_jokers = {
    {
        key = 'j_glitch_exploit',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_exploit',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main and context.scoring_hand then
                local debuffed_found = false
                for _, other_card in ipairs(context.scoring_hand) do
                    if other_card.debuff then
                        debuffed_found = true
                        break
                    end
                end
                
                if debuffed_found then
                    return {
                        message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}},
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_debug_mode',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_debug_mode',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 10 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_glitch_god_mode',
        rarity = 2,
        cost = 8,
        atlas = 'j_glitch_god_mode',
        pos = { x = 0, y = 0 },
        config = {},
        blueprint_compat = false,
        calculate = function(self, card, context)
            if context.game_over and (not context.repetition) and not context.blueprint then
                if G.GAME.chips / G.GAME.blind.chips < 1 then
                    return {
                        message = localize('k_saved_ex'),
                        saved = true,
                        colour = G.C.RED,
                        func = function() 
                            G.E_MANAGER:add_event(Event({
                                func = function()
                                    play_sound('tarot1')
                                    card.T.r = -0.2
                                    card:juice_up(0.3, 0.4)
                                    card.states.drag.is = true
                                    card.children.center.pinch.x = true
                                    G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.3, blockable = false,
                                        func = function()
                                            G.jokers:remove_card(card)
                                            card:remove()
                                            card = nil
                                            return true; 
                                        end
                                    })) 
                                    return true
                                end
                            }))
                        end
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_noclip',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_noclip',
        pos = { x = 0, y = 0 },
        blueprint_compat = false,
        config = {},
    },
    {
        key = 'j_glitch_speedrun',
        rarity = 2,
        cost = 5,
        atlas = 'j_glitch_speedrun',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 50 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main and G.GAME.current_round.hands_played == 0 then
                return {
                    message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_glitch_softlock',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_softlock',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 3 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if G.GAME.current_round.discards_left == 0 and G.GAME.dollars <= 0 then
                    return {
                        message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}},
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_duplication_glitch',
        rarity = 2,
        cost = 7,
        atlas = 'j_glitch_duplication_glitch',
        pos = { x = 0, y = 0 },
        config = { extra = { odds = 5 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { G.GAME.probabilities.normal, extra.odds } }

        end,
        calculate = function(self, card, context)
            if context.cardarea == G.jokers and context.before and not context.blueprint then
                if context.scoring_hand then
                    local triggered = false
                    for i = 1, #context.scoring_hand do
                        if pseudorandom('duplication_glitch') < G.GAME.probabilities.normal / card.ability.extra.odds then
                            triggered = true
                            local shop_card = context.scoring_hand[i]
                            G.E_MANAGER:add_event(Event({
                                func = function()
                                    local _card = copy_card(shop_card, nil, nil, G.playing_card, nil)
                                    _card:add_to_deck()
                                    G.deck.config.card_limit = G.deck.config.card_limit + 1
                                    table.insert(G.playing_cards, _card)
                                    G.hand:emplace(_card)
                                    _card:start_materialize()
                                    return true
                                end
                            }))
                        end
                    end
                    if triggered then
                        return {
                            message = localize('k_copied_ex'),
                            colour = G.C.CHIPS,
                            card = card
                        }
                    end
                end
            end
        end
    },
    {
        key = 'j_glitch_source_code',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_source_code',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 20 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)
            info_queue[#info_queue+1] = G.P_CENTERS.m_odyssey_emerald
            return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult } }
        end,
        calculate = function(self, card, context)
            if context.setting_blind and not context.blueprint then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = create_card('Default', G.hand, nil, nil, nil, nil, 'm_odyssey_emerald', 'odyssey_source_code')
                        _card:add_to_deck()
                        G.deck.config.card_limit = G.deck.config.card_limit + 1
                        table.insert(G.playing_cards, _card)
                        G.hand:emplace(_card)
                        _card:start_materialize()
                        return true
                    end
                }))
                return {
                    message = localize('k_active_ex'),
                    colour = G.C.FILTER
                }
            end
            
            if context.joker_main then
                local stone_found = false
                if G.hand and G.hand.cards then
                    for _, c in ipairs(G.hand.cards) do
                        if c.config.center == G.P_CENTERS.m_odyssey_emerald then
                            stone_found = true
                            break
                        end
                    end
                end
                
                if stone_found then
                    return {
                        message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}},
                        mult_mod = card.ability.extra.mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_hacker',
        rarity = 2,
        cost = 7,
        atlas = 'j_glitch_hacker',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 1.5 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}},
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
            
            if context.before and context.scoring_name then
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = localize('k_level_up_ex')})
                update_hand_text({sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3}, {handname=context.scoring_name,level=G.GAME.hands[context.scoring_name].level})
                level_up_hand(context.blueprint_card or card, context.scoring_name, true, 1)        
            end

            if context.after and context.scoring_name and not context.blueprint then
                level_up_hand(card, context.scoring_name, true, -1)
                update_hand_text({sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3}, {handname=context.scoring_name,level=G.GAME.hands[context.scoring_name].level})
            end 
        end
    },
    {
        key = 'j_glitch_firewall',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_firewall',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main and G.GAME.blind.boss then
                return {
                    message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}},
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_glitch_virus',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_virus',
        pos = { x = 0, y = 0 },
        config = {},
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.before and not context.blueprint then
                if context.scoring_hand and #context.scoring_hand > 0 and G.hand.cards and #G.hand.cards > 0 then
                    local target_suit = context.scoring_hand[1].base.suit
                    local random_card = pseudorandom_element(G.hand.cards, pseudorandom('virus'))
                    
                    random_card:change_suit(target_suit)
                    card:juice_up()
                    
                    return {
                        message = localize('k_active_ex'),
                        colour = G.C.RED,
                        card = card
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_trojan',
        rarity = 2,
        cost = 6,
        atlas = 'j_glitch_trojan',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 4,  x_mult = 3, rounds_remaining = 3 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, 3, extra.x_mult, extra.rounds_remaining } }

        end,
        calculate = function(self, card, context)
            if context.end_of_round and not context.repetition and not context.other_card then
                if card.ability.extra.rounds_remaining > 0 then
                    card.ability.extra.rounds_remaining = card.ability.extra.rounds_remaining - 1
                    return {
                        message = card.ability.extra.rounds_remaining .. '',
                        colour = G.C.FILTER
                    }
                else
                    return {
                        message = localize('k_active_ex'),
                        colour = G.C.FILTER
                    }
                end
            end
            
            if context.joker_main then
                if card.ability.extra.rounds_remaining > 0 then
                    return {
                        message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}},
                        mult_mod = card.ability.extra.mult,
                        colour = G.C.MULT
                    }
                else
                    return {
                        message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}},
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_phishing',
        rarity = 2,
        cost = 5,
        atlas = 'j_glitch_phishing',
        pos = { x = 0, y = 0 },
        config = { extra = { odds = 3, dollars = 1 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { G.GAME.probabilities.normal, extra.odds, extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.discard and not context.blueprint then
                if context.other_card and context.other_card:is_face() then
                     if pseudorandom('phishing') < G.GAME.probabilities.normal / card.ability.extra.odds then
                        ease_dollars(card.ability.extra.dollars)
                        return {
                            message = localize('$')..card.ability.extra.dollars,
                            colour = G.C.MONEY,
                            card = card
                        }
                     end
                end
            end
        end
    },
    {
        key = 'j_glitch_zero_day',
        rarity = 2,
        cost = 5,
        atlas = 'j_glitch_zero_day',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2.5 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                -- first hand of FIRST ante
                if G.GAME.round_resets.ante == 1 and G.GAME.current_round.hands_played == 0 then
                    return {
                        message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}},
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    } 
                end
            end
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end


local local_jokers = {
    {
        key = 'j_glitch_game_breaker',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_game_breaker',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = false,
        add_to_deck = function(self, card, from_debuff)
            G.jokers.config.card_limit = G.jokers.config.card_limit + 1
            G.hand.config.card_limit = G.hand.config.card_limit - 2
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.jokers.config.card_limit = G.jokers.config.card_limit - 1
            G.hand.config.card_limit = G.hand.config.card_limit + 2
        end
    },
    {
        key = 'j_glitch_kill_screen',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_kill_screen',
        pos = { x = 0, y = 0 },
        config = { extra = { threshold = 1000000, money = 20 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.money, extra.threshold } }

        end,
        calculate = function(self, card, context)
            if context.end_of_round and not context.repetition and not context.other_card then
                if G.GAME.blind.chips >= card.ability.extra.threshold then
                    ease_dollars(card.ability.extra.money)
                    return {
                        message = localize('$')..card.ability.extra.money,
                        colour = G.C.MONEY
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_matrix_glitch',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_matrix_glitch',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.repetition then
                if context.cardarea == G.play then
                    return {
                        message = localize('k_again_ex'),
                        repetitions = 1,
                        card = context.other_card
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_overwrite',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_overwrite',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = false,
        calculate = function(self, card, context)
            if context.selling_card and context.card.edition and context.card ~= card then
                card:set_edition(context.card.edition, true)
                return {
                    message = 'Overwritten!',
                    colour = G.C.RED
                }
            end
        end
    },
    {
        key = 'j_glitch_hex_editor',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_hex_editor',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.discard and not context.blueprint then
                if context.other_card then
                    local new_rank = pseudorandom_element({'2','3','4','5','6','7','8','9','10','J','Q','K','A'}, pseudorandom('hex_editor_rank'))
                    local new_suit = pseudorandom_element({'Spades','Hearts','Clubs','Diamonds'}, pseudorandom('hex_editor_suit'))
                    context.other_card:set_base(G.P_CARDS[new_suit..'_'..new_rank])
                    return {
                        message = 'Edited!',
                        colour = G.C.PURPLE,
                        card = card
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_corruption',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_corruption',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 1.5, odds = 10 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local mult = 1
                for k, v in ipairs(G.jokers.cards) do
                    if v ~= card then
                        mult = mult * card.ability.extra.x_mult
                    end
                end
                if mult > 1 then
                    return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { mult } },
                        Xmult_mod = mult,
                        colour = G.C.MULT
                    }
                end
            end
            if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
                for k, v in ipairs(G.jokers.cards) do
                    if v ~= card and pseudorandom('corruption') < G.GAME.probabilities.normal / card.ability.extra.odds then
                        v:start_dissolve()
                    end
                end
            end
        end
    },
    {
        key = 'j_glitch_segfault',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_segfault',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 5 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if context.full_hand and #context.full_hand > 5 then
                    return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_glitch_root_access',
        rarity = 3,
        cost = 8,
        atlas = 'j_glitch_root_access',
        pos = { x = 0, y = 0 },
        config = { extra = { bonus_slots = 3 } },
        blueprint_compat = false,
        add_to_deck = function(self, card, from_debuff)
            G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra.bonus_slots
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.consumeables.config.card_limit = G.consumeables.config.card_limit - card.ability.extra.bonus_slots
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end

local local_jokers = {
    {
        key = 'j_glitch_the_architect',
        rarity = 4,
        cost = 20,
        atlas = 'j_glitch_the_architect',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end,
        update = function(self, card, dt)
            if G.GAME and G.GAME.current_round then
                G.GAME.current_round.reroll_cost = 0
            end
        end
    },
    {
        key = 'j_glitch_digital_singularity',
        rarity = 4,
        cost = 20,
        atlas = 'j_glitch_digital_singularity',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 5, gain = 1 } },
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)
            local count = 0
            if G.jokers then
                for k, v in ipairs(G.jokers.cards) do
                    if v ~= card and v.config.center.key and string.find(v.config.center.key, 'j_glitch_') then
                        count = count + 1
                    end
                end
            end
            return { vars = { card.ability.extra.x_mult, card.ability.extra.gain, card.ability.extra.x_mult + (count * card.ability.extra.gain) } }
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local count = 0
                for k, v in ipairs(G.jokers.cards) do
                    if v ~= card and v.config.center.key and string.find(v.config.center.key, 'j_glitch_') then
                        count = count + 1
                    end
                end
                local total_xmult = card.ability.extra.x_mult + (count * card.ability.extra.gain)
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { total_xmult } },
                    Xmult_mod = total_xmult,
                    colour = G.C.MULT
                }
            end
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end


local local_jokers = {
    {
        key = 'j_corruption_blood_pact',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_blood_pact',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 30, hands_lost = 1 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
            if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
                if G.GAME.round_resets.hands > 1 then
                    G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hands_lost
                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = '-1 Hand'})
                end
            end
        end
    },
    {
        key = 'j_corruption_sold_soul',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_sold_soul',
        pos = { x = 0, y = 0 },
        config = { extra = { chips = 100 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        add_to_deck = function(self, card, from_debuff)
            ease_dollars(-G.GAME.dollars, true)
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    },
    {
        key = 'j_corruption_cursed_blade',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_cursed_blade',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 15 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
            if context.after and not context.blueprint then
                if context.scoring_hand and #context.scoring_hand > 0 then
                    local target = context.scoring_hand[#context.scoring_hand]
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            target:start_dissolve()
                            return true
                        end
                    }))
                    return {
                        message = localize('k_destroyed'),
                        colour = G.C.RED
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_poisoned_chalice',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_poisoned_chalice',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2, dollars = 2 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
            if context.after and not context.blueprint then
                ease_dollars(-card.ability.extra.dollars)
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = '-$'..card.ability.extra.dollars, colour = G.C.MONEY})
            end
        end
    },
    {
        key = 'j_corruption_minor_sacrifice',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_minor_sacrifice',
        pos = { x = 0, y = 0 },
        config = { extra = { dollars = 3 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.discard and #context.full_hand == 1 and not context.blueprint then
                return {
                    message = localize('k_val_up'),
                    remove = true,
                    dollars = card.ability.extra.dollars
                }
            end
        end
    },
    {
        key = 'j_corruption_life_drain',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_life_drain',
        pos = { x = 0, y = 0 },
        config = { extra = { mult_per_hand = 10, hands_lost = 1 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult_per_hand } }

        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hands_lost
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra.hands_lost
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local hands_left = G.GAME.current_round.hands_left
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { hands_left * card.ability.extra.mult_per_hand } },
                    mult_mod = hands_left * card.ability.extra.mult_per_hand,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_corruption_parasite',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_parasite',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 5 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local other_jokers = 0
                if G.jokers then
                    for k, v in pairs(G.jokers.cards) do
                        if v ~= card then other_jokers = other_jokers + 1 end
                    end
                end
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { other_jokers * card.ability.extra.mult } },
                    mult_mod = other_jokers * card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end,
        update = function(self, card, dt)
            if G.jokers then
                for k, v in pairs(G.jokers.cards) do
                    if v ~= card and not v.debuff then
                        v.debuff = true
                    end
                end
            end
        end,
        remove_from_deck = function(self, card, from_debuff)
            if G.jokers then
                for k, v in pairs(G.jokers.cards) do
                    if v ~= card then
                        v.debuff = false
                    end
                end
            end
        end
    },
    {
        key = 'j_corruption_decomposition',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_decomposition',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 0, gain = 5 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.gain } }

        end,
        calculate = function(self, card, context)
            if context.discard and not context.blueprint then
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
                return {
                    message = localize('k_val_up'),
                    colour = G.C.MULT,
                    remove = true
                }
            end
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_corruption_rust',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_rust',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 1.5, odds = 6 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, G.GAME.probabilities.normal, extra.odds } }

        end,
        calculate = function(self, card, context)
            if context.individual and context.cardarea == G.play then
                if context.other_card.ability.effect == 'Steel Card' then
                    return {
                        x_mult = card.ability.extra.x_mult,
                        card = card
                    }
                end
            end
            if context.after and not context.blueprint then
                for _, other_card in ipairs(context.scoring_hand) do
                    if other_card.ability.effect == 'Steel Card' then
                         if pseudorandom('rust') < G.GAME.probabilities.normal / card.ability.extra.odds then
                            if not other_card.ability.eternal then other_card:start_dissolve() end
                            card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_shattered')})
                         end
                    end
                end
            end
        end
    },
    {
        key = 'j_corruption_noxious_spores',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_noxious_spores',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 20 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)
            info_queue[#info_queue+1] = G.P_CENTERS.m_odyssey_emerald
            return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult } }
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
            if context.before and not context.blueprint then
                for k, v in ipairs(context.scoring_hand) do
                    v:set_ability(G.P_CENTERS.m_odyssey_emerald, nil, true)
                end
            end
        end
    },
    {
        key = 'j_corruption_contamination',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_contamination',
        pos = { x = 0, y = 0 },
        config = { extra = { chips = 10 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
            if context.after and not context.blueprint then
                for k, v in ipairs(context.scoring_hand) do
                    v:change_suit('Spades')
                end
            end
        end
    },
    {
        key = 'j_corruption_necrosis',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_necrosis',
        pos = { x = 0, y = 0 },
        config = { extra = { face_pen = -10, num_bonus = 20 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.face_pen, extra.num_bonus } }

        end,
        calculate = function(self, card, context)
            if context.individual and context.cardarea == G.play then
                if context.other_card:is_face() then
                    return {
                        chips = card.ability.extra.face_pen,
                        card = card
                    }
                else
                    return {
                        chips = card.ability.extra.num_bonus,
                        card = card
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_plague',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_plague',
        pos = { x = 0, y = 0 },
        config = { extra = { odds = 3 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { G.GAME.probabilities.normal, extra.odds } }

        end,
        calculate = function(self, card, context)
            if context.discard and not context.blueprint then
                if pseudorandom('plague') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    return {
                        remove = true,
                        message = localize('k_destroyed')
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_rotten_hand',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_rotten_hand',
        pos = { x = 0, y = 0 },
        config = { extra = { dollars = 10 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.before and not context.blueprint then
                if G.GAME.last_hand_played == context.scoring_name then
                    ease_dollars(card.ability.extra.dollars)
                end
            end
            if context.joker_main then
                 if G.GAME.last_hand_played == context.scoring_name then
                     return {
                         message = localize('k_nope_ex'),
                         Xmult_mod = 0,
                         colour = G.C.RED
                     }
                 end
            end
        end
    },
    {
        key = 'j_corruption_dark_heart',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_dark_heart',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 15 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local has_hearts = false
                for k, v in pairs(G.playing_cards) do
                    if v.base.suit == 'Hearts' then has_hearts = true break end
                end
                if not has_hearts then
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                        mult_mod = card.ability.extra.mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_corrupted_mind',
        rarity = 1,
        cost = 4,
        atlas = 'j_corruption_corrupted_mind',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 25, hand_size = -1 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.hand_size } }

        end,
        add_to_deck = function(self, card, from_debuff)
            G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end


local local_jokers = {
    {
        key = 'j_corruption_cannibalism',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_cannibalism',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 3, active = false } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.setting_blind and not context.blueprint then
                local destroyable_jokers = {}
                if G.jokers then
                    for k, v in pairs(G.jokers.cards) do
                        if v ~= card and not v.ability.eternal then
                            table.insert(destroyable_jokers, v)
                        end
                    end
                end
                
                if #destroyable_jokers > 0 then
                    local joker_to_destroy = pseudorandom_element(destroyable_jokers, pseudorandom('cannibalism'))
                    joker_to_destroy:start_dissolve(nil, true)
                    card.ability.extra.active = true
                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_active_ex')})
                else
                    card.ability.extra.active = false
                end
            end
            if context.joker_main and card.ability.extra.active then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
            if context.end_of_round and not context.repetition and not context.other_card then
                card.ability.extra.active = false
            end
        end
    },
    {
        key = 'j_corruption_vampirism',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_vampirism',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 0, gain = 2 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.gain } }

        end,
        calculate = function(self, card, context)
            if context.before and not context.blueprint then
                for k, v in ipairs(context.scoring_hand) do
                    if v.config.center ~= G.P_CENTERS.c_base then
                        v:set_ability(G.P_CENTERS.c_base, nil, true)
                        card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
                        card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_upgrade_ex')})
                    end
                end
            end
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_corruption_necromancy',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_necromancy',
        pos = { x = 0, y = 0 },
        config = { extra = { triggered_this_round = false } },
        blueprint_compat = false,
        eternal_compat = true,
        calculate = function(self, card, context)
            if context.destroying_card and not context.blueprint then
                    if not card.ability.extra.triggered_this_round then
                        local destroyed_card = context.destroying_card
                        G.E_MANAGER:add_event(Event({
                            trigger = 'after',
                            delay = 0.4,
                            func = function()
                                G.playing_card = (G.playing_card or 0) + 1
                                local _card = copy_card(destroyed_card, nil, nil, G.playing_card)
                                _card:add_to_deck()
                                G.deck.config.card_limit = G.deck.config.card_limit + 1
                                table.insert(G.playing_cards, _card)
                                G.hand:emplace(_card)
                                return true
                            end
                        }))
                        card.ability.extra.triggered_this_round = true
                        return {
                            message = localize('k_saved'),
                            colour = G.C.GREEN
                        }
                    end
            end
            if context.end_of_round and not context.repetition and not context.other_card then
                card.ability.extra.triggered_this_round = false
            end
        end
    },
    {
        key = 'j_corruption_offering',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_offering',
        pos = { x = 0, y = 0 },
        config = { extra = { dollars = 50 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.discard and not context.blueprint then
                if #context.full_hand == 5 then
                    local suits = {}
                    local ranks = {}
                    for _, c in ipairs(context.full_hand) do
                        suits[c.base.suit] = (suits[c.base.suit] or 0) + 1
                        ranks[c.base.id] = (ranks[c.base.id] or 0) + 1
                    end
                    local is_flush = false
                    for s, count in pairs(suits) do
                        if count == 5 then is_flush = true break end
                    end
                    local is_royal = ranks[10] and ranks[11] and ranks[12] and ranks[13] and ranks[14]
                    
                    if is_flush and is_royal then
                        ease_dollars(card.ability.extra.dollars)
                        return {
                            message = localize('k_val_up'),
                            colour = G.C.MONEY
                        }
                    end
                end
            end
        end
    },
    {
        key = 'j_corruption_curse_of_gold',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_curse_of_gold',
        pos = { x = 0, y = 0 },
        config = { extra = { dollars = 1 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.individual and context.cardarea == G.play then
                ease_dollars(card.ability.extra.dollars)
                context.other_card.ability.perma_bonus = 0 
                return {
                    chips = -context.other_card.base.nominal, 
                    card = card
                }
            end
        end
    },
    {
        key = 'j_corruption_void_whispers',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_void_whispers',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2.5, threshold = 20 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.threshold } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if #G.playing_cards < card.ability.extra.threshold then
                    return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                        Xmult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_mark_of_the_beast',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_mark_of_the_beast',
        pos = { x = 0, y = 0 },
        config = { extra = { chips = 666, hands_mod = 0 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        add_to_deck = function(self, card, from_debuff)
            card.ability.extra.hands_mod = G.GAME.round_resets.hands - 1
            G.GAME.round_resets.hands = 1
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.round_resets.hands = G.GAME.round_resets.hands + (card.ability.extra.hands_mod or 0)
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    },
    {
        key = 'j_corruption_soul_corruption',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_soul_corruption',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = false,
        eternal_compat = true,
        update = function(self, card, dt)
            if G.consumeables then
                for k, v in pairs(G.consumeables.cards) do
                    if v.config.center.set == 'Tarot' then
                        local spectral = pseudorandom_element(G.P_CENTER_POOLS.Spectral, pseudorandom('soul_corruption'))
                        v:set_ability(spectral)
                        v:set_edition(nil, true)
                    end
                end
            end
        end
    },
    {
        key = 'j_corruption_decadence',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_decadence',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 4, loss = 1 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.loss } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local current_ante = G.GAME.round_resets.ante
                local mult = math.max(1, card.ability.extra.x_mult - (current_ante - 1) * card.ability.extra.loss)
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { mult } },
                    Xmult_mod = mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_corruption_toxin',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_toxin',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 50 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
            if context.after and not context.blueprint then
                for k, v in ipairs(context.scoring_hand) do
                    v.ability.perma_debuff = true
                    v:set_debuff(true)
                end
            end
        end
    },
    {
        key = 'j_corruption_mutation',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_mutation',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 15 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
            if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
                local random_card = pseudorandom_element(G.playing_cards, pseudorandom('mutation'))
                local new_rank = pseudorandom_element({'2','3','4','5','6','7','8','9','10','J','Q','K','A'}, pseudorandom('mutation_rank'))
                local new_suit = pseudorandom_element({'Spades','Hearts','Clubs','Diamonds'}, pseudorandom('mutation_suit'))
                
                assert(SMODS.change_base(random_card, new_suit, new_rank))
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_reset'), colour = G.C.PURPLE})
            end
        end
    },
    {
        key = 'j_corruption_scar',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_scar',
        pos = { x = 0, y = 0 },
        config = { extra = { chips = 0 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        calculate = function(self, card, context)
            if context.destroying_card and not context.blueprint then
                card.ability.extra.chips = (card.ability.extra.chips or 0) + 10
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.CHIPS
                }
            end
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    },
    {
        key = 'j_corruption_slow_poison',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_slow_poison',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 3, limit = 3 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.limit } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
            if context.after and not context.blueprint then
                if G.GAME.current_round.hands_played >= card.ability.extra.limit and G.GAME.chips < G.GAME.blind.chips then
                    G.STATE = G.STATES.GAME_OVER
                    G.STATE_COMPLETE = false
                    return {
                        message = localize('k_game_over'),
                        colour = G.C.RED
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_grim_harvest',
        rarity = 2,
        cost = 6,
        atlas = 'j_corruption_grim_harvest',
        pos = { x = 0, y = 0 },
        config = { extra = { dollars = 0 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.dollars } }

        end,
        calculate = function(self, card, context)
            if context.destroying_card and not context.blueprint then
                card.ability.extra.dollars = card.ability.extra.dollars + 1
            end
            if context.end_of_round and not context.repetition and not context.other_card then
                local gain = card.ability.extra.dollars
                card.ability.extra.dollars = 0
                ease_dollars(gain)
                return {
                    message = localize{ type = 'variable', key = 'a_dollars', vars = { gain } },
                    colour = G.C.MONEY
                }
            end
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end

local local_jokers = {
    {
        key = 'j_corruption_pestilence',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_pestilence',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = true,
        eternal_compat = true,
        calculate = function(self, card, context)
            if context.before and not context.blueprint then
                local text, poker_hands, scoring_hand = G.FUNCS.get_poker_hand_info(G.play.cards)
                if text == 'Flush' then
                    local suit = scoring_hand[1].base.suit
                    for k, v in ipairs(G.hand.cards) do
                        v:change_suit(suit)
                    end
                    return {
                        message = localize('k_infected'),
                        colour = G.C.PURPLE
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_famine',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_famine',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 5, hand_size_mod = -5 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.hand_size_mod } }

        end,
        add_to_deck = function(self, card, from_debuff)
            G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size_mod
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size_mod
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_corruption_war',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_war',
        pos = { x = 0, y = 0 },
        config = { extra = { mult = 0, gain = 10 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.gain } }

        end,
        calculate = function(self, card, context)
            if context.after and not context.blueprint then
                local destroyed_cards = {}
                for k, v in ipairs(G.hand.cards) do
                    if not v.ability.eternal then
                        destroyed_cards[#destroyed_cards+1] = v
                    end
                end
                if #destroyed_cards > 0 then
                    for _, v in ipairs(destroyed_cards) do
                        v:start_dissolve(nil, true)
                    end
                    card.ability.extra.mult = card.ability.extra.mult + (#destroyed_cards * card.ability.extra.gain)
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                        colour = G.C.RED
                    }
                end
            end
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
            if context.end_of_round and not context.repetition and not context.other_card then
                card.ability.extra.mult = 0
                return {
                    message = localize('k_reset'),
                    colour = G.C.RED
                }
            end
        end
    },
    {
        key = 'j_corruption_death',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_death',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = false,
        eternal_compat = true,
        calculate = function(self, card, context)
            if context.after and not context.blueprint then
                if G.GAME.current_round.hands_left == 0 then
                    G.E_MANAGER:add_event(Event({
                        trigger = 'immediate',
                        func = function()
                            for k, v in ipairs(G.playing_cards) do
                                v:set_ability(G.P_CENTERS.m_odyssey_plastic, nil, true)
                            end
                            G.GAME.chips = G.GAME.blind.chips
                            return true
                        end
                    }))
                    return {
                        message = localize('k_death_win'),
                        colour = G.C.BLACK
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_apocalypse',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_apocalypse',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 1, gain = 10 } },
        blueprint_compat = false,
        eternal_compat = true,
        calculate = function(self, card, context)
            if context.selling_self and not context.blueprint then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        for k, v in pairs(G.jokers.cards) do
                            if v ~= card and not v.ability.eternal then
                                v:start_dissolve(nil, true)
                            end
                        end
                        local token = create_card('Joker', G.jokers, nil, nil, nil, nil, 'j_corruption_post_apocalypse')
                        token:add_to_deck()
                        G.jokers:emplace(token)
                        return true
                    end
                }))
            end
        end
    },
    {
        key = 'j_corruption_entropy',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_entropy',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = true,
        eternal_compat = true,
        calculate = function(self, card, context)
            if context.after and not context.blueprint then
                for k, v in ipairs(G.hand.cards) do
                    local new_rank = pseudorandom_element({'2','3','4','5','6','7','8','9','10','J','Q','K','A'}, pseudorandom('entropy_rank'))
                    local new_suit = pseudorandom_element({'Spades','Hearts','Clubs','Diamonds'}, pseudorandom('entropy_suit'))
                    v:set_base(G.P_CARDS[new_suit..'_'..new_rank])
                end
                return {
                    message = localize('k_chaos'),
                    colour = G.C.RED
                }
            end
        end
    },
    {
        key = 'j_corruption_absolute_chaos',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_absolute_chaos',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 2 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local suits = {}
                local unique_suits = 0
                for k, v in ipairs(context.scoring_hand) do
                    if not suits[v.base.suit] then
                        suits[v.base.suit] = true
                        unique_suits = unique_suits + 1
                    end
                end
                if unique_suits > 0 then
                    local mult = card.ability.extra.x_mult ^ unique_suits
                    return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { mult } },
                        x_mult_mod = mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_the_end',
        rarity = 3,
        cost = 8,
        atlas = 'j_corruption_the_end',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 100 } },
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if G.GAME.current_round.hands_left == 1 and G.GAME.current_round.discards_left == 0 then
                        return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                        x_mult_mod = card.ability.extra.x_mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    {
        key = 'j_corruption_post_apocalypse',
        rarity = 1,
        cost = 0,
        atlas = 'j_corruption_apocalypse',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 10 } },
        blueprint_compat = true,
        eternal_compat = true,
        yes_pool_flag = 'post_apocalypse_token',
        in_pool = function() return false end,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end


local local_jokers = {
    {
        key = 'j_corruption_world_eater',
        rarity = 4,
        cost = 20,
        atlas = 'j_corruption_world_eater',
        pos = { x = 0, y = 0 },
        config = { extra = { x_mult = 1, gain = 0.5 } },
        blueprint_compat = false,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.gain } }

        end,
        calculate = function(self, card, context)
            if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
                local destroyed_count = 0
                if G.playing_cards then
                    for k, v in pairs(G.playing_cards) do
                        if not v.ability.eternal then
                            v:start_dissolve(nil, true)
                            destroyed_count = destroyed_count + 1
                        end
                    end
                end
                
                if destroyed_count > 0 then
                    card.ability.extra.x_mult = card.ability.extra.x_mult + (destroyed_count * card.ability.extra.gain)
                    return {
                        message = localize('k_upgrade_ex'),
                        colour = G.C.RED
                    }
                end
            end
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    {
        key = 'j_corruption_the_entity',
        rarity = 4,
        cost = 20,
        atlas = 'j_corruption_the_entity',
        pos = { x = 0, y = 0 },
        config = { extra = {} },
        blueprint_compat = false,
        eternal_compat = true,
        calculate = function(self, card, context)
            if context.blueprint then return end
            
            local ret = {}
            local triggered = false
            
            if G.jokers then
                for k, v in pairs(G.jokers.cards) do
                    if v ~= card and v.edition and v.edition.negative then
                        context.blueprint = true
                        context.blueprint_card = card
                        if v.ability.blueprint_compat then
                            local other_joker_ret = v:calculate_joker(context)
                            if other_joker_ret then
                                triggered = true
                                if other_joker_ret.mult_mod then
                                    ret.mult_mod = (ret.mult_mod or 0) + other_joker_ret.mult_mod
                                end
                                if other_joker_ret.chip_mod then
                                    ret.chip_mod = (ret.chip_mod or 0) + other_joker_ret.chip_mod
                                end
                                if other_joker_ret.x_mult_mod then
                                    ret.x_mult_mod = (ret.x_mult_mod or 1) * other_joker_ret.x_mult_mod
                                end
                                if other_joker_ret.message then
                                    ret.message = other_joker_ret.message
                                end
                                if other_joker_ret.colour then
                                    ret.colour = other_joker_ret.colour
                                end
                            end
                        end
                        context.blueprint = false
                        context.blueprint_card = nil
                    end
                end
            end
            
            if triggered then
                return ret
            end
        end
    }
}

for _, joker in ipairs(local_jokers) do
    joker.unlocked = true
    joker.discovered = true
    SMODS.Joker(joker)
end


-- ============================================
-- PARADOX - Common (Jokers 321-336)
-- ============================================

-- 321. Menos  Mais (Less is More)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_less_is_more',
    atlas = 'j_paradox_less_is_more',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 20, max_cards = 3 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.max_cards } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and #context.full_hand < card.ability.extra.max_cards then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 322. Fraco  Forte (Weak is Strong)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_weak_is_strong',
    atlas = 'j_paradox_weak_is_strong',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 10 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local rank = context.other_card:get_id()
            if rank >= 2 and rank <= 4 then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 323. Perder para Ganhar (Lose to Win)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_lose_to_win',
    atlas = 'j_paradox_lose_to_win',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { dollars = 3 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.after and G.GAME.chips < (G.GAME.blind.chips * 0.1) then
            ease_dollars(card.ability.extra.dollars)
            return {
                message = localize('$')..card.ability.extra.dollars,
                colour = G.C.MONEY,
                card = card
            }
        end
    end
})

-- 324. Descarte til (Useful Discard)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_useful_discard',
    atlas = 'j_paradox_useful_discard',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { current_chips = 0, chip_gain = 2 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chip_gain, extra.current_chips } }

    end,
    calculate = function(self, card, context)
        if context.discard and not context.other_card and not context.blueprint then
            card.ability.extra.current_chips = card.ability.extra.current_chips + card.ability.extra.chip_gain
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.current_chips } },
                colour = G.C.CHIPS,
                card = card
            }
        end
        if context.joker_main and card.ability.extra.current_chips > 0 then
            return {
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.current_chips } },
                chip_mod = card.ability.extra.current_chips,
                colour = G.C.CHIPS
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current_chips = 0
            return {
                message = localize('k_reset'),
                colour = G.C.RED
            }
        end
    end
})

-- 325. Mo Torta (Crooked Hand)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_crooked_hand',
    atlas = 'j_paradox_crooked_hand',
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 10 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if context.scoring_name == 'Flush' or context.scoring_name == 'Straight' or context.scoring_name == 'Straight Flush' then
                return nil
            end
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 326. Flush Reverso (Reverse Flush)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_reverse_flush',
    atlas = 'j_paradox_reverse_flush',
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    config = { extra = { x_mult = 2 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = { ['Spades'] = 0, ['Hearts'] = 0, ['Clubs'] = 0, ['Diamonds'] = 0 }
            local unique_suits = 0
            for _, v in ipairs(context.scoring_hand) do
                if suits[v.base.suit] == 0 then
                    suits[v.base.suit] = 1
                    unique_suits = unique_suits + 1
                end
            end
            
            if unique_suits >= 4 then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 327. Par mpar (Odd Pair)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_odd_pair',
    atlas = 'j_paradox_odd_pair',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 15 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local is_odd_pair = false
            if context.poker_hands and context.poker_hands['Pair'] and #context.poker_hands['Pair'] > 0 then
                for _, p in ipairs(context.poker_hands['Pair']) do
                    local rank = p[1]:get_id()
                    if rank % 2 ~= 0 then
                        is_odd_pair = true
                    end
                end
            end
            
            if is_odd_pair then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 328. Full House Vazio (Empty Full House)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_empty_full_house',
    atlas = 'j_paradox_empty_full_house',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 12 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and #context.full_hand == 5 and context.scoring_name ~= 'Full House' then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 329. High Low (High Low)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_high_low',
    atlas = 'j_paradox_high_low',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 15 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_2 = false
            local has_ace_or_king = false
            for _, v in ipairs(context.scoring_hand) do
                local id = v:get_id()
                if id == 2 then has_2 = true end
                if id == 13 or id == 14 then has_ace_or_king = true end
            end
            if has_2 and has_ace_or_king then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 330. Cego que V (Seeing Blind)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_seeing_blind',
    atlas = 'j_paradox_seeing_blind',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 15 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.blind.boss then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 331. Pobre Rico (Rich Poor)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_rich_poor',
    atlas = 'j_paradox_rich_poor',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { threshold = 10, per_dollar = 1 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.per_dollar, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.dollars < card.ability.extra.threshold then
            local diff = card.ability.extra.threshold - math.max(0, G.GAME.dollars)
            local bonus = diff * card.ability.extra.per_dollar
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { bonus } },
                mult_mod = bonus,
                colour = G.C.MULT
            }
        end
    end
})

-- 332. Lento Rpido (Slow Fast)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_slow_fast',
    atlas = 'j_paradox_slow_fast',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 10 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played == 0 then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 333. Joker Pacifista (Pacifist Joker)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_pacifist_joker',
    atlas = 'j_paradox_pacifist_joker',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { x_mult = 1.2, active = false } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and card.ability.extra.active then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                x_mult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        if context.after and not context.blueprint then
            if G.GAME.chips < G.GAME.blind.chips then
                card.ability.extra.active = true
            else
                card.ability.extra.active = false
            end
        end
    end
})

-- 334. Paradoxo do Mentiroso (Liar's Paradox)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_liars_paradox',
    atlas = 'j_paradox_liars_paradox',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 20 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'High Card' then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 335. Inverso de Valor (Value Inversion)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_value_inversion',
    atlas = 'j_paradox_value_inversion',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { chip_mod = -10, ace_bonus = 20 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chip_mod, extra.ace_bonus } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_face() then
               return {
                   chips = card.ability.extra.chip_mod,
                   card = card
               }
            elseif context.other_card:get_id() == 14 then
                return {
                    chips = card.ability.extra.ace_bonus,
                    card = card
                }
            end
        end
    end
})

-- 336. Silncio Ruidoso (Loud Silence)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_loud_silence',
    atlas = 'j_paradox_loud_silence',
    rarity = 1,
    cost = 4,
    pos = { x = 0, y = 0 },
    config = { extra = { chips = 30 } },
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local face = false
            for _, v in ipairs(context.scoring_hand) do
                if v:is_face() then face = true end
            end
            
            if not face then
                return {
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } },
                    chip_mod = card.ability.extra.chips,
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- ============================================
-- PARADOX - Uncommon (Jokers 337-350)
-- ============================================

-- 337. Failure's Success
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_failures_success',
    config = { extra = { dollars = 10 } },
    rarity = 2,
    atlas = 'j_paradox_failures_success',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = false,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.game_over and not context.other_card then
            if G.GAME.chips < G.GAME.blind.chips then
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = localize('$') .. card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 338. Order of Chaos
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_order_of_chaos',
    config = { extra = { x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_paradox_order_of_chaos',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local is_straight = false
            if context.poker_hands and context.poker_hands['Straight'] and next(context.poker_hands['Straight']) then
                is_straight = true
            end
            
            if not is_straight then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 339. All or Nothing
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_all_or_nothing',
    config = { extra = { high_x_mult = 4, low_x_mult = 0.5, odds = 2 } },
    rarity = 2,
    atlas = 'j_paradox_all_or_nothing',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.high_x_mult, (G.GAME.probabilities.normal or 1), extra.odds, extra.low_x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('all_or_nothing') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.high_x_mult } },
                    x_mult_mod = card.ability.extra.high_x_mult,
                    colour = G.C.MULT
                }
            else
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.low_x_mult } },
                    x_mult_mod = card.ability.extra.low_x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 340. Zeno's Paradox
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_zenos_paradox',
    config = { extra = { x_mult = 8 } },
    rarity = 2,
    atlas = 'j_paradox_zenos_paradox',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                x_mult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
        if context.after and not context.blueprint then
            if card.ability.extra.x_mult > 1 then
                card.ability.extra.x_mult = card.ability.extra.x_mult / 2
                return {
                    message = localize('k_lower'),
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 341. Alive and Dead Cat
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_alive_and_dead_cat',
    config = { extra = { x_mult = 5 } },
    rarity = 2,
    atlas = 'j_paradox_alive_and_dead_cat',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.current_round.discards_left == 0 and G.GAME.current_round.hands_left == 1 then -- This is the last hand
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 342. Beginning of the End
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_beginning_of_the_end',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_paradox_beginning_of_the_end',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_left == 1 then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                x_mult_mod = card.ability.extra.x_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 343. Square Circle
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_square_circle',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_paradox_square_circle',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Logic handled in Card:is_suit override
    end
})

-- 344. Hot Cold
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_hot_cold',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_paradox_hot_cold',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Logic handled in Card:is_suit override
    end
})

-- 345. Past Future
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_past_future',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_paradox_past_future',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.odyssey_prev_round_1_hand then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    x_mult_mod = card.ability.extra.x_mult,
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- 346. False Truth
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_false_truth',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_paradox_false_truth',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_ceramic then
                 return {
                     mult = card.ability.extra.mult,
                     card = card
                 }
            end
        end
    end
})

-- 347. Mortal Immortal
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_mortal_immortal',
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_paradox_mortal_immortal',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_can_sell_eternal = true
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_can_sell_eternal = false
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Logic handled in overrides
    end
})

-- 348. Unlucky Luck
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_unlucky_luck',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_paradox_unlucky_luck',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_undead or
               context.other_card.config.center == G.P_CENTERS.m_odyssey_light or
               context.other_card.config.center == G.P_CENTERS.m_odyssey_magic then
                 return {
                     mult = card.ability.extra.mult,
                     card = card
                 }
            end
        end
    end
})

-- 349. Shrinking Growth
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_shrinking_growth',
    config = { extra = { mult = 50, loss = 2 } },
    rarity = 2,
    atlas = 'j_paradox_shrinking_growth',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.loss } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             return {
                 message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                 mult_mod = card.ability.extra.mult,
                 colour = G.C.MULT
             }
        end
        if context.end_of_round and not context.repetition and not context.game_over and not context.other_card then
            if card.ability.extra.mult > 0 then
                card.ability.extra.mult = math.max(0, card.ability.extra.mult - card.ability.extra.loss)
                return {
                    message = localize{ type = 'variable', key = 'a_mult_minus', vars = { card.ability.extra.loss } },
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 350. Polarity Reversal
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_paradox_polarity_reversal',
    config = { extra = { mult = 15, chips = 50 } },
    rarity = 2,
    atlas = 'j_paradox_polarity_reversal',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Spades') or context.other_card:is_suit('Clubs') then
                return {
                    mult = card.ability.extra.mult,
                    card = context.other_card
                }
            elseif context.other_card:is_suit('Hearts') or context.other_card:is_suit('Diamonds') then
                 return {
                    chips = card.ability.extra.chips,
                    card = context.other_card
                }
            end
        end
    end
})

-- local commons = require('src/jokers/33_paradox_common')

-- 351. Bootstrap Paradox
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_bootstrap_paradox',
    discovered = true,
    atlas = 'j_paradox_bootstrap_paradox',
    config = { extra = { x_mult = 1.5 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult
            }
        end
        
        -- Respawn logic: If end of round and we only have one, create another.
        if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
            local count = 0
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i].config.center.key == 'odyssey_j_paradox_bootstrap_paradox' then
                    count = count + 1
                end
            end
            
            if count < 2 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local card_copy = create_card('Joker', G.jokers, nil, nil, nil, nil, 'odyssey_j_paradox_bootstrap_paradox')
                        card_copy:add_to_deck()
                        G.jokers:emplace(card_copy)
                        card_copy:start_materialize()
                        play_sound('timpani')
                        return true
                    end
                }))
                return {
                    message = "Paradox!",
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 352. Chicken and Egg
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_chicken_egg',
    discovered = true,
    atlas = 'j_paradox_chicken_egg',
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
             if context.other_card == context.scoring_hand[1] then
                 return {
                     message = localize('k_again_ex'),
                     repetitions = 1,
                     card = card
                 }
             end
        end
    end
})

-- 353. Ship of Theseus
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_ship_of_theseus',
    discovered = true,
    atlas = 'j_paradox_ship_of_theseus',
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local clean_deck = true
            for k, v in pairs(G.playing_cards) do
                if v.config and v.config.center == G.P_CENTERS.c_base and not v.edition and not v.seal then
                    clean_deck = false
                    break
                end
            end
            
            if clean_deck then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end
        end
    end
})

-- 354. Fermi's Paradox
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_fermi_paradox',
    discovered = true,
    atlas = 'j_paradox_fermi_paradox',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.hands then
            local planets_used = false
            for k, v in pairs(G.GAME.hands) do
                if v.level > 1 then
                    planets_used = true
                    break
                end
            end
            
            if not planets_used then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end
        end
    end
})

-- 355. Evil Twin
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_evil_twin',
    discovered = true,
    atlas = 'j_paradox_evil_twin',
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local other_joker = nil
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then
                    other_joker = G.jokers.cards[i+1]
                    break
                end
            end
            
            if other_joker and other_joker ~= card then
                -- Protection against copying another Evil Twin or self
                if other_joker.config.center.key == 'odyssey_j_paradox_evil_twin' then return end

                context.blueprint = (context.blueprint or 0) + 1
                local ret = other_joker:calculate_joker(context)
                context.blueprint = (context.blueprint or 0) - 1
                
                if ret then
                    if ret.mult_mod then ret.mult_mod = -ret.mult_mod end
                    if ret.chip_mod then ret.chip_mod = -ret.chip_mod end
                    if ret.Xmult_mod then ret.Xmult_mod = 1 / ret.Xmult_mod end
                    ret.message = "Evil!"
                    ret.colour = G.C.BLACK
                    ret.card = card
                    return ret
                end
            end
        end
    end
})

-- 356. Anti-Joker
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_anti_joker',
    discovered = true,
    atlas = 'j_paradox_anti_joker',
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local t_chips = hand_chips
            local t_mult = mult
            
            -- Swap global values
            hand_chips = t_mult
            mult = t_chips
            
            update_hand_text({delay = 0}, {mult = mult, chips = hand_chips})
            
            return {
                message = "Swap!",
                colour = G.C.PURPLE,
                card = card
            }
        end
    end
})

-- 357. Reverse Logic
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_reverse_logic',
    discovered = true,
    atlas = 'j_paradox_reverse_logic',
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local current_hand = context.scoring_name
            local max_level = 0
            for k, v in pairs(G.GAME.hands) do
                if v.level > max_level then max_level = v.level end
            end
            
            local current_level = G.GAME.hands[current_hand].level
            if max_level > current_level then
                local diff = max_level - current_level
                local bonus_chips = G.GAME.hands[current_hand].l_chips * diff
                local bonus_mult = G.GAME.hands[current_hand].l_mult * diff
                
                return {
                     message = "Reverse!",
                     chip_mod = bonus_chips,
                     mult_mod = bonus_mult,
                     card = card
                }
            end
        end
    end
})

-- 358. Impossible
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_impossible',
    discovered = true,
    atlas = 'j_paradox_impossible',
    config = { extra = { x_mult = 100 } },
    rarity = 3,
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             local hand = context.scoring_hand
             if #hand == 5 then
                 local first_rank = hand[1].base.id
                 local same_rank = true
                 for i=2, 5 do
                     if hand[i].base.id ~= first_rank then
                         same_rank = false
                         break
                     end
                 end
                 
                 if same_rank then
                     local suits = {}
                     for i=1, 5 do
                         suits[hand[i].base.suit] = true
                     end
                     
                     local suit_count = 0
                     for k,v in pairs(suits) do suit_count = suit_count + 1 end
                     
                     if suit_count >= 5 then
                         return {
                             message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                             Xmult_mod = card.ability.extra.x_mult
                         }
                     end
                 end
             end
        end
    end
})

-- local commons = require('src/jokers/33_paradox_common')

-- 359. Ouroboros
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_ouroboros',
    discovered = true,
    atlas = 'j_paradox_ouroboros',
    config = { extra = { x_mult = 3 } },
    rarity = 4,
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                Xmult_mod = card.ability.extra.x_mult
            }
        end
        
        if context.end_of_round and not context.repetition and not context.blueprint and not context.other_card then
            if G.GAME.round_resets.ante >= 8 and G.GAME.blind.boss then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        if G.GAME.chips >= G.GAME.blind.chips then
                             -- Reset Ante to 1
                             G.GAME.round_resets.ante = 0 -- Becomes 1
                             G.GAME.round_resets.ante_scaling = (G.GAME.round_resets.ante_scaling or 1) * 1.5
                             play_sound('gold_seal', 1.2, 0.4)
                        end
                        return true
                    end
                }))
            end
        end
    end
})

-- 360. Grandfather Paradox
SMODS.Joker({
    unlocked = true,
    key = 'j_paradox_grandfather_paradox',
    discovered = true,
    atlas = 'j_paradox_grandfather_paradox',
    rarity = 4,
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.blueprint and not context.other_card then
            if G.GAME.chips < G.GAME.blind.chips then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        G.hand_text_area.blind_chips:juice_up()
                        G.hand_text_area.game_chips:juice_up()
                        play_sound('timpani')
                        return true
                    end
                })) 
                if not card.ability.eternal then card:start_dissolve() end
                return {
                    message = localize('k_saved_ex'),
                    saved = true,
                    colour = G.C.RED
                }
            end
        end
    end
})


local jokers = {
    -- 361. Spade Anomaly
    {
        key = 'j_anomaly_spade_anomaly',
        config = { extra = { mult = 10 } },
        rarity = 1,
        atlas = 'j_anomaly_spade_anomaly',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_spade_heart = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_spade_heart = nil
        end
    },
    -- 362. Heart Anomaly
    {
        key = 'j_anomaly_heart_anomaly',
        config = { extra = { mult = 10 } },
        rarity = 1,
        atlas = 'j_anomaly_heart_anomaly',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_heart_club = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_heart_club = nil
        end
    },
    -- 363. Club Anomaly
    {
        key = 'j_anomaly_club_anomaly',
        config = { extra = { mult = 10 } },
        rarity = 1,
        atlas = 'j_anomaly_club_anomaly',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_club_diamond = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_club_diamond = nil
        end
    },
    -- 364. Diamond Anomaly
    {
        key = 'j_anomaly_diamond_anomaly',
        config = { extra = { mult = 10 } },
        rarity = 1,
        atlas = 'j_anomaly_diamond_anomaly',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_diamond_spade = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_diamond_spade = nil
        end
    },
    -- 365. Rank Shift (Ases = 2s, 2s = Ases)
    {
        key = 'j_anomaly_rank_shift',
        config = { },
        rarity = 1,
        atlas = 'j_anomaly_rank_shift',
        cost = 4,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_rank_shift = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_rank_shift = nil
        end
    },
    -- 366. Numeric Inversion (Evens = Mult, Odds = Chips)
    {
        key = 'j_anomaly_numeric_inversion',
        config = { extra = { mult = 4, chips = 20 } },
        rarity = 1,
        atlas = 'j_anomaly_numeric_inversion',
        cost = 4,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.chips } }

        end,
        calculate = function(self, card, context)
            if context.individual and context.cardarea == G.play then
                if context.other_card:get_id() % 2 == 0 then
                    -- Even
                    return {
                        mult = card.ability.extra.mult,
                        card = card
                    }
                elseif context.other_card:get_id() % 2 ~= 0 then
                    -- Odd (includes Ace=14, Jack=11, King=13. Queen=12 is even)
                    return {
                        chips = card.ability.extra.chips,
                        card = card
                    }
                end
            end
        end
    },
    -- 367. Chromatic Anomaly
    {
        key = 'j_anomaly_chromatic_anomaly',
        config = { },
        rarity = 1,
        atlas = 'j_anomaly_chromatic_anomaly',
        cost = 6,
        add_to_deck = function(self, card, from_debuff)
            if not G.GAME.modifiers.odyssey_chromatic_rate then G.GAME.modifiers.odyssey_chromatic_rate = 1 end
            G.GAME.modifiers.odyssey_chromatic_rate = G.GAME.modifiers.odyssey_chromatic_rate + 2
        end,
        remove_from_deck = function(self, card, from_debuff)
            if G.GAME.modifiers.odyssey_chromatic_rate then
                G.GAME.modifiers.odyssey_chromatic_rate = G.GAME.modifiers.odyssey_chromatic_rate - 2
            end
        end
    },
    -- 368. Material Anomaly (Stone = Gold)
    {
        key = 'j_anomaly_material_anomaly',
        config = { extra = { money = 3 } },
        rarity = 1,
        atlas = 'j_anomaly_material_anomaly',
        cost = 5,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.money } }

        end,
        calculate = function(self, card, context)
            if context.individual and context.cardarea == G.play then
                if context.other_card.config.center == G.P_CENTERS.m_odyssey_emerald then
                    return {
                        dollars = card.ability.extra.money,
                        card = card
                    }
                end
            end
            -- Also Held
             if context.individual and context.end_of_round and context.cardarea == G.hand then
                 if context.other_card.config.center == G.P_CENTERS.m_odyssey_emerald then
                     return {
                         dollars = card.ability.extra.money,
                         card = card
                     }
                 end
             end
        end
    },
    -- 369. Anomalous Echo
    {
        key = 'j_anomaly_anomalous_echo',
        config = { },
        rarity = 1,
        atlas = 'j_anomaly_anomalous_echo',
        cost = 5,
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.repetition and context.cardarea == G.play then
                local scoring = context.scoring_hand
                if scoring and #scoring > 1 and context.other_card == scoring[#scoring] then
                    local first = scoring[1]
                    if not context.other_card:is_suit(first.base.suit) then
                        return {
                            message = localize('k_again_ex'),
                            repetitions = 1,
                            card = card
                        }
                    end
                end
            end
        end
    },
    -- 370. Phantom
    {
        key = 'j_anomaly_phantom',
        config = { extra = { mult = 20 } },
        rarity = 1,
        atlas = 'j_anomaly_phantom',
        cost = 6,
        blueprint_compat = true,
        eternal_compat = true,
        perishable_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        add_to_deck = function(self, card, from_debuff)
            if not from_debuff then
                G.jokers.config.card_limit = G.jokers.config.card_limit + 1
            end
        end,
        remove_from_deck = function(self, card, from_debuff)
            if not from_debuff then
                G.jokers.config.card_limit = G.jokers.config.card_limit - 1
            end
        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    },
    -- 371. Instability
    {
        key = 'j_anomaly_instability',
        config = { extra = { mult = 15, current_suit = 'Spades' } },
        rarity = 1,
        atlas = 'j_anomaly_instability',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, localize(extra.current_suit, 'suits_singular') } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local has_suit = false
                for _, playing_card in ipairs(context.scoring_hand) do
                    if playing_card:is_suit(card.ability.extra.current_suit) then
                        has_suit = true
                        break
                    end
                end
                
                if has_suit then
                    return {
                        mult_mod = card.ability.extra.mult,
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                    }
                end
            end
            if context.end_of_round and not context.repetition and not context.other_card then
                local suits = {'Spades', 'Hearts', 'Clubs', 'Diamonds'}
                card.ability.extra.current_suit = suits[pseudorandom('instability') % 4 + 1]
                return {
                    message = localize(card.ability.extra.current_suit, 'suits_singular'),
                    colour = G.C.ORANGE
                }
            end
        end
    },
    -- 372. Distortion
    {
        key = 'j_anomaly_distortion',
        config = { extra = { chips = 50 } },
        rarity = 1,
        atlas = 'j_anomaly_distortion',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    },
    -- 373. Interference
    {
        key = 'j_anomaly_interference',
        config = { extra = { mult = 10, bonus = 20 } },
        rarity = 1,
        atlas = 'j_anomaly_interference',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.bonus } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local bonus = card.ability.extra.mult
                local has_another = false
                for k, v in pairs(G.jokers.cards) do
                    if v ~= card and v.config.center.key and string.find(v.config.center.key, 'anomaly') then
                        has_another = true
                        break 
                    end
                end
                if has_another then
                    bonus = bonus + card.ability.extra.bonus
                end
                return {
                    mult_mod = bonus,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { bonus } }
                }
            end
        end
    },
    -- 374. Static Noise
    {
        key = 'j_anomaly_static_noise',
        config = { extra = { money = 5, odds = 4 } },
        rarity = 1,
        atlas = 'j_anomaly_static_noise',
        cost = 4,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.money, (G.GAME and G.GAME.probabilities.normal or 1), extra.odds } }

        end,
        calculate = function(self, card, context)
            if context.end_of_round and not context.repetition and not context.other_card then
                if pseudorandom('static_noise') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    return {
                        dollars = card.ability.extra.money,
                        message = localize('$')..card.ability.extra.money,
                        colour = G.C.MONEY
                    }
                end
            end
        end
    },
    -- 375. Lost Signal
    {
        key = 'j_anomaly_lost_signal',
        config = { extra = { hands = 1 } },
        rarity = 1,
        atlas = 'j_anomaly_lost_signal',
        cost = 6,
        blueprint_compat = false,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.hands } }

        end,
        calculate = function(self, card, context)
            if context.discard and not context.blueprint then
                if #context.full_hand == 5 then
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            ease_hands_played(card.ability.extra.hands)
                            return true
                        end
                    }))
                    return {
                        message = localize('k_upgrade_ex'),
                        colour = G.C.BLUE
                    }
                end
            end
        end
    },
    -- 376. Audio Glitch
    {
        key = 'j_anomaly_audio_glitch',
        config = { extra = { chips = 30 } },
        rarity = 1,
        atlas = 'j_anomaly_audio_glitch',
        cost = 4,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    }
}

for _, joker_def in ipairs(jokers) do
    joker_def.unlocked = true
    joker_def.discovered = true
    SMODS.Joker(joker_def)
end


local jokers = {
    -- 377. Gravitational Anomaly
    {
        key = 'j_anomaly_gravitational_anomaly',
        config = { extra = { mult = 20 } },
        rarity = 2,
        atlas = 'j_anomaly_gravitational_anomaly',
        cost = 6,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local low_ranks = true
                for _, playing_card in ipairs(context.scoring_hand) do
                    if playing_card:get_id() > 5 then
                        low_ranks = false
                        break
                    end
                end
                
                if low_ranks then
                    return {
                        message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                        mult_mod = card.ability.extra.mult,
                        colour = G.C.MULT
                    }
                end
            end
        end
    },
    -- 378. Temporal Anomaly
    {
        key = 'j_anomaly_temporal_anomaly',
        config = { },
        rarity = 2,
        atlas = 'j_anomaly_temporal_anomaly',
        cost = 8,
        blueprint_compat = false,
        calculate = function(self, card, context)
            if context.selling_self then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        play_sound('timpani')
                        G.GAME.blind:defeat()
                        return true
                    end
                })) 
            end
        end
    },
    -- 379. Spatial Anomaly
    {
        key = 'j_anomaly_spatial_anomaly',
        config = { extra = { hand_size = 2, joker_slot = 1 } },
        rarity = 2,
        atlas = 'j_anomaly_spatial_anomaly',
        cost = 6,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.hand_size, extra.joker_slot } }

        end,
        add_to_deck = function(self, card, from_debuff)
            G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size
            G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.joker_slot
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size
            G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.joker_slot
        end
    },
    -- 380. Unstable Wormhole
    {
        key = 'j_anomaly_unstable_wormhole',
        config = { extra = { x_mult = 2, odds = 10 } },
        rarity = 2,
        atlas = 'j_anomaly_unstable_wormhole',
        cost = 6,
        blueprint_compat = true,
        eternal_compat = true,
        perishable_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, (G.GAME and G.GAME.probabilities.normal or 1), extra.odds } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if not context.blueprint and not context.retrigger_joker then
                    if pseudorandom('wormhole') < G.GAME.probabilities.normal / card.ability.extra.odds then
                        local neighbors = {}
                        local my_pos = -1
                        for i, j in ipairs(G.jokers.cards) do
                            if j == card then my_pos = i; break end
                        end
                        if my_pos > 1 then table.insert(neighbors, G.jokers.cards[my_pos-1]) end
                        if my_pos < #G.jokers.cards then table.insert(neighbors, G.jokers.cards[my_pos+1]) end
                        
                        if #neighbors > 0 then
                            local target = neighbors[pseudorandom('wormhole_target') % #neighbors + 1]
                            if not target.ability.eternal then
                                target.getting_sliced = true
                                G.E_MANAGER:add_event(Event({func = function()
                                    target:start_dissolve()
                                return true end }))
                                card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_eaten_ex')})
                            end
                        end
                    end
                end
                
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end
        end
    },
    -- 381. Augmented Reality
    {
        key = 'j_anomaly_augmented_reality',
        config = { },
        rarity = 2,
        atlas = 'j_anomaly_augmented_reality',
        cost = 6,
        eternal_compat = true,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_glass_safe = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_glass_safe = nil
        end
    },
    -- 382. Simulation
    {
        key = 'j_anomaly_simulation',
        config = { extra = { x_mult = 4 } },
        rarity = 2,
        atlas = 'j_anomaly_simulation',
        cost = 7,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if G.GAME.current_round.odyssey_last_hand_ranks then
                    local current_ranks = ''
                    for _, c in ipairs(context.scoring_hand) do current_ranks = current_ranks .. c.base.id .. ',' end
                    
                    if current_ranks == G.GAME.current_round.odyssey_last_hand_ranks then
                        return {
                            message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                            Xmult_mod = card.ability.extra.x_mult
                        }
                    end
                end
            end
            if context.after and not context.blueprint then
                local current_ranks = ''
                for _, c in ipairs(context.scoring_hand) do current_ranks = current_ranks .. c.base.id .. ',' end
                G.GAME.current_round.odyssey_last_hand_ranks = current_ranks
            end
        end
    },
    -- 383. Broken Code
    {
        key = 'j_anomaly_broken_code',
        config = { extra = { chips = 100 } },
        rarity = 2,
        atlas = 'j_anomaly_broken_code',
        cost = 5,
        blueprint_compat = true,
        eternal_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.chips } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                 return {
                    chip_mod = card.ability.extra.chips,
                    message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    },
    -- 384. Hidden Variable
    {
        key = 'j_anomaly_hidden_variable',
        config = { extra = { x_mult = 0.5 } },
        rarity = 2,
        atlas = 'j_anomaly_hidden_variable',
        cost = 6,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                local count = 0
                for _, v in pairs(G.jokers.cards) do
                    if v.config.center.key and string.find(v.config.center.key, 'anomaly') then
                        count = count + 1
                    end
                end
                
                local total_xmult = 1 + (count * card.ability.extra.x_mult)
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { total_xmult } },
                    Xmult_mod = total_xmult
                }
            end
        end
    },
    -- 385. Unhandled Exception
    {
        key = 'j_anomaly_unhandled_exception',
        config = { extra = { money = 10 } },
        rarity = 2,
        atlas = 'j_anomaly_unhandled_exception',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.money } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if G.GAME.current_round.discards_left <= 0 then
                     return {
                        dollars = card.ability.extra.money,
                        message = localize('$')..card.ability.extra.money,
                        colour = G.C.MONEY
                     }
                end
            end
        end
    },
    -- 386. Buffer Overflow
    {
        key = 'j_anomaly_buffer_overflow',
        config = { },
        rarity = 2,
        atlas = 'j_anomaly_buffer_overflow',
        cost = 6,
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.repetition and context.cardarea == G.play then
                if #G.play.cards == 5 then
                    local middle_card = G.play.cards[3]
                    if context.other_card == middle_card then
                        return {
                            message = localize('k_again_ex'),
                            repetitions = 2,
                            card = card
                        }
                    end
                end
            end
        end
    },
    -- 387. Memory Dump
    {
        key = 'j_anomaly_memory_dump',
        config = { },
        rarity = 2,
        atlas = 'j_anomaly_memory_dump',
        cost = 4,
        calculate = function(self, card, context)
            if context.selling_self then
                G.E_MANAGER:add_event(Event({
                    func = function() 
                        for i=1, 3 do
                            local _card = create_card('Base', G.pack_cards, nil, nil, true, true, nil, 'memdump')
                            _card:add_to_deck()
                            G.hand:emplace(_card)
                        end
                        return true
                    end
                }))
            end
        end
    },
    -- 388. Race Condition
    {
        key = 'j_anomaly_race_condition',
        config = { extra = { mult = 50, seconds = 5 } },
        rarity = 2,
        atlas = 'j_anomaly_race_condition',
        cost = 6,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.mult, extra.seconds } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                    mult_mod = card.ability.extra.mult,
                    colour = G.C.MULT
                }
            end
        end
    },
    -- 389. Deadlock
    {
        key = 'j_anomaly_deadlock',
        config = { extra = { x_mult = 3 } },
        rarity = 2,
        atlas = 'j_anomaly_deadlock',
        cost = 6,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if G.GAME.current_round.discards_left == 0 and G.GAME.current_round.hands_left == 0 then
                    return {
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                        Xmult_mod = card.ability.extra.x_mult
                    }
                end
            end
        end
    },
    -- 390. Heisenbug
    {
        key = 'j_anomaly_heisenbug',
        config = { extra = { mult = 15, chips = 100, dollars = 5, mode = 1 } },
        rarity = 2,
        atlas = 'j_anomaly_heisenbug',
        cost = 5,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)
            local modes = {"Mult", "Chips", "Money"}
            return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult, ( (card and card.ability and card.ability.extra) or self.config.extra ).chips, ( (card and card.ability and card.ability.extra) or self.config.extra ).dollars, modes[( (card and card.ability and card.ability.extra) or self.config.extra ).mode] } }
        end,
        calculate = function(self, card, context)
             if context.end_of_round and not context.repetition and not context.other_card then
                 card.ability.extra.mode = pseudorandom('heisenbug') % 3 + 1
                 return { message = 'Glitch!', colour = G.C.RED }
             end
             
             if context.joker_main then
                 if card.ability.extra.mode == 1 then
                     return { mult_mod = card.ability.extra.mult, message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } } }
                 elseif card.ability.extra.mode == 2 then
                     return { chip_mod = card.ability.extra.chips, message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } } }
                 else
                     return { dollars = card.ability.extra.dollars, message = localize('$')..card.ability.extra.dollars, colour = G.C.MONEY }
                 end
             end
        end
    }
}

for _, joker_def in ipairs(jokers) do
    joker_def.unlocked = true
    joker_def.discovered = true
    SMODS.Joker(joker_def)
end

local jokers = {
    -- 391. The Monolith
    {
        key = 'j_anomaly_the_monolith',
        config = { extra = { x_mult = 4 } },
        rarity = 3,
        atlas = 'j_anomaly_the_monolith',
        cost = 8,
        blueprint_compat = true,
        eternal_compat = true,
        perishable_compat = false,
        add_to_deck = function(self, card, from_debuff)
            if not from_debuff then
                card.ability.eternal = true
            end
        end,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end
        end
    },
    -- 392. Primordial Anomaly
    {
        key = 'j_anomaly_primordial_anomaly',
        config = { },
        rarity = 3,
        atlas = 'j_anomaly_primordial_anomaly',
        cost = 8,
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
                if G.GAME.blind.boss and G.GAME.current_round.discards_used == 0 then
                    G.E_MANAGER:add_event(Event({
                        func = function() 
                            local card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, 'c_soul', 'primordial')
                            card:add_to_deck()
                            G.consumeables:emplace(card)
                            return true
                        end
                    }))
                    return {
                        message = localize('k_soul_ex'),
                        colour = G.C.PURPLE
                    }
                end
            end
        end
    },
    -- 393. Reality Rift
    {
        key = 'j_anomaly_reality_rift',
        config = { extra = { consumable = 1, joker = 1 } },
        rarity = 3,
        atlas = 'j_anomaly_reality_rift',
        cost = 8,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.consumable, extra.joker } }

        end,
        add_to_deck = function(self, card, from_debuff)
            if not from_debuff then
                G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra.consumable
                G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.joker
            end
        end,
        remove_from_deck = function(self, card, from_debuff)
            if not from_debuff then
                G.consumeables.config.card_limit = G.consumeables.config.card_limit - card.ability.extra.consumable
                G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.joker
            end
        end
    },
    -- 394. Mirror Universe
    {
        key = 'j_anomaly_mirror_universe',
        config = { },
        rarity = 3,
        atlas = 'j_anomaly_mirror_universe',
        cost = 8,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_mirror_universe = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_mirror_universe = nil
        end
    },
    -- 395. Strange Matter
    {
        key = 'j_anomaly_strange_matter',
        config = { },
        rarity = 3,
        atlas = 'j_anomaly_strange_matter',
        cost = 8,
        blueprint_compat = true,
        calculate = function(self, card, context)
            if context.before and not context.blueprint then
                 for _, c in ipairs(context.scoring_hand) do
                    c:set_ability(G.P_CENTERS.m_odyssey_plastic)
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            c:juice_up()
                            return true
                        end
                    }))
                 end
                 return {
                    message = localize('k_gold'),
                    colour = G.C.MONEY
                 }
            end
        end
    },
    -- 396. Phantom Energy
    {
        key = 'j_anomaly_phantom_energy',
        config = { extra = { consumable = 1, joker = 1, hand = 2 } },
        rarity = 3,
        atlas = 'j_anomaly_phantom_energy',
        cost = 8,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.consumable, extra.joker, extra.hand } }

        end,
        add_to_deck = function(self, card, from_debuff)
            if not from_debuff then
                G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra.consumable
                G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.joker
                G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand
            end
        end,
        remove_from_deck = function(self, card, from_debuff)
            if not from_debuff then
                G.consumeables.config.card_limit = G.consumeables.config.card_limit - card.ability.extra.consumable
                G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.joker
                G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand
            end
        end
    },
    -- 397. Function Collapse
    {
        key = 'j_anomaly_function_collapse',
        config = { extra = { x_mult = 3 } },
        rarity = 3,
        atlas = 'j_anomaly_function_collapse',
        cost = 8,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                 return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end
        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_faceless_suits = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_faceless_suits = nil
        end
    },
    -- 398. Parity Error
    {
        key = 'j_anomaly_parity_error',
        config = { extra = { money = 20 } },
        rarity = 3,
        atlas = 'j_anomaly_parity_error',
        cost = 8,
        blueprint_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.money } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                if #context.scoring_hand == 5 then
                    local odds = 0
                    local evens = 0
                    for _, c in ipairs(context.scoring_hand) do
                        if c:get_id() % 2 == 0 then evens = evens + 1 else odds = odds + 1 end
                    end
                    
                    if evens == 5 or odds == 5 then
                        return {
                            dollars = card.ability.extra.money,
                            message = localize('$')..card.ability.extra.money,
                            colour = G.C.MONEY
                        }
                    end
                end
            end
        end
    }
}

for _, joker_def in ipairs(jokers) do
    joker_def.unlocked = true
    joker_def.discovered = true
    SMODS.Joker(joker_def)
end


local jokers = {
    -- 399. The Watcher
    {
        key = 'j_anomaly_the_watcher',
        config = { extra = { x_mult = 3 } },
        rarity = 4,
        atlas = 'j_anomaly_the_watcher',
        cost = 20,
        blueprint_compat = true,
        eternal_compat = true,
        perishable_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end
        end,
        add_to_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_reveal_deck = true
        end,
        remove_from_deck = function(self, card, from_debuff)
            G.GAME.modifiers.odyssey_reveal_deck = nil
        end
    },
    -- 400. Fatal Error
    {
        key = 'j_anomaly_fatal_error',
        config = { extra = { x_mult = 10, money = 100 } },
        rarity = 4,
        atlas = 'j_anomaly_fatal_error',
        cost = 20,
        blueprint_compat = true,
        eternal_compat = true,
        perishable_compat = true,
        loc_vars = function(self, info_queue, card)

            local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

            return { vars = { extra.x_mult, extra.money } }

        end,
        calculate = function(self, card, context)
            if context.joker_main then
                return {
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } },
                    Xmult_mod = card.ability.extra.x_mult
                }
            end

            if context.end_of_round and not context.repetition and not context.other_card then
                if not context.blueprint then
                    local deletable_jokers = {}
                    for _, j in ipairs(G.jokers.cards) do
                        if not j.ability.eternal and j ~= card then
                            table.insert(deletable_jokers, j)
                        end
                    end
                    if #deletable_jokers > 0 then
                        local target = deletable_jokers[pseudorandom('fatal_error') % #deletable_jokers + 1]
                        target.getting_sliced = true
                        G.E_MANAGER:add_event(Event({func = function()
                            target:start_dissolve()
                        return true end }))
                    end
                end

                return {
                    dollars = card.ability.extra.money,
                    message = localize('$')..card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
    }
}

for _, joker_def in ipairs(jokers) do
    joker_def.unlocked = true
    joker_def.discovered = true
    SMODS.Joker(joker_def)
end


-- ============================================
-- ELEMENTAL - Common (Jokers 401-420)
-- ============================================

-- 401. Eternal Flame
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_eternal_flame',
    discovered = true,
    config = { extra = { mult = 4 } },
    rarity = 1,
    atlas = 'j_elemental_eternal_flame',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Hearts") then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 402. Raindrop
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_raindrop',
    discovered = true,
    config = { extra = { chips = 20 } },
    rarity = 1,
    atlas = 'j_elemental_raindrop',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Spades") then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
    end
})

-- 403. Runestone
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_runestone',
    discovered = true,
    config = { extra = { mult = 4 } },
    rarity = 1,
    atlas = 'j_elemental_runestone',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Diamonds") then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 404. Gentle Breeze
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_gentle_breeze',
    discovered = true,
    config = { extra = { chips = 20 } },
    rarity = 1,
    atlas = 'j_elemental_gentle_breeze',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Clubs") then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
    end
})

-- 405. Inferno
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_inferno',
    discovered = true,
    config = { extra = { mult = 15, perma_mult = 0, gain = 2 } },
    rarity = 1,
    atlas = 'j_elemental_inferno',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) 
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult, ( (card and card.ability and card.ability.extra) or self.config.extra ).perma_mult, ( (card and card.ability and card.ability.extra) or self.config.extra ).gain } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local total_mult = card.ability.extra.mult + card.ability.extra.perma_mult
            return {
                mult_mod = total_mult,
                message = localize{type='variable', key='a_mult', vars={total_mult}}
            }
        end
        if context.before and not context.blueprint then
            local hearts = 0
            for i=1, #context.scoring_hand do 
                if context.scoring_hand[i]:is_suit("Hearts") then hearts = hearts + 1 end 
            end
            if hearts >= 5 then
                card.ability.extra.perma_mult = card.ability.extra.perma_mult + card.ability.extra.gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
    end
})

-- 406. Tsunami
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_tsunami',
    discovered = true,
    config = { extra = { chips = 50, perma_chips = 0, gain = 10 } },
    rarity = 1,
    atlas = 'j_elemental_tsunami',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) 
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).chips, ( (card and card.ability and card.ability.extra) or self.config.extra ).perma_chips, ( (card and card.ability and card.ability.extra) or self.config.extra ).gain } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local total_chips = card.ability.extra.chips + card.ability.extra.perma_chips
            return {
                chip_mod = total_chips,
                message = localize{type='variable', key='a_chips', vars={total_chips}}
            }
        end
        if context.before and not context.blueprint then
            local spades = 0
            for i=1, #context.scoring_hand do 
                if context.scoring_hand[i]:is_suit("Spades") then spades = spades + 1 end 
            end
            if spades >= 5 then
                card.ability.extra.perma_chips = card.ability.extra.perma_chips + card.ability.extra.gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.CHIPS,
                    card = card
                }
            end
        end
    end
})

-- 407. Earthquake
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_earthquake',
    discovered = true,
    config = { extra = { mult = 10, dollars = 2 } },
    rarity = 1,
    atlas = 'j_elemental_earthquake',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).dollars } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
        if context.discard and not context.blueprint then
            if context.other_card:is_suit("Diamonds") then
                ease_dollars(card.ability.extra.dollars)
                if not context.other_card.ability.eternal then context.other_card:start_dissolve() end
                return {
                    message = localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 408. Tornado
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_tornado',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_elemental_tornado',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
        if (context.after or context.discard) and not context.blueprint then
             G.FUNCS.sort_hand_suit(nil)
        end
    end
})

-- 409. Volcano
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_volcano',
    discovered = true,
    config = { extra = { odds = 4, x_mult = 2 } },
    rarity = 1,
    atlas = 'j_elemental_volcano',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds, ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Hearts") then
                if pseudorandom('volcano') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    if not context.other_card.ability.eternal then context.other_card:start_dissolve() end
                    return {
                        x_mult = card.ability.extra.x_mult,
                        card = card
                    }
                end
            end
        end
    end
})

-- 410. Iceberg
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_iceberg',
    discovered = true,
    config = { extra = { chips = 10, mult = 2 } },
    rarity = 1,
    atlas = 'j_elemental_iceberg',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips, (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Spades") then
                return {
                    chips = card.ability.extra.chips,
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 411. Lightning
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_lightning',
    discovered = true,
    config = { extra = { mult = 30 } },
    rarity = 1,
    atlas = 'j_elemental_lightning',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local clubs = false
            local diamonds = false
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit("Clubs") then clubs = true end
                if context.scoring_hand[i]:is_suit("Diamonds") then diamonds = true end
            end
            if clubs and diamonds then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
                }
            end
        end
    end
})

-- 412. Magma
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_magma',
    discovered = true,
    config = { extra = { } },
    rarity = 1,
    atlas = 'j_elemental_magma',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_magma_active = true
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_magma_active = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 413. Mud
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_mud',
    discovered = true,
    config = { extra = { } },
    rarity = 1,
    atlas = 'j_elemental_mud',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_mud_active = true
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.modifiers.odyssey_mud_active = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 414. Ember
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_ember',
    discovered = true,
    config = { extra = { mult = 5, gain = 1 } },
    rarity = 1,
    atlas = 'j_elemental_ember',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).gain } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
        if context.before and not context.blueprint then
            if context.scoring_name == "Flush" then
                local hearts = true
                for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Hearts") then hearts = false end end
                if hearts then
                    card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
                    return {
                        message = localize('k_upgrade_ex'),
                        colour = G.C.MULT
                    }
                end
            end
        end
    end
})

-- 415. Dew
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_dew',
    discovered = true,
    config = { extra = { chips = 20, gain = 5 } },
    rarity = 1,
    atlas = 'j_elemental_dew',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips, (( (card and card.ability and card.ability.extra) or self.config.extra )).gain } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize{type='variable', key='a_chips', vars={card.ability.extra.chips}}
            }
        end
        if context.before and not context.blueprint then
            if context.scoring_name == "Flush" then
                local spades = true
                for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Spades") then spades = false end end
                if spades then
                    card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.gain
                    return {
                        message = localize('k_upgrade_ex'),
                        colour = G.C.CHIPS
                    }
                end
            end
        end
    end
})

-- 416. Crystal
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_crystal',
    discovered = true,
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    atlas = 'j_elemental_crystal',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local only_diamonds = true
            for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Diamonds") then only_diamonds = false end end
            if only_diamonds then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 417. Smoke
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_smoke',
    discovered = true,
    config = { extra = { odds = 3 } },
    rarity = 1,
    atlas = 'j_elemental_smoke',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } } end,
    calculate = function(self, card, context)
        if context.before and G.GAME.blind.boss and not G.GAME.blind.disabled then
            local clubs = false
            for i=1, #context.scoring_hand do if context.scoring_hand[i]:is_suit("Clubs") then clubs = true end end
            if clubs and pseudorandom('smoke') < G.GAME.probabilities.normal / card.ability.extra.odds then
                G.GAME.blind:disable()
                return {
                    message = localize('k_safe_ex'),
                    colour = G.C.FILTER,
                    card = card
                }
            end
        end
    end
})

-- 418. Spark
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_spark',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_elemental_spark',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played == 0 then
            local red = true
            for i=1, #context.scoring_hand do 
                if not (context.scoring_hand[i]:is_suit("Hearts") or context.scoring_hand[i]:is_suit("Diamonds")) then red = false end 
            end
            if red then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
                }
            end
        end
    end
})

-- 419. Wave
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_wave',
    discovered = true,
    config = { extra = { chips = 40 } },
    rarity = 1,
    atlas = 'j_elemental_wave',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played == 0 then
            local black = true
            for i=1, #context.scoring_hand do 
                if not (context.scoring_hand[i]:is_suit("Spades") or context.scoring_hand[i]:is_suit("Clubs")) then black = false end 
            end
            if black then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize{type='variable', key='a_chips', vars={card.ability.extra.chips}}
                }
            end
        end
    end
})

-- 420. Ash
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_ash',
    discovered = true,
    config = { extra = { dollars = 3 } },
    rarity = 1,
    atlas = 'j_elemental_ash',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).dollars } } end,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            local red_count = 0
            for i=1, #context.full_hand do
                if context.full_hand[i]:is_suit("Hearts") or context.full_hand[i]:is_suit("Diamonds") then
                    red_count = red_count + 1
                end
            end
            if red_count >= 5 then
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})



-- ============================================
-- ELEMENTAL - Uncommon (Jokers 421-438)
-- ============================================

-- 421. Fire Spirit
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_fire_spirit',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_elemental_fire_spirit',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Flush" then
            local hearts = true
            for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Hearts") then hearts = false end end
            if hearts then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 422. Water Spirit
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_water_spirit',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_elemental_water_spirit',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Flush" then
            local spades = true
            for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Spades") then spades = false end end
            if spades then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 423. Earth Spirit
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_earth_spirit',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_elemental_earth_spirit',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Flush" then
            local diamonds = true
            for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Diamonds") then diamonds = false end end
            if diamonds then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 424. Air Spirit
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_air_spirit',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_elemental_air_spirit',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Flush" then
            local clubs = true
            for i=1, #context.scoring_hand do if not context.scoring_hand[i]:is_suit("Clubs") then clubs = false end end
            if clubs then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 425. Elemental Fusion
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_elemental_fusion',
    discovered = true,
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_elemental_elemental_fusion',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {Hearts=false, Spades=false, Diamonds=false, Clubs=false}
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit("Hearts") then suits.Hearts = true end
                if context.scoring_hand[i]:is_suit("Spades") then suits.Spades = true end
                if context.scoring_hand[i]:is_suit("Diamonds") then suits.Diamonds = true end
                if context.scoring_hand[i]:is_suit("Clubs") then suits.Clubs = true end
            end
            local count = 0
            for _, v in pairs(suits) do if v then count = count + 1 end end
            if count >= 4 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 426. Steam
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_steam',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_elemental_steam',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local hearts = false
            local spades = false
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit("Hearts") then hearts = true end
                if context.scoring_hand[i]:is_suit("Spades") then spades = true end
            end
            if hearts and spades then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
                }
            end
        end
    end
})

-- 427. Lava
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_lava',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_elemental_lava',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local hearts = false
            local diamonds = false
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit("Hearts") then hearts = true end
                if context.scoring_hand[i]:is_suit("Diamonds") then diamonds = true end
            end
            if hearts and diamonds then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
                }
            end
        end
    end
})

-- 428. Sandstorm
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_sandstorm',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_elemental_sandstorm',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local diamonds = false
            local clubs = false
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit("Diamonds") then diamonds = true end
                if context.scoring_hand[i]:is_suit("Clubs") then clubs = true end
            end
            if diamonds and clubs then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
                }
            end
        end
    end
})

-- 429. Storm
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_storm',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_elemental_storm',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local spades = false
            local clubs = false
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit("Spades") then spades = true end
                if context.scoring_hand[i]:is_suit("Clubs") then clubs = true end
            end
            if spades and clubs then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
                }
            end
        end
    end
})

-- 430. Element Master
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_element_master',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 2,
    atlas = 'j_elemental_element_master',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            for k, v in ipairs(G.playing_cards) do suits[v.base.suit] = true end
            local count = 0
            for _ in pairs(suits) do count = count + 1 end
            return {
                mult_mod = count * card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={count * card.ability.extra.mult}}
            }
        end
    end
})

-- 431. Prism
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_prism',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_elemental_prism',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.edition and context.other_card.edition.polychrome then
                return {
                    x_mult = card.ability.extra.x_mult,
                    card = card
                }
            end
        end
    end
})

-- 432. Aether
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_aether',
    discovered = true,
    config = { extra = { mult = 50 } },
    rarity = 2,
    atlas = 'j_elemental_aether',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_emerald then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 433. Plasma
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_plasma',
    discovered = true,
    config = { extra = { x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_elemental_plasma',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit("Hearts") or context.other_card:is_suit("Spades") then
                return {
                    x_mult = card.ability.extra.x_mult,
                    card = card
                }
            end
        end
    end
})

-- 434. Geode
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_geode',
    discovered = true,
    config = { extra = { odds = 3, dollars = 5, mult = 20 } },
    rarity = 2,
    atlas = 'j_elemental_geode',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds, ( (card and card.ability and card.ability.extra) or self.config.extra ).dollars, ( (card and card.ability and card.ability.extra) or self.config.extra ).mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_emerald then
                if pseudorandom('geode') < G.GAME.probabilities.normal / card.ability.extra.odds then
                    if pseudorandom('geode_type') < 0.5 then
                        ease_dollars(card.ability.extra.dollars)
                        return {
                            message = localize('$')..card.ability.extra.dollars,
                            colour = G.C.MONEY,
                            card = card
                        }
                    else
                        return {
                            mult = card.ability.extra.mult,
                            card = card
                        }
                    end
                end
            end
        end
    end
})

-- 435. Thunderbolt
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_thunderbolt',
    discovered = true,
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_elemental_thunderbolt',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.before and context.scoring_name == "Straight Flush" then
            if #context.scoring_hand >= 3 then
                local middle = math.ceil(#context.scoring_hand / 2)
                local target = context.scoring_hand[middle]
                if not target.ability.eternal then
                    target:start_dissolve()
                end
            end
        end
        if context.joker_main and context.scoring_name == "Straight Flush" then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                card = card
            }
        end
    end
})

-- 436. Blizzard
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_blizzard',
    discovered = true,
    config = { extra = {} },
    rarity = 2,
    atlas = 'j_elemental_blizzard',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local spades = 0
            for i=1, #context.scoring_hand do if context.scoring_hand[i]:is_suit("Spades") then spades = spades + 1 end end
            if spades >= 5 then
                G.GAME.modifiers.odyssey_blizzard_frozen = true
                return {
                    message = "Frozen!",
                    colour = G.C.FILTER,
                    card = card
                }
            end
        end
    end
})

-- 437. Fire Meteor
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_fire_meteor',
    discovered = true,
    config = { extra = { chips = 100, mult = 10 } },
    rarity = 2,
    atlas = 'j_elemental_fire_meteor',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips, (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local hearts_in_hand = 0
            for i=1, #G.hand.cards do if G.hand.cards[i]:is_suit("Hearts") then hearts_in_hand = hearts_in_hand + 1 end end
            local bonus_mult = hearts_in_hand * card.ability.extra.mult
            return {
                chip_mod = card.ability.extra.chips,
                mult_mod = bonus_mult,
                message = localize{type='variable', key='a_mult', vars={bonus_mult}}
            }
        end
    end
})

-- 438. Garden
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_garden',
    discovered = true,
    config = { extra = { bonus = 1 } },
    rarity = 2,
    atlas = 'j_elemental_garden',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).bonus } } end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.blueprint then
            for i=1, #G.hand.cards do
                if G.hand.cards[i]:is_suit("Diamonds") then
                    local c = G.hand.cards[i]
                    c.ability.perma_bonus = (c.ability.perma_bonus or 0) + card.ability.extra.bonus
                    c:juice_up()
                end
            end
            return {
                message = "Grown!",
                colour = G.C.CHIPS
            }
        end
    end
})


-- ============================================
-- ELEMENTAL - Rare (Jokers 439-448)
-- ============================================

-- 439. Phoenix
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_phoenix',
    discovered = true,
    config = { extra = { mult = 0, gain = 1 } },
    rarity = 3,
    atlas = 'j_elemental_phoenix',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).gain } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
        if context.discard and not context.blueprint then
             local hearts = 0
             for i=1, #context.full_hand do if context.full_hand[i]:is_suit("Hearts") then hearts = hearts + 1 end end
             if hearts >= 5 then
                 card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
                 return {
                     message = localize('k_upgrade_ex'),
                     colour = G.C.MULT
                 }
             end
        end
    end
})

-- 440. Leviathan
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_leviathan',
    discovered = true,
    config = { extra = { hands = 1 } },
    rarity = 3,
    atlas = 'j_elemental_leviathan',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and context.scoring_name == "Flush" then
            local spades = 0
            for i=1, #context.scoring_hand do if context.scoring_hand[i]:is_suit("Spades") then spades = spades + 1 end end
            if spades >= 5 then
                ease_hands_played(card.ability.extra.hands)
                return {
                    message = "+"..card.ability.extra.hands.." Hand",
                    colour = G.C.BLUE
                }
            end
        end
    end
})

-- 441. Behemoth
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_behemoth',
    discovered = true,
    config = { extra = { slots = 1 } },
    rarity = 3,
    atlas = 'j_elemental_behemoth',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and context.scoring_name == "Flush" then
            local diamonds = 0
            for i=1, #context.scoring_hand do if context.scoring_hand[i]:is_suit("Diamonds") then diamonds = diamonds + 1 end end
            if diamonds >= 5 and not context.blueprint then
                G.GAME.modifiers.odyssey_behemoth_slots = (G.GAME.modifiers.odyssey_behemoth_slots or 0) + card.ability.extra.slots
                G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.slots
                return {
                    message = "+1 Slot!",
                    colour = G.C.JOKER_GREY,
                    card = card
                }
            end
        end
        if context.end_of_round and not context.other_card and not context.blueprint then
            if G.GAME.modifiers.odyssey_behemoth_slots and G.GAME.modifiers.odyssey_behemoth_slots > 0 then
                G.jokers.config.card_limit = G.jokers.config.card_limit - G.GAME.modifiers.odyssey_behemoth_slots
                G.GAME.modifiers.odyssey_behemoth_slots = 0
            end
        end
    end
})

-- 442. Ziz
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_ziz',
    discovered = true,
    config = { extra = { discards = 1, dollars = 5 } },
    rarity = 3,
    atlas = 'j_elemental_ziz',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and context.scoring_name == "Flush" then
            local clubs = 0
            for i=1, #context.scoring_hand do if context.scoring_hand[i]:is_suit("Clubs") then clubs = clubs + 1 end end
            if clubs >= 5 then
                ease_discard(card.ability.extra.discards)
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = "+1 Discard / $5",
                    colour = G.C.GREEN
                }
            end
        end
    end
})

-- 443. Fifth Element
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_fifth_element',
    discovered = true,
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    atlas = 'j_elemental_fifth_element',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local elements = { fire=false, water=false, earth=false, air=false }
            for i = 1, #G.jokers.cards do
                local j = G.jokers.cards[i]
                if j.config.center.key == 'j_elemental_fire_spirit' or j.config.center.key == 'odyssey_j_elemental_fire_spirit' then elements.fire = true end
                if j.config.center.key == 'j_elemental_water_spirit' or j.config.center.key == 'odyssey_j_elemental_water_spirit' then elements.water = true end
                if j.config.center.key == 'j_elemental_earth_spirit' or j.config.center.key == 'odyssey_j_elemental_earth_spirit' then elements.earth = true end
                if j.config.center.key == 'j_elemental_air_spirit' or j.config.center.key == 'odyssey_j_elemental_air_spirit' then elements.air = true end
            end
            local count = 0
            for _, v in pairs(elements) do if v then count = count + 1 end end
            if count >= 4 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
                }
            end
        end
    end
})

-- 444. Master Alchemist
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_master_alchemist',
    discovered = true,
    config = { extra = {} },
    rarity = 3,
    atlas = 'j_elemental_master_alchemist',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.setting_blind and G.GAME.blind.boss and not context.blueprint then
            for i=1, #G.hand.cards do
                local c = G.hand.cards[i]
                local new_base = 'D_' .. (c.base.value == '10' and 'T' or string.sub(c.base.value, 1, 1))
                if c.base.value == 'Ace' then new_base = 'D_A' end
                if c.base.value == 'Jack' then new_base = 'D_J' end
                if c.base.value == 'Queen' then new_base = 'D_Q' end
                if c.base.value == 'King' then new_base = 'D_K' end
                -- Safe way:
                local rank = c.base.value
                local suit = 'Diamonds'
                c:set_base(G.P_CARDS[suit .. '_' .. rank])
            end
            return {
                message = "Golden Hand!",
                colour = G.C.MONEY
            }
        end
    end
})

-- 445. Heart of the World
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_heart_of_the_world',
    discovered = true,
    config = { extra = { x_mult = 3, odyssey_suit_immune = true } },
    rarity = 3,
    atlas = 'j_elemental_heart_of_the_world',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
            }
        end
        if context.setting_blind then
            G.GAME.modifiers.odyssey_suit_immune = true
        end
    end
})

-- 446. Neutron Star
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_neutron_star',
    discovered = true,
    config = { extra = { mult = 20 } },
    rarity = 3,
    atlas = 'j_elemental_neutron_star',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local c = context.other_card
            if c.config.center == G.P_CENTERS.m_odyssey_platinum or c.config.center == G.P_CENTERS.m_odyssey_plastic or c.config.center == G.P_CENTERS.m_odyssey_emerald then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 447. Superconductor
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_superconductor',
    discovered = true,
    config = { extra = {} },
    rarity = 3,
    atlas = 'j_elemental_superconductor',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_plastic then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- 448. Absolute Zero
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_absolute_zero',
    discovered = true,
    config = { extra = { x_mult = 10, next_hand_active = false } },
    rarity = 3,
    atlas = 'j_elemental_absolute_zero',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and card.ability.extra.next_hand_active then
            card.ability.extra.next_hand_active = false
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
            }
        end
        if context.after and not context.blueprint then
            if G.GAME.chips - G.GAME.chips_at_start_of_hand == 0 then
                card.ability.extra.next_hand_active = true
            end
        end
    end
})


-- ============================================
-- ELEMENTAL - Legendary (Jokers 449-450)
-- ============================================

-- 449. Avatar
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_avatar',
    discovered = true,
    config = { extra = { x_mult = 4 } },
    rarity = 4,
    atlas = 'j_elemental_avatar',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
            }
        end
        if context.setting_blind then
            G.GAME.modifiers.odyssey_any_flush = true
        end
    end
})

-- 450. Cataclysm
SMODS.Joker({
    unlocked = true,
    key = 'j_elemental_cataclysm',
    discovered = true,
    config = { extra = { x_mult = 10 } },
    rarity = 4,
    atlas = 'j_elemental_cataclysm',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}}
            }
        end
        if context.buy_joker and not context.blueprint then
            local suits = {"Hearts", "Spades", "Diamonds", "Clubs"}
            local target_suit = suits[pseudorandom('cataclysm') % 4 + 1]
            local cards_to_destroy = {}
            for i = 1, #G.playing_cards do
                if G.playing_cards[i].base.suit == target_suit then
                    table.insert(cards_to_destroy, G.playing_cards[i])
                end
            end
            for _, c in ipairs(cards_to_destroy) do
                c:start_dissolve()
            end
            return {
                message = "Cataclysm: " .. target_suit .. " destroyed!",
                colour = G.C.SECONDARY_SET.Spectral
            }
        end
    end
})



SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_squire',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_squire',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_jack = false
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == 11 then
                    has_jack = true
                    break
                end
            end
            if has_jack then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_lady_in_waiting',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_lady_in_waiting',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_queen = false
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == 12 then
                    has_queen = true
                    break
                end
            end
            if has_queen then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_royal_guard',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_royal_guard',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_king = false
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == 13 then
                    has_king = true
                    break
                end
            end
            if has_king then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_jester',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_jester',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_ace = false
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == 14 then
                    has_ace = true
                    break
                end
            end
            if has_ace then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_warrior',
    discovered = true,
    config = { extra = { chips = 20 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_warrior',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit('Spades') then
                    count = count + 1
                end
            end
            if count > 0 then
                return {
                    message = localize{type='variable', key='a_chips', vars={card.ability.extra.chips * count}},
                    chip_mod = card.ability.extra.chips * count
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_mage',
    discovered = true,
    config = { extra = { mult = 4 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_mage',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit('Clubs') then
                    count = count + 1
                end
            end
            if count > 0 then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult * count}},
                    mult_mod = card.ability.extra.mult * count
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_rogue',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_rogue',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Diamonds') then
                G.GAME.dollar_cap = G.GAME.dollar_cap or 0
                ease_dollars(card.ability.extra.money)
                return {
                    extra = {focus = context.other_card, message = localize('$')..card.ability.extra.money, colour = G.C.MONEY},
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_cleric',
    discovered = true,
    config = { extra = { hearts_needed = 5, hand_gained = 1 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_cleric',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.hearts_needed, extra.hand_gained } }

    end,
    calculate = function(self, card, context)
        if context.after_hand and not context.blueprint then
            local hearts = 0
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit('Hearts') then
                    hearts = hearts + 1
                end
            end
            if hearts >= card.ability.extra.hearts_needed and not G.GAME.current_round.odyssey_cleric_activated then
                G.GAME.current_round.odyssey_cleric_activated = true
                ease_hands_played(card.ability.extra.hand_gained)
                return {
                    message = localize('k_plus_one_hand'),
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_barbarian',
    discovered = true,
    config = { extra = { mult = 30 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_barbarian',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_face = false
            for i = 1, #context.full_hand do
                if context.full_hand[i]:is_face() then
                    has_face = true
                    break
                end
            end
            if not has_face then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_paladin',
    discovered = true,
    config = { extra = { chips = 50 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_paladin',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local all_face = true
            for i = 1, #context.full_hand do
                if not context.full_hand[i]:is_face() then
                    all_face = false
                    break
                end
            end
            if all_face and #context.full_hand > 0 then
                return {
                    message = localize{type='variable', key='a_chips', vars={card.ability.extra.chips}},
                    chip_mod = card.ability.extra.chips
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_druid',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_druid',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            local suit_count = 0
            for i = 1, #context.scoring_hand do
                local suit = context.scoring_hand[i].base.suit
                if not suits[suit] then
                    suits[suit] = true
                    suit_count = suit_count + 1
                end
            end
            if suit_count > 1 then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                    mult_mod = card.ability.extra.mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_necromancer',
    discovered = true,
    config = { extra = {} },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_necromancer',
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and not context.blueprint and G.GAME.last_destroyed_face_card then
            local card_data = G.GAME.last_destroyed_face_card
            G.GAME.last_destroyed_face_card = nil
            
            G.E_MANAGER:add_event(Event({
                func = function()
                    local _card = create_playing_card(G.P_CARDS[card_data.card_key], G.deck, nil, nil, nil)
                    
                    _card:set_ability(card_data.ability)
                    _card:set_edition(card_data.edition)
                    _card:set_seal(card_data.seal)
                    _card:juice_up()
                    
                    return true
                end
            }))
            return {
                message = localize('k_plus_card'),
                colour = G.C.BLUE
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_bard',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_bard',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                mult_mod = card.ability.extra.mult
            }
        end
        if context.repetition and context.cardarea == G.play then
            -- Retrigger last face card played
            local last_face = nil
            for i = #context.scoring_hand, 1, -1 do
                if context.scoring_hand[i]:is_face() then
                    last_face = context.scoring_hand[i]
                    break
                end
            end
            if last_face and context.other_card == last_face then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_monk',
    discovered = true,
    config = { extra = { chips = 20 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_monk',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.scoring_hand do
                local id = context.scoring_hand[i]:get_id()
                if id >= 2 and id <= 4 then
                    count = count + 1
                end
            end
            if count > 0 then
                return {
                    message = localize{type='variable', key='a_chips', vars={card.ability.extra.chips * count}},
                    chip_mod = card.ability.extra.chips * count
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_hunter',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_hunter',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.blind and G.GAME.blind.boss then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                mult_mod = card.ability.extra.mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_blacksmith',
    discovered = true,
    config = { extra = { mult = 10 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_blacksmith',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_platinum or context.other_card.ability.effect == 'Steel Card' then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
        if context.individual and context.cardarea == G.hand and not context.end_of_round then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_platinum or context.other_card.ability.effect == 'Steel Card' then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_merchant',
    discovered = true,
    config = { extra = { money = 2 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_merchant',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_plastic or context.other_card.ability.effect == 'Gold Card' then
                ease_dollars(card.ability.extra.money)
                return {
                    extra = {focus = context.other_card, message = localize('$')..card.ability.extra.money, colour = G.C.MONEY},
                    card = card
                }
            end
        end
        if context.individual and context.cardarea == G.hand and not context.end_of_round then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_plastic or context.other_card.ability.effect == 'Gold Card' then
                ease_dollars(card.ability.extra.money)
                return {
                    extra = {focus = context.other_card, message = localize('$')..card.ability.extra.money, colour = G.C.MONEY},
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_alchemist',
    discovered = true,
    config = { extra = { odds = 5 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_alchemist',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.odds } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.c_base and pseudorandom('alchemist') < G.GAME.probabilities.normal / card.ability.extra.odds then
                context.other_card:set_ability(G.P_CENTERS.m_odyssey_platinum)
                return {
                    extra = {focus = context.other_card, message = localize('k_platinum'), colour = G.C.CHIPS},
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_seer',
    discovered = true,
    config = { extra = { mult = 5 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_seer',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local next_card = (G.deck and G.deck.cards) and G.deck.cards[#G.deck.cards] or nil
        local next_suit = next_card and next_card.base.suit or 'None'
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult, next_suit } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                mult_mod = card.ability.extra.mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_peasant',
    discovered = true,
    config = { extra = { mult = 5 } },
    rarity = 1,
    cost = 5,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_peasant',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.scoring_hand do
                local id = context.scoring_hand[i]:get_id()
                if id >= 2 and id <= 5 then
                    count = count + 1
                end
            end
            if count > 0 then
                return {
                    message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult * count}},
                    mult_mod = card.ability.extra.mult * count
                }
            end
        end
    end
})


SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_barbarian_king',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_barbarian_king',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local only_black = true
            for i = 1, #context.full_hand do
                if context.full_hand[i]:is_suit('Hearts') or context.full_hand[i]:is_suit('Diamonds') then
                    only_black = false
                    break
                end
            end
            if only_black and #context.full_hand > 0 then
                return {
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                    x_mult = card.ability.extra.x_mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_fairy_queen',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_fairy_queen',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local only_red = true
            for i = 1, #context.full_hand do
                if context.full_hand[i]:is_suit('Spades') or context.full_hand[i]:is_suit('Clubs') then
                    only_red = false
                    break
                end
            end
            if only_red and #context.full_hand > 0 then
                return {
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                    x_mult = card.ability.extra.x_mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_archmage',
    discovered = true,
    config = { extra = { mult_per_club = 10 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_archmage',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.playing_cards then
            for _, c in ipairs(G.playing_cards) do
                if c:is_suit('Clubs') then count = count + 1 end
            end
        end
        return { vars = { card.ability.extra.mult_per_club, count, count * card.ability.extra.mult_per_club } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for _, c in ipairs(G.playing_cards) do
                if c:is_suit('Clubs') then count = count + 1 end
            end
            if count > 0 then
                return {
                    message = localize{type='variable', key='a_mult', vars={count * card.ability.extra.mult_per_club}},
                    mult_mod = count * card.ability.extra.mult_per_club
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_grandmaster',
    discovered = true,
    config = { extra = { x_mult = 1.5 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_grandmaster',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.hand and not context.end_of_round then
            if context.other_card:is_face() then
                return {
                    x_mult = card.ability.extra.x_mult,
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_assassin',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_assassin',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint and #G.hand.cards > 0 then
            local lowest_card = G.hand.cards[1]
            for i = 2, #G.hand.cards do
                if G.hand.cards[i]:get_id() < lowest_card:get_id() then
                    lowest_card = G.hand.cards[i]
                end
            end
            if not lowest_card.ability.eternal then lowest_card:start_dissolve() end
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_berserker',
    discovered = true,
    config = { extra = { mult = 50, discards = 1 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_berserker',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.discards } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                mult_mod = card.ability.extra.mult
            }
        end
    end,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards
        ease_discard(-card.ability.extra.discards)
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards
        ease_discard(card.ability.extra.discards)
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_shaman',
    discovered = true,
    config = { extra = {} },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_shaman',
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint and not G.GAME.current_round.odyssey_shaman_activated then
            G.GAME.current_round.odyssey_shaman_activated = true
            local suits = {'Spades', 'Hearts', 'Clubs', 'Diamonds'}
            local new_suit = pseudorandom_element(suits, pseudoseed('shaman'))
            for i = 1, #G.hand.cards do
                G.hand.cards[i]:change_suit(new_suit)
            end
            return {
                message = localize('k_suit'),
                colour = G.C.PURPLE
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_knight',
    discovered = true,
    config = { extra = { chips = 0, chip_gain = 50 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_knight',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.chip_gain } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_face() then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
        if context.end_of_round and G.GAME.blind and G.GAME.blind.boss and not context.blueprint and not context.other_card then
            card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chip_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.CHIPS
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_ninja',
    discovered = true,
    config = { extra = { odds = 4 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_ninja',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.odds } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_face() and pseudorandom('ninja') < G.GAME.probabilities.normal / card.ability.extra.odds then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = copy_card(context.other_card, nil)
                        _card:add_to_deck()
                        table.insert(G.playing_cards, _card)
                        G.deck:emplace(_card)
                        _card:juice_up()
                        return true
                    end
                }))
                return {
                    extra = {focus = context.other_card, message = localize('k_plus_card'), colour = G.C.BLUE},
                    card = card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_samurai',
    discovered = true,
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_samurai',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'High Card' then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_viking',
    discovered = true,
    config = { extra = { money_per_card = 1 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_viking',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = G.GAME.viking_destroyed_count or 0
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).money_per_card, count, count * ( (card and card.ability and card.ability.extra) or self.config.extra ).money_per_card } }
    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.blueprint and not context.other_card then
            local count = G.GAME.viking_destroyed_count or 0
            if count > 0 then
                ease_dollars(count * card.ability.extra.money_per_card)
                return {
                    message = localize('$')..(count * card.ability.extra.money_per_card),
                    colour = G.C.MONEY
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_pirate',
    discovered = true,
    config = { extra = { money = 3 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_pirate',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'Flush' then
            ease_dollars(card.ability.extra.money)
            return {
                message = localize('$')..card.ability.extra.money,
                colour = G.C.MONEY
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_gladiator',
    discovered = true,
    config = { extra = { mult_per_card = 10 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_gladiator',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult_per_card } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = #G.hand.cards
            if count > 0 then
                return {
                    message = localize{type='variable', key='a_mult', vars={count * card.ability.extra.mult_per_card}},
                    mult_mod = count * card.ability.extra.mult_per_card
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_musketeer',
    discovered = true,
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_musketeer',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'Three of a Kind' then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_legionnaire',
    discovered = true,
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_legionnaire',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'Four of a Kind' then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_emperor',
    discovered = true,
    config = { extra = {} },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_emperor',
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and G.GAME.current_round.hands_played == 1 and not context.blueprint and not context.other_card then
            if #G.consumeables.cards < G.consumeables.config.card_limit then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, 'c_emperor', 'emperor')
                        _card:add_to_deck()
                        G.consumeables:emplace(_card)
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_tarot'),
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_high_priestess',
    discovered = true,
    config = { extra = {} },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_high_priestess',
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and G.GAME.current_round.discards_used == 0 and not context.blueprint and not context.other_card then
            if #G.consumeables.cards < G.consumeables.config.card_limit then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, 'c_high_priestess', 'high_priestess')
                        _card:add_to_deck()
                        G.consumeables:emplace(_card)
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_tarot'),
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_the_hermit',
    discovered = true,
    config = { extra = {} },
    rarity = 2,
    cost = 7,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_the_hermit',
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and G.GAME.dollars == 0 and not context.blueprint and not context.other_card then
            if #G.consumeables.cards < G.consumeables.config.card_limit then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, 'c_hermit', 'hermit')
                        _card:add_to_deck()
                        G.consumeables:emplace(_card)
                        return true
                    end
                }))
                return {
                    message = localize('k_plus_tarot'),
                    colour = G.C.PURPLE
                }
            end
        end
    end
})


SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_council_of_kings',
    discovered = true,
    config = { extra = { x_mult = 4, count_needed = 4, rank = 13 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_council_of_kings',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.count_needed } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == card.ability.extra.rank then
                    count = count + 1
                end
            end
            if count >= card.ability.extra.count_needed then
                return {
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                    x_mult = card.ability.extra.x_mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_harem',
    discovered = true,
    config = { extra = { x_mult = 4, count_needed = 4, rank = 12 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_harem',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.count_needed } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == card.ability.extra.rank then
                    count = count + 1
                end
            end
            if count >= card.ability.extra.count_needed then
                return {
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                    x_mult = card.ability.extra.x_mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_brotherhood',
    discovered = true,
    config = { extra = { x_mult = 4, count_needed = 4, rank = 11 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_brotherhood',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.count_needed } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.full_hand do
                if context.full_hand[i]:get_id() == card.ability.extra.rank then
                    count = count + 1
                end
            end
            if count >= card.ability.extra.count_needed then
                return {
                    message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                    x_mult = card.ability.extra.x_mult
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_mage_circle',
    discovered = true,
    config = { extra = { consumable_slots = 1 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_mage_circle',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.consumable_slots } }

    end,
    add_to_deck = function(self, card, from_debuff)
        G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra.consumable_slots
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.consumeables.config.card_limit = G.consumeables.config.card_limit - card.ability.extra.consumable_slots
    end,
    calculate = function(self, card, context)
        -- Passive effect for Tarot frequency handled in pool overrides
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_thieves_guild',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_thieves_guild',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.after_hand then
            ease_dollars(card.ability.extra.money)
            return {
                message = localize('$')..card.ability.extra.money,
                colour = G.C.MONEY
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_holy_order',
    discovered = true,
    config = { extra = { mult = 20 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_holy_order',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            for i = 1, #G.hand.cards do
                G.hand.cards[i].debuff = false
            end
            return {
                message = localize('k_active_ex'),
                colour = G.C.WHITE
            }
        end
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}},
                mult_mod = card.ability.extra.mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_shadow_army',
    discovered = true,
    config = { extra = {} },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_shadow_army',
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and not context.blueprint then
            local cards_to_copy = {}
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:is_face() then
                    table.insert(cards_to_copy, context.scoring_hand[i])
                end
            end
            if #cards_to_copy > 0 then
                for _, face_card in ipairs(cards_to_copy) do
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            local _card = copy_card(face_card, nil)
                            _card:add_to_deck()
                            table.insert(G.playing_cards, _card)
                            G.deck:emplace(_card)
                            _card:juice_up()
                            return true
                        end
                    }))
                end
                return {
                    message = localize('k_plus_card'),
                    colour = G.C.BLUE
                }
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_champion',
    discovered = true,
    config = { extra = { x_mult = 3, permanent_gain = 0.5 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_champion',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.permanent_gain } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
        if context.end_of_round and G.GAME.blind and G.GAME.blind.boss and not context.blueprint and not context.other_card then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.permanent_gain
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_dark_lord',
    discovered = true,
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_dark_lord',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end,
    add_to_deck = function(self, card, from_debuff)
        if not from_debuff then
            local face_cards = {}
            for i = #G.playing_cards, 1, -1 do
                if G.playing_cards[i]:is_face() then
                    table.insert(face_cards, G.playing_cards[i])
                end
            end
            for _, face_card in ipairs(face_cards) do
                if not face_card.ability.eternal then face_card:start_dissolve() end
            end
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_hero',
    discovered = true,
    config = { extra = { x_mult = 5, hands_needed = 1 } },
    rarity = 3,
    cost = 9,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_hero',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.hands_needed } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_left == card.ability.extra.hands_needed then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end
})


SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_king_of_kings',
    discovered = true,
    config = { extra = { x_mult = 5 } },
    rarity = 4,
    cost = 20,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_king_of_kings',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    add_to_deck = function(self, card)
        G.GAME.odyssey_king_of_kings_active = (G.GAME.odyssey_king_of_kings_active or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_king_of_kings_active = (G.GAME.odyssey_king_of_kings_active or 0) - 1
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
    end
})

SMODS.Joker({
    unlocked = true,
    key = 'j_tribal_god_of_war',
    discovered = true,
    config = { extra = { x_mult = 5, scaling = 1 } },
    rarity = 4,
    cost = 20,
    pos = { x = 0, y = 0 },
    atlas = 'j_tribal_god_of_war',
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.scaling } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_xmult', vars={card.ability.extra.x_mult}},
                x_mult = card.ability.extra.x_mult
            }
        end
        if context.after_hand and not context.blueprint and not context.other_card then
            local count = #context.scoring_hand
            if count > 0 then
                card.ability.extra.x_mult = card.ability.extra.x_mult + (count * card.ability.extra.scaling)
                for i = 1, #context.scoring_hand do
                    context.scoring_hand[i]:start_dissolve()
                end
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT
                }
            end
        end
    end
})


----------------------------------------------
-- PROFESSIONS GROUP (COMMON)
----------------------------------------------

-- 501. Miner
SMODS.Joker({
    key = 'j_professions_miner',
    atlas = 'j_professions_miner',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { chance = 4 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context)
        if context.discard and not context.other_card then -- Trigger once per discard action
             if pseudorandom('miner') < G.GAME.probabilities.normal / card.ability.extra.chance then
                 G.E_MANAGER:add_event(Event({func = function()
                     local c = create_playing_card(pseudorandom_element(G.P_CARDS, pseudoseed('miner_card')), G.deck, nil, nil, nil)
                     c:set_ability(G.P_CENTERS.m_odyssey_emerald)
                     c:add_to_deck()
                     G.deck:emplace(c)
                     return true
                 end}))
                 return { message = localize('k_plus_stone'), colour = G.C.SECONDARY_SET.Enhanced }
             end
        end
    end
})

-- 502. Farmer
SMODS.Joker({
    key = 'j_professions_farmer',
    atlas = 'j_professions_farmer',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for k, v in pairs(G.playing_cards) do
                local id = v:get_id()
                if id >= 2 and id <= 5 then count = count + 1 end
            end
             return { mult_mod = count * card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={count * card.ability.extra.mult}} }
        end
    end
})

-- 503. Fisherman
SMODS.Joker({
    key = 'j_professions_fisherman',
    atlas = 'j_professions_fisherman',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { chance = 3 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
             if pseudorandom('fisherman') < G.GAME.probabilities.normal / card.ability.extra.chance then
                 G.E_MANAGER:add_event(Event({
                    trigger = 'before',
                    delay = 0.4,
                    func = function()
                        local card = create_card(nil, G.consumeables, nil, nil, nil, nil, nil, 'fish')
                        card:add_to_deck()
                        G.consumeables:emplace(card)
                        return true
                    end
                }))
                return { message = localize('k_plus_card'), colour = G.C.SECONDARY_SET.Tarot }
             end
        end
    end
})

-- 504. Chef
SMODS.Joker({
    key = 'j_professions_chef',
    atlas = 'j_professions_chef',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if #G.jokers.cards < G.jokers.config.card_limit then
                local food_jokers = { 'j_gros_michel', 'j_ice_cream', 'j_turtle_bean', 'j_popcorn', 'j_ramen', 'j_selzer' }
                local chosen_food = food_jokers[pseudorandom('chef', 1, #food_jokers)]
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local card = create_card('Joker', G.jokers, nil, nil, nil, nil, chosen_food, 'chef')
                        card:add_to_deck()
                        G.jokers:emplace(card)
                        return true
                    end
                }))
                return { message = localize('k_plus_joker'), colour = G.C.BLUE }
            end
        end
    end
})

-- 505. Doctor
SMODS.Joker({
    key = 'j_professions_doctor',
    atlas = 'j_professions_doctor',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = false,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.game_over and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                func = function()
                    G.hand_text_area.card_eval_status_text:ease_text(localize('k_saved_ex'), 0.5, 0.5, 0.5)
                    G.GAME.round_resets.hands = G.GAME.round_resets.hands + 1
                    if not card.ability.eternal then card:start_dissolve() end
                    return true
                end
            }))
            return { saved = true }
        end
    end
})

-- 506. Engineer
SMODS.Joker({
    key = 'j_professions_engineer',
    atlas = 'j_professions_engineer',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.current_round.hands_played == 1 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        G.jokers.config.card_limit = G.jokers.config.card_limit + 1
                        return true
                    end
                }))
                return { message = localize('k_plus_joker_slot'), colour = G.C.DARK_EDITION }
            end
        end
    end
})

-- 507. Architect
SMODS.Joker({
    key = 'j_professions_architect',
    atlas = 'j_professions_architect',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { hand_size = 1 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.hand_size } }

    end,
    add_to_deck = function(self, card) G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size end,
    remove_from_deck = function(self, card) G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 508. Astronomer
SMODS.Joker({
    key = 'j_professions_astronomer',
    atlas = 'j_professions_astronomer',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_astronomer_planets_free = (G.GAME.odyssey_astronomer_planets_free or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_astronomer_planets_free = (G.GAME.odyssey_astronomer_planets_free or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 509. Librarian
SMODS.Joker({
    key = 'j_professions_librarian',
    atlas = 'j_professions_librarian',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { chips = 10 } },
    loc_vars = function(self, info_queue, card)
        local views = G.GAME.odyssey_deck_clicks or 0
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).chips, views, ( (card and card.ability and card.ability.extra) or self.config.extra ).chips * views } }
    end,
    add_to_deck = function(self, card) G.GAME.odyssey_librarian_active = (G.GAME.odyssey_librarian_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_librarian_active = (G.GAME.odyssey_librarian_active or 0) - 1 end,
    calculate = function(self, card, context)
         if context.joker_main then
              local views = G.GAME.odyssey_deck_clicks or 0
              return { chip_mod = views * card.ability.extra.chips, message = localize{type='variable',key='a_chips',vars={views * card.ability.extra.chips}} }
        end
    end
})

-- 510. Mailman
SMODS.Joker({
    key = 'j_professions_mailman',
    atlas = 'j_professions_mailman',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { dollars = 1 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.discard and context.other_card and context.other_card:get_id() == 14 then
             ease_dollars(card.ability.extra.dollars)
             return { message = localize('$')..card.ability.extra.dollars, colour = G.C.MONEY }
        end
    end
})

-- 511. Firefighter
SMODS.Joker({
    config = { odyssey_immune = true },
    key = 'j_professions_firefighter',
    atlas = 'j_professions_firefighter',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_firefighter_active = (G.GAME.odyssey_firefighter_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_firefighter_active = (G.GAME.odyssey_firefighter_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 512. Police
SMODS.Joker({
    key = 'j_professions_police',
    atlas = 'j_professions_police',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { dollars = 5 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'High Card' then
             ease_dollars(card.ability.extra.dollars)
             return { message = localize('$')..card.ability.extra.dollars, colour = G.C.MONEY }
        end
    end
})

-- 513. Judge
SMODS.Joker({
    key = 'j_professions_judge',
    atlas = 'j_professions_judge',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 10 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and #context.scoring_hand == 5 then
             return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
        end
    end
})

-- 514. Lawyer
SMODS.Joker({
    key = 'j_professions_lawyer',
    atlas = 'j_professions_lawyer',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 15 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
        end
    end
})

-- 515. Teacher
SMODS.Joker({
    key = 'j_professions_teacher',
    atlas = 'j_professions_teacher',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult_gain = 2, mult = 0 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult_gain, extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'High Card' then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain
            return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
        end
    end
})

-- 516. Student
SMODS.Joker({
    key = 'j_professions_student',
    atlas = 'j_professions_student',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 0, gain = 1, rounds = 0, graduated = false } },

    loc_vars = function(self, info_queue, card)
        -- Proteccin contra 'nil' si se ve desde la coleccin
        local mult = card and card.ability and card.ability.extra.mult or 0
        local rounds = card and card.ability.extra.rounds or 0
        local gain = card and card.ability.extra.gain or 1
        
        -- #1: Ganancia, #2: Mult Actual, #3: Rondas
        return { vars = { gain, mult, rounds } }
    end,

    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.rounds = card.ability.extra.rounds + 1
            
            -- Si llega a 10 rondas, se grada
            if card.ability.extra.rounds >= 10 then 
                card.ability.extra.graduated = true 
            end
            
            -- Si NO est graduado, sigue ganando Mult
            if not card.ability.extra.graduated then
                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT,
                    card = card
                }
            elseif card.ability.extra.graduated and card.ability.extra.rounds == 10 then
                -- Mensaje nico justo cuando se grada
                return {
                    message = "Graduated!",
                    colour = G.C.PURPLE,
                    card = card
                }
            end
        end

        if context.joker_main then
            if card.ability.extra.graduated then
                 return { 
                    x_mult = 2, 
                    message = localize{type='variable',key='a_xmult',vars={2}} 
                 }
            else
                 return { 
                    mult_mod = card.ability.extra.mult, 
                    message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} 
                 }
            end
        end
    end
})

-- 517. Scientist
SMODS.Joker({
    key = 'j_professions_scientist',
    atlas = 'j_professions_scientist',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { chance = 4 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
             if pseudorandom('scientist') < G.GAME.probabilities.normal / card.ability.extra.chance then
                local card_to_upgrade = pseudorandom_element(context.scoring_hand, pseudoseed('scientist_card'))
                local enhancements = { 'm_bonus', 'm_mult', 'm_wild', 'm_odyssey_ceramic', 'm_odyssey_platinum', 'm_odyssey_emerald', 'm_odyssey_plastic', 'm_lucky' }
                local enhancement = pseudorandom_element(enhancements, pseudoseed('scientist_enh'))
                card_to_upgrade:set_ability(G.P_CENTERS[enhancement])
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.CHIPS,
                    card = card_to_upgrade
                }
             end
        end
    end
})

-- 518. Artist
SMODS.Joker({
    key = 'j_professions_artist',
    atlas = 'j_professions_artist',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { chips = 10 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_face() then
                 return { chips = card.ability.extra.chips, card = card }
            end
        end
    end
})

-- 519. Musician
SMODS.Joker({
    key = 'j_professions_musician',
    atlas = 'j_professions_musician',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 10 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
         if context.joker_main and next(context.poker_hands['Straight']) then
              return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
        end
    end
})

-- 520. Actor
SMODS.Joker({
    key = 'j_professions_actor',
    atlas = 'j_professions_actor',
    pos = { x = 0, y = 0 },
    rarity = 1,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        local right_joker = nil
        for i = 1, #G.jokers.cards do
            if G.jokers.cards[i] == card then
                right_joker = G.jokers.cards[i+1]
                break
            end
        end
        if right_joker and right_joker ~= card then
            context.blueprint = (context.blueprint or 0) + 1
            context.blueprint_card = card
            local res = right_joker:calculate_joker(context)
            if res then
                res.card = card
                return res
            end
        end
    end
})



----------------------------------------------
-- PROFESSIONS GROUP (UNCOMMON)
----------------------------------------------

-- 521. Surgeon
SMODS.Joker({
    key = 'j_professions_surgeon',
    atlas = 'j_professions_surgeon',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.pre_discard and not context.blueprint and #context.full_hand == 2 then
            local card1 = context.full_hand[1]
            local card2 = context.full_hand[2]
            if card1.base.value == card2.base.value then
                local new_rank = card1.base.id + 1
                if new_rank > 14 then new_rank = 14 end
                
                -- Construct key: 10 -> T, 11 -> J, etc.
                local rank_suffix = tostring(new_rank)
                if new_rank == 10 then rank_suffix = 'T'
                elseif new_rank == 11 then rank_suffix = 'J'
                elseif new_rank == 12 then rank_suffix = 'Q'
                elseif new_rank == 13 then rank_suffix = 'K'
                elseif new_rank == 14 then rank_suffix = 'A'
                end
                local suit_prefix = card1.base.suit:sub(1,1)
                local target_key = suit_prefix..'_'..rank_suffix
                
                if G.P_CARDS[target_key] then
                    G.E_MANAGER:add_event(Event({
                        trigger = 'after',
                        delay = 0.2,
                        func = function()
                            local _card = create_playing_card({front = G.P_CARDS[target_key], center = G.P_CENTERS.c_base}, G.hand, nil, nil, {G.C.SECONDARY_SET.Enhanced})
                            _card:juice_up()
                            return true
                        end
                    }))
                    return {
                        message = localize('k_active_ex'),
                        card = card
                    }
                end
            end
        end
    end
})

-- 522. Chemist
SMODS.Joker({
    key = 'j_professions_chemist',
    atlas = 'j_professions_chemist',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local cards_to_change = {}
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i].config.center == G.P_CENTERS.m_odyssey_plastic then
                    cards_to_change[#cards_to_change+1] = context.scoring_hand[i]
                end
            end
            if #cards_to_change > 0 then
                for i=1, #cards_to_change do
                    cards_to_change[i]:set_ability(G.P_CENTERS.m_odyssey_platinum)
                    cards_to_change[i]:juice_up()
                end
                return {
                    message = localize('k_active_ex'),
                    colour = G.C.GOLD
                }
            end
        end
    end
})

-- 523. Geologist
SMODS.Joker({
    key = 'j_professions_geologist',
    atlas = 'j_professions_geologist',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { chips = 50 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_emerald then
                return { chips = card.ability.extra.chips, card = card }
            end
        end
    end
})

-- 524. Botanist
SMODS.Joker({
    key = 'j_professions_botanist',
    atlas = 'j_professions_botanist',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 1.5 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Clubs') then
                return { x_mult = card.ability.extra.x_mult, card = card }
            end
        end
    end
})

-- 525. Zoologist
SMODS.Joker({
    key = 'j_professions_zoologist',
    atlas = 'j_professions_zoologist',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
         if context.joker_main and next(context.poker_hands['Pair']) then
             return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
        end
    end
})

-- 526. Archaeologist
SMODS.Joker({
    key = 'j_professions_archaeologist',
    atlas = 'j_professions_archaeologist',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    add_to_deck = function(self, card) G.GAME.odyssey_archaeologist_active = (G.GAME.odyssey_archaeologist_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_archaeologist_active = (G.GAME.odyssey_archaeologist_active or 0) - 1 end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local is_old = false
            for i=1, math.min(10, #G.deck.cards) do
                if G.deck.cards[i] == context.other_card then is_old = true break end
            end
            if is_old then
                return {
                    x_mult = card.ability.extra.x_mult,
                    card = card
                }
            end
        end
    end
})

-- 527. Historian
SMODS.Joker({
    key = 'j_professions_historian',
    atlas = 'j_professions_historian',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
         if context.joker_main then
             local r = G.GAME.round or 0
             return { mult_mod = r, message = localize{type='variable',key='a_mult',vars={r}} }
        end
    end
})

-- 528. Futurist
SMODS.Joker({
    key = 'j_professions_futurist',
    atlas = 'j_professions_futurist',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 15 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
        end
    end
})

-- 529. Investor
SMODS.Joker({
    key = 'j_professions_investor',
    atlas = 'j_professions_investor',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.blueprint and not context.other_card then
            if G.GAME.dollars >= 50 then
                ease_dollars(5)
                return {
                    message = "$5",
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 530. Banker
SMODS.Joker({
    key = 'j_professions_banker',
    atlas = 'j_professions_banker',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_banker_active = (G.GAME.odyssey_banker_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_banker_active = (G.GAME.odyssey_banker_active or 0) - 1 end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.blueprint and not context.other_card then
            if G.GAME.odyssey_banker_money and G.GAME.odyssey_banker_money > 0 then
                ease_dollars(G.GAME.odyssey_banker_money)
                local m = G.GAME.odyssey_banker_money
                G.GAME.odyssey_banker_money = 0
                return {
                    message = "$" .. m,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 531. Cat Burglar
SMODS.Joker({
    key = 'j_professions_cat_burglar',
    atlas = 'j_professions_cat_burglar',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.buy_joker and not context.blueprint and not G.GAME.odyssey_cat_burglar_used then
             G.GAME.odyssey_cat_burglar_used = true
             ease_dollars(context.card.cost)
             return { message = "Stolen!", colour = G.C.MONEY }
        end
    end
})

-- 532. Spy
SMODS.Joker({
    key = 'j_professions_spy',
    atlas = 'j_professions_spy',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 10 } },
    loc_vars = function(self, info_queue, card)
        local next_card = (G.deck and G.deck.cards) and G.deck.cards[#G.deck.cards] or nil
        local display = "None"
        if next_card then
            display = next_card.base.value .. " of " .. next_card.base.suit
        end
        return { vars = { card.ability.extra.mult, display } }
    end,
    add_to_deck = function(self, card) G.GAME.odyssey_spy_active = (G.GAME.odyssey_spy_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_spy_active = (G.GAME.odyssey_spy_active or 0) - 1 end,
    calculate = function(self, card, context)
         if context.joker_main then
              return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
         end
    end
})

-- 533. Diplomat
SMODS.Joker({
    key = 'j_professions_diplomat',
    atlas = 'j_professions_diplomat',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_diplomat_active = (G.GAME.odyssey_diplomat_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_diplomat_active = (G.GAME.odyssey_diplomat_active or 0) - 1 end,
    calculate = function(self, card, context)
        -- Logic handled in Blind:set_blind override
    end
})

-- 534. General
SMODS.Joker({
    key = 'j_professions_general',
    atlas = 'j_professions_general',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { xmult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
         if context.joker_main and G.GAME.current_round.hands_played == 0 then
             return { x_mult = card.ability.extra.xmult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.xmult}} }
        end
    end
})

-- 535. Admiral
SMODS.Joker({
    key = 'j_professions_admiral',
    atlas = 'j_professions_admiral',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { xmult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
         if context.joker_main and G.GAME.current_round.hands_left == 0 then
             return { x_mult = card.ability.extra.xmult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.xmult}} }
        end
    end
})

-- 536. Astronaut
SMODS.Joker({
    key = 'j_professions_astronaut',
    atlas = 'j_professions_astronaut',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 20 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
         if context.joker_main then
              return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
         end
    end
})

-- 537. Diver
SMODS.Joker({
    key = 'j_professions_diver',
    atlas = 'j_professions_diver',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { mult = 20 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
         if context.joker_main then
            local black = true
            for k, v in ipairs(context.scoring_hand) do
                if v:is_suit('Hearts') or v:is_suit('Diamonds') then black = false end
            end
            if black then
                  return { mult_mod = card.ability.extra.mult, message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}} }
            end
         end
    end
})

-- 538. Pilot
SMODS.Joker({
    key = 'j_professions_pilot',
    atlas = 'j_professions_pilot',
    pos = { x = 0, y = 0 },
    rarity = 2,
    cost = 6,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + 1
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - 1
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - 1
    end,
    calculate = function(self, card, context)
        -- Passive
    end
})



----------------------------------------------
-- PROFESSIONS GROUP (RARE)
----------------------------------------------

-- 539. CEO
SMODS.Joker({
    key = 'j_professions_ceo',
    atlas = 'j_professions_ceo',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 3, money = 1 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            local dollars = #G.jokers.cards * card.ability.extra.money
            ease_dollars(dollars)
            return { message = localize('$')..dollars, colour = G.C.MONEY }
        end
    end
})

-- 540. President
SMODS.Joker({
    key = 'j_professions_president',
    atlas = 'j_professions_president',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 4, money = 10 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
             ease_dollars(card.ability.extra.money)
            return { message = localize('$')..card.ability.extra.money, colour = G.C.MONEY }
        end
    end
})

-- 541. Dictator
SMODS.Joker({
    key = 'j_professions_dictator',
    atlas = 'j_professions_dictator',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 5 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             -- Only works if playing the most played hand
             local most_played = 'High Card'
             local max_p = 0
             for k, v in pairs(G.GAME.hands) do
                 if v.played > max_p then
                     max_p = v.played
                     most_played = k
                 end
             end
             if context.scoring_name == most_played then
                return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
             end
        end
    end
})

-- 542. Revolutionary
SMODS.Joker({
    key = 'j_professions_revolutionary',
    atlas = 'j_professions_revolutionary',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.blueprint and not context.other_card then
            local most_expensive = nil
            local max_cost = -1
            for i=1, #G.jokers.cards do
                local j = G.jokers.cards[i]
                if j ~= card and j.cost > max_cost then
                    max_cost = j.cost
                    most_expensive = j
                end
            end
            if most_expensive then
                most_expensive:start_dissolve()
                G.GAME.odyssey_revolutionary_active = (G.GAME.odyssey_revolutionary_active or 0) + 1
                return {
                    message = "X3 Mult!",
                    colour = G.C.MULT
                }
            end
        end
        if context.joker_main and G.GAME.odyssey_revolutionary_active and G.GAME.odyssey_revolutionary_active > 0 then
             local total_x = 3 ^ G.GAME.odyssey_revolutionary_active
             return { x_mult = total_x, message = "X"..total_x }
        end
    end
})

-- 543. Prophet
SMODS.Joker({
    key = 'j_professions_prophet',
    atlas = 'j_professions_prophet',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    add_to_deck = function(self, card)
        G.GAME.modifiers.booster_view_all = true
    end,
    remove_from_deck = function(self, card)
        G.GAME.modifiers.booster_view_all = false
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
        end
    end
})

-- 544. Magician
SMODS.Joker({
    key = 'j_professions_magician',
    atlas = 'j_professions_magician',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_magician_active = (G.GAME.odyssey_magician_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_magician_active = (G.GAME.odyssey_magician_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 545. Illusionist
SMODS.Joker({
    key = 'j_professions_illusionist',
    atlas = 'j_professions_illusionist',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 3 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
        end
    end
})

-- 546. Hypnotist
SMODS.Joker({
    key = 'j_professions_hypnotist',
    atlas = 'j_professions_hypnotist',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 3 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == 'Straight' then
            local has_face = false
            for k, v in ipairs(context.scoring_hand) do
                if v:get_id() >= 11 and v:get_id() <= 13 then has_face = true break end
            end
            if has_face then
                return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
            end
        end
    end
})

-- 547. Beast Tamer
SMODS.Joker({
    key = 'j_professions_beast_tamer',
    atlas = 'j_professions_beast_tamer',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 2 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_wild then
                return { x_mult = card.ability.extra.x_mult, card = card }
            end
        end
    end
})

-- 548. Foreman
SMODS.Joker({
    key = 'j_professions_foreman',
    atlas = 'j_professions_foreman',
    pos = { x = 0, y = 0 },
    rarity = 3,
    cost = 8,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { rounds = 0 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.rounds } }

    end,
    calculate = function(self, card, context)
         if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.rounds = card.ability.extra.rounds + 1
            if card.ability.extra.rounds == 5 then
                 G.jokers.config.card_limit = G.jokers.config.card_limit + 1
                 return { left = true, message = localize('k_plus_joker_slot') }
            end
         end
    end
})



----------------------------------------------
-- PROFESSIONS GROUP (LEGENDARY)
----------------------------------------------

-- 549. Guild Master
SMODS.Joker({
    key = 'j_professions_guild_master',
    atlas = 'j_professions_guild_master',
    pos = { x = 0, y = 0 },
    rarity = 4,
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 3, gain = 0.5 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.gain } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.jokers and G.jokers.cards then
                for _, j in ipairs(G.jokers.cards) do
                    if j.config.center.key:find('professions') then
                        count = count + 1
                    end
                end
            end
            local total_xmult = card.ability.extra.x_mult + (count * card.ability.extra.gain)
            return { x_mult = total_xmult, message = localize{type='variable',key='a_xmult',vars={total_xmult}} }
        end
    end
})

-- 550. Tycoon
SMODS.Joker({
    key = 'j_professions_tycoon',
    atlas = 'j_professions_tycoon',
    pos = { x = 0, y = 0 },
    rarity = 4,
    cost = 20,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    eternal_compat = true,
    perishable_compat = true,
    config = { extra = { x_mult = 5, huge_mult = 10, threshold = 100 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.huge_mult, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local mult = card.ability.extra.x_mult
            if G.GAME.dollars >= card.ability.extra.threshold then
                mult = card.ability.extra.huge_mult
            end
             return { x_mult = mult, message = localize{type='variable',key='a_xmult',vars={mult}} }
        end
    end
})



-- ============================================
-- ECONOMY - Common (Jokers 551-570)
-- ============================================

-- 551: Piggy Bank
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_piggy_bank',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_piggy_bank',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local dollars = (G.GAME.current_round.hands_left or 0) * card.ability.extra.money
            if dollars > 0 then
                ease_dollars(dollars)
                return {
                    message = localize('$') .. dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 552: Angel Investor
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_angel_investor',
    discovered = true,
    config = { extra = { money = 2, gain = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_angel_investor',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money, extra.gain } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            ease_dollars(card.ability.extra.money)
            local ret = {
                message = localize('$') .. card.ability.extra.money,
                colour = G.C.MONEY
            }
            if not context.blueprint then
                card.ability.extra.money = card.ability.extra.money + card.ability.extra.gain
            end
            return ret
        end
    end
})

-- 553: Clearance Sale
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_clearance_sale',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_clearance_sale',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_clearance_sale = (G.GAME.odyssey_clearance_sale or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_clearance_sale = (G.GAME.odyssey_clearance_sale or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 554: Coupon
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_coupon',
    discovered = true,
    config = { extra = { active = true, last_ante = 0 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_coupon',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card) 
        return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra ).active and "Sim" or "No") } } 
    end,
    calculate = function(self, card, context)
        -- Reset at new Ante
        if context.setting_blind and not context.blueprint then
            if (card.ability.extra.last_ante or 0) < G.GAME.round_resets.ante then
                card.ability.extra.last_ante = G.GAME.round_resets.ante
                card.ability.extra.active = true
            end
        end

        -- Consume when buying an item
        if (context.buying_card or context.buying_consumeable) and not context.blueprint and card.ability.extra.active then
            if not context.odyssey_coupon_consumed then
                card.ability.extra.active = false
                context.odyssey_coupon_consumed = true
                return {
                    message = "Livre!",
                    colour = G.C.GOLD
                }
            end
        end
    end
})

-- 555: Rebate
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_rebate',
    discovered = true,
    config = { extra = { money = 1, max = 5, current = 0 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_rebate',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money, extra.max, extra.current } }

    end,
    calculate = function(self, card, context)
        if context.discard and not context.other_card then
            if card.ability.extra.current < card.ability.extra.max then
                card.ability.extra.current = card.ability.extra.current + 1
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current = 0
        end
    end
})

-- 556: Service Fee
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_service_fee',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_service_fee',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            ease_dollars(card.ability.extra.money)
            return {
                message = localize('$') .. card.ability.extra.money,
                colour = G.C.MONEY
            }
        end
    end
})

-- 557: Tip Jar
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_tip_jar',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_tip_jar',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and #context.scoring_hand == 1 then
            ease_dollars(card.ability.extra.money)
            return {
                message = localize('$') .. card.ability.extra.money,
                colour = G.C.MONEY
            }
        end
    end
})

-- 558: Black Market
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_black_market',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_black_market',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card) G.GAME.odyssey_black_market_active = (G.GAME.odyssey_black_market_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_black_market_active = (G.GAME.odyssey_black_market_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 559: Loan Shark
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_loan_shark',
    discovered = true,
    config = { extra = { money = 20, loss = 2 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_loan_shark',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money, extra.loss } }

    end,
    add_to_deck = function(self, card)
        ease_dollars(card.ability.extra.money)
    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            ease_dollars(-card.ability.extra.loss)
            return {
                message = "-" .. localize('$') .. card.ability.extra.loss,
                colour = G.C.RED
            }
        end
    end
})

-- 560: Inheritance
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_inheritance',
    discovered = true,
    config = { extra = { money = 10 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_inheritance',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card and (G.GAME.dollars or 0) <= 0 then
            ease_dollars(card.ability.extra.money)
            return {
                message = localize('$') .. card.ability.extra.money,
                colour = G.C.MONEY
            }
        end
    end
})

-- 561: Tithe
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_tithe',
    discovered = true,
    config = { extra = { mult = 10, threshold = 20 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_tithe',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if (G.GAME.dollars or 0) > card.ability.extra.threshold then
                local fee = math.floor((G.GAME.dollars or 0) * 0.1)
                if fee > 0 then
                    ease_dollars(-fee)
                    return {
                        message = "-" .. localize('$') .. fee,
                        colour = G.C.RED
                    }
                end
            end
        end
        if context.joker_main and (G.GAME.dollars or 0) > card.ability.extra.threshold then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- 562: Inflation
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_inflation',
    discovered = true,
    config = { extra = { x_mult = 2, cost_inc = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_inflation',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.cost_inc } }

    end,
    add_to_deck = function(self, card) G.GAME.odyssey_inflation_active = (G.GAME.odyssey_inflation_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_inflation_active = (G.GAME.odyssey_inflation_active or 0) - 1 end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- 563: Deflation
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_deflation',
    discovered = true,
    config = { extra = { chips = 50, cost_dec = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_deflation',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.cost_dec } }

    end,
    add_to_deck = function(self, card) G.GAME.odyssey_deflation_active = (G.GAME.odyssey_deflation_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_deflation_active = (G.GAME.odyssey_deflation_active or 0) - 1 end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- 564: Pawn Shop
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_pawn_shop',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_pawn_shop',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card) G.GAME.odyssey_pawn_shop_active = (G.GAME.odyssey_pawn_shop_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_pawn_shop_active = (G.GAME.odyssey_pawn_shop_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 565: Treasure Hunt
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_treasure_hunt',
    discovered = true,
    config = { extra = { chance = 5, money = 5 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_treasure_hunt',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance, extra.money } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Diamonds') then
                if pseudorandom('treasure_hunt') < G.GAME.probabilities.normal / card.ability.extra.chance then
                    ease_dollars(card.ability.extra.money)
                    return {
                        message = localize('$') .. card.ability.extra.money,
                        colour = G.C.MONEY,
                        card = card
                    }
                end
            end
        end
    end
})

-- 566: Gold Mine
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_gold_mine',
    discovered = true,
    config = { extra = { money = 2 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_gold_mine',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_emerald then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})

-- 567: Unionizer
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_unionizer',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_unionizer',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local dollars = (#G.jokers.cards or 0) * card.ability.extra.money
            if dollars > 0 then
                ease_dollars(dollars)
                return {
                    message = localize('$') .. dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 568: Accountant
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_accountant',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_accountant',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local d = G.GAME.dollars or 0
            if d % 5 == 0 then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- 569: Auditor
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_auditor',
    discovered = true,
    config = { extra = { chips = 20, gain = 20 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_auditor',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.gain } }

    end,
    add_to_deck = function(self, card) G.GAME.odyssey_auditor_active = (G.GAME.odyssey_auditor_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_auditor_active = (G.GAME.odyssey_auditor_active or 0) - 1 end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
             if not G.GAME.odyssey_money_spent_in_shop then
                card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.CHIPS
                }
             end
             G.GAME.odyssey_money_spent_in_shop = (G.GAME.odyssey_money_spent_in_shop or 0) - 1
        end
    end
})

-- 570: Capitalist
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_capitalist',
    discovered = true,
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_economy_capitalist',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    add_to_deck = function(self, card) G.GAME.odyssey_capitalist_active = (G.GAME.odyssey_capitalist_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_capitalist_active = (G.GAME.odyssey_capitalist_active or 0) - 1 end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})



-- ============================================
-- ECONOMY - Uncommon (Jokers 571-588)
-- ============================================

-- 571: Invisible Hand
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_invisible_hand',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_invisible_hand',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    config = { extra = { x_mult = 1.5 } },
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and (G.GAME.dollars or 0) < 5 then
            return { x_mult = card.ability.extra.x_mult, message = localize{type='variable',key='a_xmult',vars={card.ability.extra.x_mult}} }
        end
    end
})

-- 572: Economic Bubble
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_economic_bubble',
    discovered = true,
    config = { extra = { money = 5, threshold = 50 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_economic_bubble',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if (G.GAME.dollars or 0) >= card.ability.extra.threshold then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        G.GAME.dollars = 0
                        if not card.ability.eternal then card:start_dissolve() end
                        return true
                    end
                }))
                return {
                    message = "POP!",
                    colour = G.C.RED
                }
            else
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 573: Cryptocurrency
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_cryptocurrency',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_cryptocurrency',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            -- The sell value of this Joker fluctuates randomly between $0 and $50 each round.
            local new_val = math.floor(pseudorandom('crypto') * 50)
            card.sell_cost = new_val
        end
    end
})

-- 574: Income Tax
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_income_tax',
    discovered = true,
    config = { extra = { xmult = 3, tax = 0.2 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_income_tax',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult, extra.tax * 100 } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local tax = math.floor((G.GAME.dollars or 0) * card.ability.extra.tax)
            if tax > 0 then
                ease_dollars(-tax)
            end
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 575: Money Laundering
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_money_laundering',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_money_laundering',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    config = { extra = { mult = 20 } },
    add_to_deck = function(self, card) G.GAME.odyssey_money_laundering_active = (G.GAME.odyssey_money_laundering_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_money_laundering_active = (G.GAME.odyssey_money_laundering_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_plastic then
                return { mult = card.ability.extra.mult, card = card }
            end
        end
    end
})

-- 576: Bribery
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_bribery',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_bribery',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card) G.GAME.odyssey_bribery_active = (G.GAME.odyssey_bribery_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_bribery_active = (G.GAME.odyssey_bribery_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 577: Hedge Fund
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_hedge_fund',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_hedge_fund',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local dollars = math.floor((G.GAME.dollars or 0) / 10)
            if dollars > 0 then
                ease_dollars(dollars)
                return {
                    message = localize('$') .. dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 578: Monopoly
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_monopoly',
    discovered = true,
    config = { extra = { money = 10 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_monopoly',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local gold_count = 0
            if G.hand and G.hand.cards then
                for k, v in ipairs(G.hand.cards) do
                    if v.config.center == G.P_CENTERS.m_odyssey_plastic then
                        gold_count = gold_count + 1
                    end
                end
            end
            if gold_count >= 3 then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 579: Recession
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_recession',
    discovered = true,
    config = { extra = { xmult = 4 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_recession',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and (G.GAME.dollars or 0) <= 0 then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 580: Stimulus Package
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_stimulus_package',
    discovered = true,
    config = { extra = { money = 10, threshold = 10 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_stimulus_package',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.entering_shop then
            if (G.GAME.dollars or 0) < card.ability.extra.threshold then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 581: Lottery
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_lottery',
    discovered = true,
    config = { extra = { chance = 100, money = 100 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_lottery',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance, extra.money } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if pseudorandom('lottery') < G.GAME.probabilities.normal / card.ability.extra.chance then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 582: Insurance
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_insurance',
    discovered = true,
    config = { extra = { money = 20 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_insurance',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_insurance_active = (G.GAME.odyssey_insurance_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_insurance_active = (G.GAME.odyssey_insurance_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 583: Retirement
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_retirement',
    discovered = true,
    config = { extra = { gain = 1 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_retirement',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.gain } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra_value = (card.ability.extra_value or 0) + card.ability.extra.gain
            card:set_cost()
            return {
                message = localize('k_val_up'),
                colour = G.C.MONEY
            }
        end
    end
})

-- 584: Venture Capital
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_venture_capital',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_venture_capital',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.dollars >= 10 then
                ease_dollars(-10)
                if pseudorandom('venture') < 0.5 then
                    ease_dollars(30)
                    return {
                        message = localize('$') .. "30",
                        colour = G.C.MONEY
                    }
                else
                    return {
                        message = "Fail!",
                        colour = G.C.RED
                    }
                end
            end
        end
    end
})

-- 585: Credit Card
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_credit_card_2',
    discovered = true,
    config = { extra = 20 },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_credit_card_2',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card) G.GAME.bankrupt_at = G.GAME.bankrupt_at - card.ability.extra end,
    remove_from_deck = function(self, card) G.GAME.bankrupt_at = G.GAME.bankrupt_at + card.ability.extra end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 586: Compound Interest
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_compound_interest',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_compound_interest',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            G.GAME.interest_cap = G.GAME.interest_cap + 5
            return {
                message = localize('k_val_up'),
                colour = G.C.MONEY
            }
        end
    end
})

-- 587: Day Trader
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_day_trader',
    discovered = true,
    config = { extra = 2 },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_day_trader',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_day_trader_active = (G.GAME.odyssey_day_trader_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_day_trader_active = (G.GAME.odyssey_day_trader_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 588: Oil Tycoon
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_oil_tycoon',
    discovered = true,
    config = { extra = { money = 1 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_economy_oil_tycoon',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Spades') or context.other_card:is_suit('Clubs') then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$') .. card.ability.extra.money,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end
})


-- ============================================
-- ECONOMY - Rare (Jokers 589-598)
-- ============================================

-- 589: The Great Depression
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_the_great_depression',
    discovered = true,
    config = { extra = { xmult = 1, lost = 0 } },
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_the_great_depression',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult, extra.lost } }

    end,
    add_to_deck = function(self, card)
        local loss = G.GAME.dollars or 0
        G.GAME.dollars = 0
        card.ability.extra.lost = loss
        card.ability.extra.xmult = 1 + math.floor(loss / 5)
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 590: Midas
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_midas',
    discovered = true,
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_midas',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.before then
            for k, v in ipairs(context.scoring_hand) do
                if v:is_face() then
                    v:set_ability(G.P_CENTERS.m_odyssey_plastic, nil, true)
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            v:juice_up()
                            return true
                        end
                    }))
                end
            end
        end
    end
})

-- 591: Philosopher's Stone
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_philosophers_stone',
    discovered = true,
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_philosophers_stone',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.discard and not context.other_card then
            -- Note: context.other_card is nil if multiple cards are discarded?
            -- Steamodded calls calculate for EACH card discarded if it's context.discard.
            -- Wait, if I want to target the card being discarded, I should check context.other_card.
        end
        if context.discard and context.other_card then
            context.other_card:set_ability(G.P_CENTERS.m_odyssey_plastic, nil, true)
            G.E_MANAGER:add_event(Event({
                func = function()
                    context.other_card:juice_up()
                    return true
                end
            }))
        end
    end
})

-- 592: Money Printer
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_money_printer',
    discovered = true,
    config = { extra = { chance = 3 } },
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_money_printer',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.blueprint then
            if pseudorandom('money_printer') < G.GAME.probabilities.normal / card.ability.extra.chance then
                local amt = G.GAME.odyssey_banker_money or 0
                if amt > 0 then
                    ease_dollars(amt)
                    return {
                        message = localize('$') .. amt,
                        colour = G.C.MONEY
                    }
                end
            end
        end
    end
})

-- 593: Central Bank
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_central_bank',
    discovered = true,
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_central_bank',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.interest_cap = 50
    end,
    remove_from_deck = function(self, card)
        G.GAME.interest_cap = 5
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 594: Mercenary
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_mercenary',
    discovered = true,
    config = { extra = { xmult = 5, cost = 1 } },
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_mercenary',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult, extra.cost } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local fee = card.ability.extra.cost * #context.scoring_hand
            if fee > 0 then
                ease_dollars(-fee)
            end
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 595: Make it Rain
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_make_it_rain',
    discovered = true,
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_make_it_rain',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.after and not context.blueprint then
             local hand_chips = G.GAME.hands[context.scoring_name].chips
             local hand_mult = G.GAME.hands[context.scoring_name].mult
             local excess_mult = math.floor(hand_mult - (G.GAME.blind.chips / hand_chips))
             if excess_mult > 0 then
                 ease_dollars(excess_mult)
                 return {
                     message = localize('$') .. excess_mult,
                     colour = G.C.MONEY
                 }
             end
        end
    end
})

-- 596: Blood Diamond
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_blood_diamond',
    discovered = true,
    config = { extra = { money = 50 } },
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_blood_diamond',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.money } }

    end,
    add_to_deck = function(self, card)
        ease_dollars(card.ability.extra.money)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - 1
        ease_hands_played(-1)
    end,
    remove_from_deck = function(self, card)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + 1
        ease_hands_played(1)
    end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 597: Fool's Gold
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_fools_gold',
    discovered = true,
    config = { extra = { mult = 50 } },
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_fools_gold',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_fools_gold_active = (G.GAME.odyssey_fools_gold_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_fools_gold_active = (G.GAME.odyssey_fools_gold_active or 1) - 1 end,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_plastic then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            end
        end
    end
})

-- 598: Utopia
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_utopia',
    discovered = true,
    rarity = 3,
    cost = 8,
    atlas = 'j_economy_utopia',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_utopia_active = (G.GAME.odyssey_utopia_active or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_utopia_active = (G.GAME.odyssey_utopia_active or 1) - 1
    end,
    calculate = function(self, card, context)
        if context.buy_card and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                func = function()
                    card:start_dissolve()
                    return true
                end
            }))
            return {
                message = "Used!",
                colour = G.C.RED
            }
        end
    end
})


-- ============================================
-- ECONOMY - Legendary (Jokers 599-600)
-- ============================================

-- 599: Mammon
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_mammon',
    discovered = true,
    config = { extra = { xmult = 5 } },
    rarity = 4,
    cost = 20,
    atlas = 'j_economy_mammon',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            local bonus = G.GAME.dollars or 0
            if bonus > 0 then
                ease_dollars(bonus)
                return {
                    message = localize('$') .. bonus,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 600: The Market's Hand
SMODS.Joker({
    unlocked = true,
    key = 'j_economy_markets_hand',
    discovered = true,
    rarity = 4,
    cost = 20,
    atlas = 'j_economy_markets_hand',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_market_hand_active = (G.GAME.odyssey_market_hand_active or 0) + 1
        G.E_MANAGER:add_event(Event({func = function()
            if G.shop then
                G.shop.config.card_limit = G.shop.config.card_limit + 5
            end
            return true
        end}))
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_market_hand_active = (G.GAME.odyssey_market_hand_active or 1) - 1
        G.E_MANAGER:add_event(Event({func = function()
            if G.shop then
                G.shop.config.card_limit = G.shop.config.card_limit - 5
            end
            return true
        end}))
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- ============================================
-- TIME & TURNS - Common (Jokers 601-620)
-- ============================================

-- 601: Hourglass
SMODS.Joker({
    unlocked = true,
    key = 'j_time_hourglass',
    discovered = true,
    config = { extra = { mult = 20, loss = 2, current_mult = 20 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_hourglass',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.loss, extra.current_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.current_mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.current_mult } }
            }
        end
        if context.after and not context.blueprint then
            card.ability.extra.current_mult = math.max(0, card.ability.extra.current_mult - card.ability.extra.loss)
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current_mult = card.ability.extra.mult
        end
    end
})

-- 602: Stopwatch
SMODS.Joker({
    unlocked = true,
    key = 'j_time_stopwatch',
    discovered = true,
    config = { extra = { chips = 30 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_stopwatch',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.current_round.hands_played == 0 then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    end
})

-- 603: Countdown
SMODS.Joker({
    unlocked = true,
    key = 'j_time_countdown',
    discovered = true,
    config = { extra = { start = 10, current = 10, reward = 50 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_countdown',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.start, extra.reward, extra.current } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current = card.ability.extra.current - 1
            if card.ability.extra.current <= 0 then
                ease_dollars(card.ability.extra.reward)
                card.ability.extra.current = card.ability.extra.start
                return {
                    message = localize('$') .. card.ability.extra.reward,
                    colour = G.C.MONEY
                }
            end
            return {
                message = card.ability.extra.current .. '',
                colour = G.C.FILTER
            }
        end
    end
})

-- 604: Patience
SMODS.Joker({
    unlocked = true,
    key = 'j_time_patience',
    discovered = true,
    config = { extra = { time = 30, mult = 20 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_patience',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.time, extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local current_time = G.TIMERS.REAL
            local last_time = G.GAME.last_hand_time or current_time
            if (current_time - last_time) >= card.ability.extra.time then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
        if context.after then
            G.GAME.last_hand_time = G.TIMERS.REAL
        end
    end
})

-- 605: Haste
SMODS.Joker({
    unlocked = true,
    key = 'j_time_haste',
    discovered = true,
    config = { extra = { time = 5, mult = 10 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_haste',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.time } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local current_time = G.TIMERS.REAL
            local last_time = G.GAME.last_hand_time or current_time
            if (current_time - last_time) <= card.ability.extra.time then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
        if context.after then
            G.GAME.last_hand_time = G.TIMERS.REAL
        end
    end
})

-- 606: Extra Turn
SMODS.Joker({
    unlocked = true,
    key = 'j_time_extra_turn',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_time_extra_turn',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + 1
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - 1
        ease_hands_played(1)
        ease_discard(-1)
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - 1
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + 1
        ease_hands_played(-1)
        ease_discard(1)
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 607: Rush Hour
SMODS.Joker({
    unlocked = true,
    key = 'j_time_rush_hour',
    discovered = true,
    config = { extra = { chips = 50 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_rush_hour',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and (G.GAME.current_round.discards_left or 0) == 0 then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- 608: Delay
SMODS.Joker({
    unlocked = true,
    key = 'j_time_delay',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_time_delay',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local bonus = G.GAME.current_round.last_hand_mult or 0
            if bonus > 0 then
                ease_dollars(bonus)
                return {
                    message = localize('$') .. bonus,
                    colour = G.C.MONEY
                }
            end
        end
        if context.joker_main then
            G.GAME.current_round.last_hand_mult = context.mult
        end
    end
})

-- 609: Cycle
SMODS.Joker({
    unlocked = true,
    key = 'j_time_cycle',
    discovered = true,
    config = { extra = { rounds = 4, current = 4 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_cycle',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.rounds, extra.current } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.current = card.ability.extra.current - 1
            if card.ability.extra.current <= 0 then
                card.ability.extra.current = card.ability.extra.rounds
                G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()
                    local key = 'p_arcana_normal_' .. (math.random(1, 2))
                    local card = Card(G.play.T.x, G.play.T.y, G.CARD_W*1.27, G.CARD_H*1.27, G.P_CARDS.empty, G.P_CENTERS[key], {bypass_discovery_center = true, bypass_discovery_ui = true})
                    card:set_edition(nil, true, true)
                    card:draw_from_deck()
                    G.play:emplace(card)
                    G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()
                        card:use_booster_pack()
                        return true
                    end}))
                    return true
                end}))
                return {
                    message = "Cycle!",
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

-- 610: Seasons
SMODS.Joker({
    unlocked = true,
    key = 'j_time_seasons',
    discovered = true,
    config = { extra = { suit = 'Hearts', index = 1 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_seasons',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        return { 
            vars = { localize(( (card and card.ability and card.ability.extra) or self.config.extra ).suit, 'suits_plural'), colours = { G.C.SUITS[( (card and card.ability and card.ability.extra) or self.config.extra ).suit] } }
        }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit(card.ability.extra.suit) then
                    count = count + 1
                end
            end
            if count > 0 then
                return {
                    mult_mod = count * 5,
                    chips_mod = count * 20,
                    message = localize { type = 'variable', key = 'a_mult', vars = { count * 5 } }
                }
            end
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            local suits = { 'Hearts', 'Spades', 'Diamonds', 'Clubs' }
            card.ability.extra.index = (card.ability.extra.index % 4) + 1
            card.ability.extra.suit = suits[card.ability.extra.index]
            return {
                message = localize(card.ability.extra.suit, 'suits_plural'),
                colour = G.C.FILTER
            }
        end
    end
})

-- 611: Day and Night
SMODS.Joker({
    unlocked = true,
    key = 'j_time_day_night',
    discovered = true,
    config = { extra = { chips = 50, mult = 10, state = 'day' } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_day_night',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.mult, extra.state } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if card.ability.extra.state == 'day' then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            else
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
        if context.after and not context.blueprint then
            card.ability.extra.state = (card.ability.extra.state == 'day') and 'night' or 'day'
        end
    end
})

-- 612: Sundial
SMODS.Joker({
    unlocked = true,
    key = 'j_time_sundial',
    discovered = true,
    config = { extra = { mult_per_card = 0.5 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_sundial',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local deck_count = (G.deck and G.deck.cards) and #G.deck.cards or 0
        local current_mult = deck_count * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_card
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_card, current_mult } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local deck_count = (G.deck and G.deck.cards) and #G.deck.cards or 0
            local current_mult = deck_count * card.ability.extra.mult_per_card
            return {
                mult_mod = current_mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { current_mult } }
            }
        end
    end
})

-- 613: Pendulum
SMODS.Joker({
    unlocked = true,
    key = 'j_time_pendulum',
    discovered = true,
    config = { extra = { xmult_low = 0.5, xmult_high = 2.0, state = 'low' } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_pendulum',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local current = (( (card and card.ability and card.ability.extra) or self.config.extra ).state == 'low') and ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_low or ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_high
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_low, ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_high, current } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local current = (card.ability.extra.state == 'low') and card.ability.extra.xmult_low or card.ability.extra.xmult_high
            return {
                x_mult = current,
                message = localize { type = 'variable', key = 'a_xmult', vars = { current } }
            }
        end
        if context.after and not context.blueprint then
            card.ability.extra.state = (card.ability.extra.state == 'low') and 'high' or 'low'
        end
    end
})

-- 614: Metronome
SMODS.Joker({
    unlocked = true,
    key = 'j_time_metronome',
    discovered = true,
    config = { extra = { mult = 20, last_count = nil } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_metronome',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.last_count or '?' } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if card.ability.extra.last_count and #context.full_hand == card.ability.extra.last_count then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
        if context.after and not context.blueprint then
            card.ability.extra.last_count = #context.full_hand
        end
    end
})

-- 615: Time Zone
SMODS.Joker({
    unlocked = true,
    key = 'j_time_zone',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_time_zone',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card:is_suit('Spades') or context.other_card:is_suit('Hearts') then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- 616: Ice Age
SMODS.Joker({
    unlocked = true,
    key = 'j_time_ice_age',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_time_ice_age',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card) G.GAME.odyssey_ice_age_active = (G.GAME.odyssey_ice_age_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_ice_age_active = (G.GAME.odyssey_ice_age_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 617: Stone Age
SMODS.Joker({
    unlocked = true,
    key = 'j_time_stone_age',
    discovered = true,
    rarity = 1,
    cost = 4,
    atlas = 'j_time_stone_age',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local front_cards = {}
            for k, v in ipairs(G.playing_cards) do
                if not v.config.center_key or v.config.center_key == 'c_base' then
                    table.insert(front_cards, v)
                end
            end
            if #front_cards > 0 then
                local target = pseudorandom_element(front_cards, pseudoseed('stone_age'))
                target:set_ability(G.P_CENTERS.m_odyssey_emerald)
                return {
                    message = localize('k_stone'),
                    colour = G.C.GREY
                }
            end
        end
    end
})

-- 618: Bronze Age
SMODS.Joker({
    unlocked = true,
    key = 'j_time_bronze_age',
    discovered = true,
    config = { extra = { chips = 15 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_bronze_age',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local rank = context.other_card:get_id()
            if rank >= 2 and rank <= 10 then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
    end
})

-- 619: Iron Age
SMODS.Joker({
    unlocked = true,
    key = 'j_time_iron_age',
    discovered = true,
    config = { extra = { chips = 30 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_iron_age',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_odyssey_platinum then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
    end
})

-- 620: Future
SMODS.Joker({
    unlocked = true,
    key = 'j_time_future',
    discovered = true,
    config = { extra = { mult = 15 } },
    rarity = 1,
    cost = 4,
    atlas = 'j_time_future',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end,
    update = function(self, card)
        if G.STAGE == G.STAGES.RUN and G.deck and G.deck.cards and #G.deck.cards > 0 and not G.GAME.blind.animating then
            local top_card = G.deck.cards[#G.deck.cards]
            if top_card.facing == 'back' then
                top_card.facing = 'front'
                top_card.sprite_facing = 'front'
            end
        end
    end
})


-- ============================================
-- TIME & TURNS - Uncommon (Jokers 621-638)
-- ============================================

-- 621: Time Machine
SMODS.Joker({
    unlocked = true,
    key = 'j_time_machine',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_machine',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.selling_self then
            G.GAME.chips = 0
            G.GAME.current_round.hands_played = 0
            G.GAME.current_round.discards_used = 0
            G.GAME.current_round.hands_left = G.GAME.round_resets.hands
            G.GAME.current_round.discards_left = G.GAME.round_resets.discards
            return {
                message = localize('k_reset'),
                colour = G.C.BLUE
            }
        end
    end
})

-- 622: Back to the Future
SMODS.Joker({
    unlocked = true,
    key = 'j_time_back_to_the_future',
    discovered = true,
    config = { extra = { xmult = 3 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_back_to_the_future',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if not G.GAME.odyssey_first_hand_ever then
                G.GAME.odyssey_first_hand_ever = context.poker_hand
            end
            if context.poker_hand == G.GAME.odyssey_first_hand_ever then
                return {
                    x_mult = card.ability.extra.xmult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
                }
            end
        end
    end
})

-- 623: Doppler Effect
SMODS.Joker({
    unlocked = true,
    key = 'j_time_doppler_effect',
    discovered = true,
    config = { extra = { mult = 5 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_doppler_effect',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local pos = 1
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i] == context.other_card then
                    pos = i
                    break
                end
            end
            local bonus = pos * card.ability.extra.mult
            return {
                mult = bonus,
                card = card
            }
        end
    end
})

-- 624: Relativity
SMODS.Joker({
    unlocked = true,
    key = 'j_time_relativity',
    discovered = true,
    config = { extra = { chips = 100, xmult = 1.5, threshold = 5 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_relativity',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.xmult, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local current_time = G.TIMERS.REAL
            local last_time = G.GAME.last_hand_time or current_time
            local diff = current_time - last_time
            if diff <= card.ability.extra.threshold then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            else
                return {
                    x_mult = card.ability.extra.xmult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
                }
            end
        end
        if context.after then
            G.GAME.last_hand_time = G.TIMERS.REAL
        end
    end
})

-- 625: Wormhole
SMODS.Joker({
    unlocked = true,
    key = 'j_time_wormhole',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_wormhole',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card) G.GAME.odyssey_wormhole_active = (G.GAME.odyssey_wormhole_active or 0) + 1 end,
    remove_from_deck = function(self, card) G.GAME.odyssey_wormhole_active = (G.GAME.odyssey_wormhole_active or 0) - 1 end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 626: Time Skip
SMODS.Joker({
    unlocked = true,
    key = 'j_time_skip',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_skip',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            if G.GAME.blind.name == 'Small Blind' and G.GAME.current_round.hands_played == 1 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        G.GAME.blind:skip()
                        G.STATE = G.STATES.NEW_ROUND
                        return true
                    end
                }))
            end
        end
    end
})

-- 627: Time Freeze
SMODS.Joker({
    unlocked = true,
    key = 'j_time_freeze',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_freeze',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_time_freeze_active = (G.GAME.odyssey_time_freeze_active or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_time_freeze_active = (G.GAME.odyssey_time_freeze_active or 1) - 1
    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
             G.E_MANAGER:add_event(Event({func = function()
                 card:start_dissolve()
                 return true
             end}))
        end
    end
})

-- 628: Time Loop
SMODS.Joker({
    unlocked = true,
    key = 'j_time_loop',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_loop',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card == context.scoring_hand[1] then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 3,
                    card = card
                }
            end
        end
    end
})

-- 629: Grandfather Paradox
SMODS.Joker({
    unlocked = true,
    key = 'j_time_grandfather_paradox',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_grandfather_paradox',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        -- Logic is in G.FUNCS.die override in 03_vanilla_override.lua
    end
})

-- 630: Precognition
SMODS.Joker({
    unlocked = true,
    key = 'j_time_precognition',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_precognition',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_precognition = (G.GAME.odyssey_precognition or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_precognition = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 631: Deja Vu
SMODS.Joker({
    unlocked = true,
    key = 'j_time_deja_vu',
    discovered = true,
    config = { extra = { xmult = 2 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_deja_vu',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.last_poker_hand == context.poker_hand then
                return {
                    x_mult = card.ability.extra.xmult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
                }
            end
        end
        if context.after and not context.blueprint then
            G.GAME.last_poker_hand = context.poker_hand
        end
    end
})

-- 632: Eternity
SMODS.Joker({
    unlocked = true,
    key = 'j_time_eternity',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_eternity',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    calculate = function(self, card, context)
        for i = 1, #G.jokers.cards do
            local j = G.jokers.cards[i]
            if j.transient then
                j.transient = false
            end
        end
    end
})

-- 633: Ephemeral
SMODS.Joker({
    unlocked = true,
    key = 'j_time_ephemeral',
    discovered = true,
    config = { extra = { mult = 50, rounds = 3 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_ephemeral',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.rounds } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.rounds = card.ability.extra.rounds - 1
            if card.ability.extra.rounds <= 0 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        if not card.ability.eternal then card:start_dissolve() end
                        return true
                    end
                }))
                return {
                    message = localize('k_lost_ex'),
                    colour = G.C.RED
                }
            end
        end
    end
})

-- 634: Chronokinesis
SMODS.Joker({
    unlocked = true,
    key = 'j_time_chronokinesis',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_chronokinesis',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card)
        G.GAME.odyssey_chronokinesis = (G.GAME.odyssey_chronokinesis or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_chronokinesis = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 635: Synchronicity
SMODS.Joker({
    unlocked = true,
    key = 'j_time_synchronicity',
    discovered = true,
    config = { extra = { xmult = 3 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_synchronicity',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local first_rank = context.scoring_hand[1]:get_id()
            local all_same = true
            for i = 2, #context.scoring_hand do
                if context.scoring_hand[i]:get_id() ~= first_rank then
                    all_same = false
                    break
                end
            end
            if all_same then
                return {
                    x_mult = card.ability.extra.xmult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
                }
            end
        end
    end
})

-- 636: Anachronism
SMODS.Joker({
    unlocked = true,
    key = 'j_time_anachronism',
    discovered = true,
    rarity = 2,
    cost = 6,
    atlas = 'j_time_anachronism',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_anachronism = (G.GAME.odyssey_anachronism or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_anachronism = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 637: Lost Time
SMODS.Joker({
    unlocked = true,
    key = 'j_time_lost_time',
    discovered = true,
    config = { extra = { chips = 100 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_lost_time',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- 638: End Times
SMODS.Joker({
    unlocked = true,
    key = 'j_time_end_times',
    discovered = true,
    config = { extra = { xmult = 4 } },
    rarity = 2,
    cost = 6,
    atlas = 'j_time_end_times',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.blind.boss and G.GAME.current_round.hands_left == 0 then
                return {
                    x_mult = card.ability.extra.xmult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
                }
            end
        end
    end
})


-- ============================================
-- TIME & TURNS - Rare (Jokers 639-648)
-- ============================================

-- 639: Time Lord
SMODS.Joker({
    unlocked = true,
    key = 'j_time_time_lord',
    discovered = true,
    config = { extra = { hands = 1, discards = 1, slots = 1 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_time_lord',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra.hands
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards
        G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.slots
        ease_hands_played(card.ability.extra.hands)
        ease_discard(card.ability.extra.discards)
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hands
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards
        G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.slots
        ease_hands_played(-card.ability.extra.hands)
        ease_discard(-card.ability.extra.discards)
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 640: The World
SMODS.Joker({
    unlocked = true,
    key = 'j_time_the_world',
    discovered = true,
    config = { extra = { xmult = 2 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_the_world',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 641: Aeon
SMODS.Joker({
    unlocked = true,
    key = 'j_time_aeon',
    discovered = true,
    config = { extra = { xmult = 1 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_aeon',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.xmult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            card.ability.extra.xmult = card.ability.extra.xmult + 0.1
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
    end
})

-- 642: Kairos
SMODS.Joker({
    unlocked = true,
    key = 'j_time_kairos',
    discovered = true,
    config = { extra = { xmult = 5 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_kairos',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_left == 0 then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 643: Chronos
SMODS.Joker({
    unlocked = true,
    key = 'j_time_chronos',
    discovered = true,
    config = { extra = { dollars_per_hand = 2 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_chronos',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
            local bonus = G.GAME.current_round.hands_left * card.ability.extra.dollars_per_hand
            if bonus > 0 then
                ease_dollars(bonus)
                return {
                    message = localize('$') .. bonus,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- 644: Ouroboros
SMODS.Joker({
    unlocked = true,
    key = 'j_time_ouroboros',
    discovered = true,
    rarity = 3,
    cost = 10,
    atlas = 'j_time_ouroboros',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_ouroboros = (G.GAME.odyssey_ouroboros or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_ouroboros = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 645: Reverse Entropy
SMODS.Joker({
    unlocked = true,
    key = 'j_time_reverse_entropy',
    discovered = true,
    rarity = 3,
    cost = 10,
    atlas = 'j_time_reverse_entropy',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_reverse_entropy = (G.GAME.odyssey_reverse_entropy or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_reverse_entropy = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 646: Big Crunch
SMODS.Joker({
    unlocked = true,
    key = 'j_time_big_crunch',
    discovered = true,
    config = { extra = { xmult = 10, hand_size = -7 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_big_crunch',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 647: Big Bang
SMODS.Joker({
    unlocked = true,
    key = 'j_time_big_bang',
    discovered = true,
    config = { extra = { mult_minus = 2, hand_size = 5 } },
    rarity = 3,
    cost = 10,
    atlas = 'j_time_big_bang',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    add_to_deck = function(self, card, from_debuff)
        G.hand.config.card_limit = G.hand.config.card_limit + card.ability.extra.hand_size
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.hand.config.card_limit = G.hand.config.card_limit - card.ability.extra.hand_size
    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.hand then
            return {
                mult = -card.ability.extra.mult_minus,
                card = card
            }
        end
    end
})

-- 648: Sacred Timeline
SMODS.Joker({
    unlocked = true,
    key = 'j_time_sacred_timeline',
    discovered = true,
    rarity = 3,
    cost = 10,
    atlas = 'j_time_sacred_timeline',
    pos = { x = 0, y = 0 },
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.GAME.odyssey_sacred_timeline = (G.GAME.odyssey_sacred_timeline or 0) + 1
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_sacred_timeline = nil
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- ============================================
-- TIME & TURNS - Legendary (Jokers 649-650)
-- ============================================

-- 649: Father Time
SMODS.Joker({
    unlocked = true,
    key = 'j_time_father_time',
    discovered = true,
    config = { extra = { xmult = 5 } },
    rarity = 4,
    cost = 20,
    atlas = 'j_time_father_time',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).xmult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})

-- 650: Guardian of Eternity
SMODS.Joker({
    unlocked = true,
    key = 'j_time_guardian_of_eternity',
    discovered = true,
    config = { extra = { xmult = 4 } },
    rarity = 4,
    cost = 20,
    atlas = 'j_time_guardian_of_eternity',
    pos = { x = 0, y = 0 },
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).xmult } } end,
    add_to_deck = function(self, card)
        G.GAME.odyssey_guardian_of_eternity = (G.GAME.odyssey_guardian_of_eternity or 0) + 1
        if G.jokers and G.jokers.cards then
            for _, v in ipairs(G.jokers.cards) do
                v.ability.eternal = true
            end
        end
    end,
    remove_from_deck = function(self, card)
        G.GAME.odyssey_guardian_of_eternity = nil
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.xmult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.xmult } }
            }
        end
    end
})


-- ============================================
-- HAND AND DISCARD - Common (Jokers 651-670)
-- ============================================

-- 651. Extra Hand
SMODS.Joker({
    key = 'j_hand_and_discard_extra_hand',
    config = { extra = 1 },
    rarity = 1,
    atlas = 'j_hand_and_discard_extra_hand',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then
            G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra
        end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then
            G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 652. Extra Discard
SMODS.Joker({
    key = 'j_hand_and_discard_extra_discard',
    config = { extra = 1 },
    rarity = 1,
    atlas = 'j_hand_and_discard_extra_discard',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then
            G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra
        end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then
            G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 653. Recycling
SMODS.Joker({
    key = 'j_hand_and_discard_recycling',
    config = { extra = { hands_needed = 2, hands_played = 0 } },
    rarity = 1,
    atlas = 'j_hand_and_discard_recycling',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.after and not context.blueprint then
            card.ability.extra.hands_played = card.ability.extra.hands_played + 1
            if card.ability.extra.hands_played >= card.ability.extra.hands_needed then
                card.ability.extra.hands_played = 0
                G.GAME.current_round.discards_left = G.GAME.current_round.discards_left + 1
                return {
                    message = localize('k_plus_discard'),
                    colour = G.C.RED,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).hands_needed, (( (card and card.ability and card.ability.extra) or self.config.extra )).hands_played } } end
})

-- 654. Trash Can
SMODS.Joker({
    key = 'j_hand_and_discard_trash_can',
    config = { extra = 1 },
    rarity = 1,
    atlas = 'j_hand_and_discard_trash_can',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.discard and G.GAME.current_round.discards_left <= 0 then
            ease_dollars(card.ability.extra)
            return {
                message = localize('$')..card.ability.extra,
                colour = G.C.MONEY,
                card = card
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 655. Full Hand
SMODS.Joker({
    key = 'j_hand_and_discard_full_hand',
    config = { extra = 20 },
    rarity = 1,
    atlas = 'j_hand_and_discard_full_hand',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and #context.full_hand == 5 then
            return {
                message = localize{type='variable', key='a_chips', vars={card.ability.extra}},
                chip_mod = card.ability.extra,
                colour = G.C.CHIPS
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 656. Empty Hand
SMODS.Joker({
    key = 'j_hand_and_discard_empty_hand',
    config = { extra = 20 },
    rarity = 1,
    atlas = 'j_hand_and_discard_empty_hand',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and #context.full_hand <= 2 then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra}},
                mult_mod = card.ability.extra,
                colour = G.C.MULT
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 657. Juggler
SMODS.Joker({
    key = 'j_hand_and_discard_juggler',
    config = { extra = 1 },
    rarity = 1,
    atlas = 'j_hand_and_discard_juggler',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = false,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then
            G.hand:change_size(card.ability.extra)
        end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then
            G.hand:change_size(-card.ability.extra)
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 658. Street Magician
SMODS.Joker({
    key = 'j_hand_and_discard_street_magician',
    config = { extra = { odds = 5, money = 2 } },
    rarity = 1,
    atlas = 'j_hand_and_discard_street_magician',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.discard and not context.other_card then
            if pseudorandom('street_magician') < G.GAME.probabilities.normal / card.ability.extra.odds then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$')..card.ability.extra.money,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds, ( (card and card.ability and card.ability.extra) or self.config.extra ).money } } end
})

-- 659. Cards Up Sleeve
SMODS.Joker({
    key = 'j_hand_and_discard_cards_up_sleeve',
    config = { extra = { odds = 4 } },
    rarity = 1,
    atlas = 'j_hand_and_discard_cards_up_sleeve',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            if pseudorandom('cards_up_sleeve') < G.GAME.probabilities.normal / card.ability.extra.odds then
                G.E_MANAGER:add_event(Event({
                    trigger = 'before',
                    delay = 0.5,
                    func = function()
                        draw_card(G.deck, G.hand, 90, 'up', nil)
                        return true
                    end
                }))
                return {
                    message = "Extra Card!",
                    colour = G.C.BLUE,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } } end
})

-- 660. Dealer
SMODS.Joker({
    key = 'j_hand_and_discard_dealer',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_hand_and_discard_dealer',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                message = localize{type='variable', key='a_mult', vars={card.ability.extra}},
                mult_mod = card.ability.extra,
                colour = G.C.MULT
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 661. Auto Shuffler
SMODS.Joker({
    key = 'j_hand_and_discard_auto_shuffler',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_hand_and_discard_auto_shuffler',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            G.E_MANAGER:add_event(Event({ func = function()
                table.sort(G.deck.cards, function(a, b) 
                    return (a.base.value or 0) > (b.base.value or 0) 
                end)
                return true
            end }))
            return { message = "Sorted!", colour = G.C.BLUE }
        end
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end
})

-- 662. Deck Cut
SMODS.Joker({
    key = 'j_hand_and_discard_deck_cut',
    config = { extra = { mult = 15, cards = 5 } },
    rarity = 1,
    atlas = 'j_hand_and_discard_deck_cut',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            G.E_MANAGER:add_event(Event({ func = function()
                for i=1, card.ability.extra.cards do
                    if G.deck.cards[1] then
                        local deleted_card = G.deck.cards[1]
                        draw_card(G.deck, G.discard, i*100/card.ability.extra.cards, 'down', false, deleted_card)
                    end
                end
                return true
            end }))
            return { message = "Cut!", colour = G.C.RED }
        end
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).cards, (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end
})

-- 663. Ghost Hand
SMODS.Joker({
    key = 'j_hand_and_discard_ghost_hand',
    config = { extra = 1, extra_hand_given = false },
    rarity = 1,
    atlas = 'j_hand_and_discard_ghost_hand',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.after and G.GAME.current_round.hands_left == 0 and not card.ability.extra_hand_given then
             G.GAME.current_round.hands_left = G.GAME.current_round.hands_left + 1
             card.ability.extra_hand_given = true
             return { 
                 message = "Ghost Hand!",
                 colour = G.C.FILTER
             }
        end
        if context.end_of_round and not context.other_card then card.ability.extra_hand_given = false end
    end
})

-- 664. Tactical Discard
SMODS.Joker({
    key = 'j_hand_and_discard_tactical_discard',
    config = { extra = { mult = 10, active = false } },
    rarity = 1,
    atlas = 'j_hand_and_discard_tactical_discard',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and not context.other_card then
            if #context.full_hand == 1 then
                card.ability.extra.active = true
                return { 
                    message = "Tactical!",
                    colour = G.C.RED
                }
            end
        end
        if context.joker_main and card.ability.extra.active then
            card.ability.extra.active = false
            return { 
                mult_mod = card.ability.extra.mult,
                message = localize{type='variable', key='a_mult', vars={card.ability.extra.mult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end
})

-- 665. Steady Hand
SMODS.Joker({
    key = 'j_hand_and_discard_steady_hand',
    config = { extra = 1.5 },
    rarity = 1,
    atlas = 'j_hand_and_discard_steady_hand',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_used == 0 then
            return { x_mult = card.ability.extra }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 666. Shaky Hand
SMODS.Joker({
    key = 'j_hand_and_discard_shaky_hand',
    config = { extra = 50 },
    rarity = 1,
    atlas = 'j_hand_and_discard_shaky_hand',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_left == 0 then
            return { chip_mod = card.ability.extra }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 667. Boxing Glove
SMODS.Joker({
    key = 'j_hand_and_discard_boxing_glove',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_hand_and_discard_boxing_glove',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local hand_count = #G.hand.cards
            return { chip_mod = hand_count * card.ability.extra }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ), (G.hand and G.hand.cards and #G.hand.cards or 0) * ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 668. Silk Glove
SMODS.Joker({
    key = 'j_hand_and_discard_silk_glove',
    config = { extra = 5 },
    rarity = 1,
    atlas = 'j_hand_and_discard_silk_glove',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return { mult_mod = G.GAME.current_round.discards_left * card.ability.extra }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ), G.GAME.current_round.discards_left * ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 669. Gauntlet
SMODS.Joker({
    key = 'j_hand_and_discard_gauntlet',
    config = { extra = { chips = 50, discards = 1 } },
    rarity = 1,
    atlas = 'j_hand_and_discard_gauntlet',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards end
    end,
    calculate = function(self, card, context)
        if context.joker_main then return { chip_mod = card.ability.extra.chips } end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips, (( (card and card.ability and card.ability.extra) or self.config.extra )).discards } } end
})

-- 670. Magic Finger
SMODS.Joker({
    key = 'j_hand_and_discard_magic_finger',
    config = { extra = 1 },
    rarity = 1,
    atlas = 'j_hand_and_discard_magic_finger',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.play.config.card_limit = G.play.config.card_limit + 1 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.play.config.card_limit = G.play.config.card_limit - 1 end
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- ============================================
-- HAND AND DISCARD - Uncommon (Jokers 671-688)
-- ============================================

-- 671. Hand of Midas
SMODS.Joker({
    key = 'j_hand_and_discard_hand_of_midas',
    config = { extra = 10 },
    rarity = 2,
    atlas = 'j_hand_and_discard_hand_of_midas',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local gold_count = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center == G.P_CENTERS.m_odyssey_plastic then gold_count = gold_count + 1 end
            end
            if gold_count >= 5 then
                ease_dollars(card.ability.extra)
                return {
                    message = localize('$')..card.ability.extra,
                    colour = G.C.MONEY,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 672. Iron Hand
SMODS.Joker({
    key = 'j_hand_and_discard_iron_hand',
    config = { extra = 100 },
    rarity = 2,
    atlas = 'j_hand_and_discard_iron_hand',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local steel_count = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center == G.P_CENTERS.m_odyssey_platinum then steel_count = steel_count + 1 end
            end
            if steel_count >= 5 then
                return {
                    mult_mod = card.ability.extra,
                    message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 673. Stone Hand
SMODS.Joker({
    key = 'j_hand_and_discard_stone_hand',
    config = { extra = 200 },
    rarity = 2,
    atlas = 'j_hand_and_discard_stone_hand',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local stone_count = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center == G.P_CENTERS.m_odyssey_emerald then stone_count = stone_count + 1 end
            end
            if stone_count >= 5 then
                return {
                    chip_mod = card.ability.extra,
                    message = localize{type = 'variable', key = 'a_chips', vars = {card.ability.extra}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 674. Glass Hand
SMODS.Joker({
    key = 'j_hand_and_discard_glass_hand',
    config = { extra = 4 },
    rarity = 2,
    atlas = 'j_hand_and_discard_glass_hand',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local glass_count = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center == G.P_CENTERS.m_odyssey_ceramic then glass_count = glass_count + 1 end
            end
            if glass_count >= 5 then
                for k, v in ipairs(context.scoring_hand) do
                    if v.config.center == G.P_CENTERS.m_odyssey_ceramic then
                        v:shatter()
                    end
                end
                return {
                    Xmult_mod = card.ability.extra,
                    message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 675. Helping Hand
SMODS.Joker({
    key = 'j_hand_and_discard_helping_hand',
    rarity = 2,
    atlas = 'j_hand_and_discard_helping_hand',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.before and context.scoring_name == "High Card" and not context.blueprint then
            level_up_hand(card, context.scoring_name, nil, 1)
            return {
                message = localize('k_level_up'),
                colour = G.C.PURPLE
            }
        end
    end
})

-- 676. Dead Hand
SMODS.Joker({
    key = 'j_hand_and_discard_dead_hand',
    config = { extra = 5 },
    rarity = 2,
    atlas = 'j_hand_and_discard_dead_hand',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.after and not context.blueprint and not context.repetition and not context.other_card then
            -- We check if the hand score was 0 (e.g. all debuffed)
            -- This is tricky in after context, so we'll check hand_chips and hand_mult
            if G.GAME.hands[context.scoring_name].chips == 0 or G.GAME.hands[context.scoring_name].mult == 0 then
                ease_dollars(card.ability.extra)
                return { message = localize('$')..card.ability.extra, colour = G.C.MONEY }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 677. Divine Hand
SMODS.Joker({
    key = 'j_hand_and_discard_divine_hand',
    config = { extra = 2 },
    rarity = 2,
    atlas = 'j_hand_and_discard_divine_hand',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played == 0 then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 678. Cursed Hand
SMODS.Joker({
    key = 'j_hand_and_discard_cursed_hand',
    config = { extra = 3 },
    rarity = 2,
    atlas = 'j_hand_and_discard_cursed_hand',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.round_resets.hands = G.GAME.round_resets.hands - 1; ease_hands_played(-1) end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.round_resets.hands = G.GAME.round_resets.hands + 1; ease_hands_played(1) end
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 679. Perfect Discard
SMODS.Joker({
    key = 'j_hand_and_discard_perfect_discard',
    config = { extra = 4 },
    rarity = 2,
    atlas = 'j_hand_and_discard_perfect_discard',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and #context.full_hand == 5 and not context.blueprint then
            local suit = context.full_hand[1].base.suit
            local all_same = true
            for i=2, 5 do if context.full_hand[i].base.suit ~= suit then all_same = false end end
            if all_same then
                ease_dollars(card.ability.extra)
                return { message = localize('$')..card.ability.extra, colour = G.C.MONEY, card = card }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 680. Strategic Discard
SMODS.Joker({
    key = 'j_hand_and_discard_strategic_discard',
    config = { extra = { mult = 20, active = false } },
    rarity = 2,
    atlas = 'j_hand_and_discard_strategic_discard',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and #context.full_hand >= 5 and not context.blueprint then
             local ranks = {}
             for k, v in ipairs(context.full_hand) do table.insert(ranks, v.base.id) end
             table.sort(ranks)
             local is_straight = true
             for i=1, #ranks-1 do
                if ranks[i+1] ~= ranks[i] + 1 then
                    -- Handle Ace low straight
                    if not (i == #ranks-1 and ranks[i] == 5 and ranks[i+1] == 14) then
                        is_straight = false
                        break
                    end
                end
             end
             if is_straight then
                card.ability.extra.active = true
                return { message = "Strategic!", colour = G.C.FILTER }
             end
        end
        if context.joker_main and card.ability.extra.active then
            card.ability.extra.active = false
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra.mult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end
})

-- 681. Gold Discard
SMODS.Joker({
    key = 'j_hand_and_discard_gold_discard',
    config = { extra = 4 },
    rarity = 2,
    atlas = 'j_hand_and_discard_gold_discard',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint and context.other_card.config.center == G.P_CENTERS.m_odyssey_plastic then
            ease_dollars(card.ability.extra)
            return { message = localize('$')..card.ability.extra, colour = G.C.MONEY, card = card }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 682. Steel Discard
SMODS.Joker({
    key = 'j_hand_and_discard_steel_discard',
    config = { extra = { mult = 0, gain = 5 } },
    rarity = 2,
    atlas = 'j_hand_and_discard_steel_discard',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint and context.other_card.config.center == G.P_CENTERS.m_odyssey_platinum then
            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain
            return {
                message = "Up!",
                colour = G.C.MULT
            }
        end
        if context.joker_main and card.ability.extra.mult > 0 then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra.mult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).gain } } end
})

-- 683. Glass Discard

SMODS.Joker({
    key = 'j_hand_and_discard_glass_discard',
    config = { extra = 2 }, -- 1 in 2
    rarity = 2,
    atlas = 'j_hand_and_discard_glass_discard',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint and context.other_card.config.center == G.P_CENTERS.m_odyssey_ceramic then
            if pseudorandom('glass_discard') < G.GAME.probabilities.normal / card.ability.extra then
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.4,
                    func = function()
                        local _card = copy_card(context.other_card, nil, nil, G.hand.cards[1] and G.hand.cards[1].set or 'Default')
                        _card:add_to_deck()
                        G.hand:emplace(_card)
                        return true
                    end
                }))
                return { message = "New Ceramic!", colour = G.C.PALE_GREEN }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 684. Mirrored Hand
SMODS.Joker({
    key = 'j_hand_and_discard_mirrored_hand',
    config = { extra = 2 },
    rarity = 2,
    atlas = 'j_hand_and_discard_mirrored_hand',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 685. Shadow Hand
SMODS.Joker({
    key = 'j_hand_and_discard_shadow_hand',
    rarity = 2,
    atlas = 'j_hand_and_discard_shadow_hand',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.after and not context.blueprint and not card.ability.used_this_round then
            card.ability.used_this_round = true
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    for k, v in ipairs(context.scoring_hand) do
                        local _card = copy_card(v)
                        _card:add_to_deck()
                        G.hand:emplace(_card)
                    end
                    return true
                end
            }))
            return { message = "Shadow Recall!", colour = G.C.PURPLE }
        end
        if context.end_of_round and not context.other_card then card.ability.used_this_round = false end
    end
})

-- 686. Quick Hand
SMODS.Joker({
    key = 'j_hand_and_discard_quick_hand',
    rarity = 2,
    atlas = 'j_hand_and_discard_quick_hand',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + 2
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - 2
        ease_hands_played(2)
        ease_discard(-2)
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - 2
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + 2
        ease_hands_played(-2)
        ease_discard(2)
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 687. Slow Hand
SMODS.Joker({
    key = 'j_hand_and_discard_slow_hand',
    config = { extra = { mult = 10, current_mult = 0 } },
    rarity = 2,
    atlas = 'j_hand_and_discard_slow_hand',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            card.ability.extra.current_mult = card.ability.extra.current_mult + card.ability.extra.mult
            return { message = "+" .. card.ability.extra.mult, colour = G.C.MULT }
        end
        if context.joker_main and card.ability.extra.current_mult > 0 then
            local bonus = card.ability.extra.current_mult
            card.ability.extra.current_mult = 0
            return {
                mult_mod = bonus,
                message = localize{type = 'variable', key = 'a_mult', vars = {bonus}},
                colour = G.C.MULT
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).current_mult } } end
})

-- 688. Ambidextrous
SMODS.Joker({
    key = 'j_hand_and_discard_ambidextrous',
    config = { extra = 10 },
    rarity = 2,
    atlas = 'j_hand_and_discard_ambidextrous',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then
            G.play.config.card_limit = card.ability.extra
        end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then
            G.play.config.card_limit = 10
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})



-- ============================================
-- HAND AND DISCARD - Rare & Legendary (689-700)
-- ============================================

-- 689. Hand of God
SMODS.Joker({
    key = 'j_hand_and_discard_hand_of_god',
    config = { extra = { played = 0, xmult_gain = 0.2 } },
    rarity = 3,
    atlas = 'j_hand_and_discard_hand_of_god',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local current_xmult = 1 + (card.ability.extra.played * card.ability.extra.xmult_gain)
            return {
                Xmult_mod = current_xmult,
                message = localize{type = 'variable', key = 'a_xmult', vars = {current_xmult}}
            }
        end
        if context.buying_card and not context.blueprint then
            card.ability.extra.played = (card.ability.extra.played or 0) + 1
            return {
                message = localize('k_upgrade_ex'),
                colour = G.C.MULT
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_gain, ( (card and card.ability and card.ability.extra) or self.config.extra ).played, 1 + (( (card and card.ability and card.ability.extra) or self.config.extra ).played * ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult_gain) } } end
})

-- 690. Devil's Hand
SMODS.Joker({
    key = 'j_hand_and_discard_devils_hand',
    config = { extra = 3 },
    rarity = 3,
    atlas = 'j_hand_and_discard_devils_hand',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local highest_card = nil
            local max_rank = -1
            for k, v in ipairs(G.hand.cards) do
                if v.base.id > max_rank then
                    max_rank = v.base.id
                    highest_card = v
                end
            end
            if highest_card then
                if not highest_card.ability.eternal then highest_card:start_dissolve() end
            end
        end
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 691. King's Hand
SMODS.Joker({
    key = 'j_hand_and_discard_kings_hand',
    rarity = 3,
    atlas = 'j_hand_and_discard_kings_hand',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.cardarea == G.play and context.repetition and not context.repetition_only then
            local has_king = false
            for k, v in ipairs(context.scoring_hand) do
                if v.base.value == 'King' then has_king = true break end
            end
            if has_king and (context.other_card.base.value == 'King' or context.other_card.base.value == 'Queen') then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- 692. Queen's Hand
SMODS.Joker({
    key = 'j_hand_and_discard_queens_hand',
    config = { extra = { money = 5, mult = 10 } },
    rarity = 3,
    atlas = 'j_hand_and_discard_queens_hand',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_queen = false
            for k, v in ipairs(context.scoring_hand) do
                if v.base.value == 'Queen' then has_queen = true break end
            end
            if has_queen then
                ease_dollars(card.ability.extra.money)
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra.mult}},
                    colour = G.C.MULT,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end
})

-- 693. Jack's Hand
SMODS.Joker({
    key = 'j_hand_and_discard_jacks_hand',
    config = { extra = 50 },
    rarity = 3,
    atlas = 'j_hand_and_discard_jacks_hand',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_jack = false
            for k, v in ipairs(context.scoring_hand) do
                if v.base.value == 'Jack' then has_jack = true break end
            end
            if has_jack then
                local bonus = #context.scoring_hand * card.ability.extra
                return {
                    chip_mod = bonus,
                    message = localize{type = 'variable', key = 'a_chips', vars = {bonus}},
                    colour = G.C.CHIPS,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 694. Ace's Hand
SMODS.Joker({
    key = 'j_hand_and_discard_aces_hand',
    rarity = 3,
    atlas = 'j_hand_and_discard_aces_hand',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local has_ace = false
            for k, v in ipairs(context.scoring_hand) do
                if v.base.value == 'Ace' then has_ace = true break end
            end
            if has_ace then
                for k, v in ipairs(context.scoring_hand) do
                    if v.base.value ~= 'Ace' then
                        v:set_base(G.P_CARDS[v.base.suit..'_A'])
                    end
                end
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.CHIPS,
                    card = card
                }
            end
        end
    end
})

-- 695. Infinite Hand
SMODS.Joker({
    key = 'j_hand_and_discard_infinite_hand',
    rarity = 3,
    atlas = 'j_hand_and_discard_infinite_hand',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.after and not context.blueprint then
            local cards_to_return = {}
            for k, v in ipairs(context.scoring_hand) do
                table.insert(cards_to_return, v)
            end
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    for i = #cards_to_return, 1, -1 do
                        draw_card(G.play, G.deck, 90, 'up', nil, cards_to_return[i])
                    end
                    return true
                end
            }))
            return {
                message = "Refill!",
                colour = G.C.BLUE,
                card = card
            }
        end
    end
})

-- 696. Infinite Discard
SMODS.Joker({
    key = 'j_hand_and_discard_infinite_discard',
    config = { extra = 1 },
    rarity = 3,
    atlas = 'j_hand_and_discard_infinite_discard',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        -- We'll handle this in 03_vanilla_override.lua for the discard button press
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 697. Supreme Hand
SMODS.Joker({
    key = 'j_hand_and_discard_supreme_hand',
    rarity = 3,
    atlas = 'j_hand_and_discard_supreme_hand',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Royal Flush" then
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    G.GAME.chips = G.GAME.blind.chips
                    return true
                end
            }))
            return {
                message = "SUPREME!",
                colour = G.C.GOLD,
                card = card
            }
        end
    end
})

-- 698. Void Hand
SMODS.Joker({
    key = 'j_hand_and_discard_void_hand',
    config = { extra = 10 },
    rarity = 3,
    atlas = 'j_hand_and_discard_void_hand',
    pos = { x = 0, y = 0 },
    cost = 15,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and #context.scoring_hand == 1 and context.scoring_name == "High Card" then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}},
                card = card
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 699. The Creator
SMODS.Joker({
    key = 'j_hand_and_discard_the_creator',
    rarity = 4,
    atlas = 'j_hand_and_discard_the_creator',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then
            G.hand.config.card_limit = G.hand.config.card_limit + 3
            G.GAME.round_resets.hands = G.GAME.round_resets.hands + 2
            G.GAME.round_resets.discards = G.GAME.round_resets.discards + 2
            ease_hands_played(2)
            ease_discard(2)
        end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then
            G.hand.config.card_limit = G.hand.config.card_limit - 3
            G.GAME.round_resets.hands = G.GAME.round_resets.hands - 2
            G.GAME.round_resets.discards = G.GAME.round_resets.discards - 2
            ease_hands_played(-2)
            ease_discard(-2)
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { 3, 2, 2 } } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 700. The Destroyer
SMODS.Joker({
    key = 'j_hand_and_discard_the_destroyer',
    config = { extra = 6 },
    rarity = 4,
    atlas = 'j_hand_and_discard_the_destroyer',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.hand.config.card_limit = G.hand.config.card_limit - 2 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.hand.config.card_limit = G.hand.config.card_limit + 2 end
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}},
                card = card
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ), 2 } } end
})



-- ============================================
-- PROBABILITY AND LUCK - Common (701-720)
-- ============================================

-- 701. Four Leaf Clover
SMODS.Joker({
    key = 'j_luck_and_probability_four_leaf_clover',
    config = { extra = 0.1 },
    rarity = 1,
    atlas = 'j_luck_and_probability_four_leaf_clover',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal + card.ability.extra end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal - card.ability.extra end
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 702. Rabbit's Foot
SMODS.Joker({
    key = 'j_luck_and_probability_rabbit_s_foot',
    config = { extra = { mult = 5, odds = 2 } },
    rarity = 1,
    atlas = 'j_luck_and_probability_rabbit_s_foot',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('rabbit_s_foot') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra.mult}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds, ( (card and card.ability and card.ability.extra) or self.config.extra ).mult } } end
})

-- 703. Horseshoe
SMODS.Joker({
    key = 'j_luck_and_probability_horseshoe',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_luck_and_probability_horseshoe',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.deck and G.deck.cards then
                for k, v in ipairs(G.deck.cards) do
                    if v.config.center == G.P_CENTERS.m_lucky then count = count + 1 end
                end
            end
            if count > 0 then
                local bonus = count * card.ability.extra
                return {
                    chip_mod = bonus,
                    message = localize{type = 'variable', key = 'a_chips', vars = {bonus}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 704. D6 Die
SMODS.Joker({
    key = 'j_luck_and_probability_d6_die',
    rarity = 1,
    atlas = 'j_luck_and_probability_d6_die',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local total_mult = 0
            local dice_sides = (G.GAME.odyssey_dice_master and G.GAME.odyssey_dice_master > 0) and 12 or 6
            local sides = {}
            for i=1, dice_sides do table.insert(sides, i) end
            
            for i=1, #context.scoring_hand do
                total_mult = total_mult + pseudorandom_element(sides, pseudoseed('d6'))
            end
            return {
                mult_mod = total_mult,
                message = "Roll: " .. total_mult,
                colour = G.C.MULT
            }
        end
    end
})

-- 705. D20 Die
SMODS.Joker({
    key = 'j_luck_and_probability_d20_die',
    rarity = 1,
    atlas = 'j_luck_and_probability_d20_die',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local total_chips = 0
            local dice_sides = (G.GAME.odyssey_dice_master and G.GAME.odyssey_dice_master > 0) and 40 or 20
            local sides = {}
            for i=1, dice_sides do table.insert(sides, i) end
            
            for i=1, #context.scoring_hand do
                total_chips = total_chips + pseudorandom_element(sides, pseudoseed('d20'))
            end
            return {
                chip_mod = total_chips,
                message = "Crit: " .. total_chips,
                colour = G.C.CHIPS
            }
        end
    end
})

-- 706. Coin Flip
SMODS.Joker({
    key = 'j_luck_and_probability_coin_flip',
    config = { extra = 2 },
    rarity = 1,
    atlas = 'j_luck_and_probability_coin_flip',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('coin_flip') < G.GAME.probabilities.normal / 2 then
                return {
                    Xmult_mod = card.ability.extra,
                    message = "Heads!"
                }
            else
                return { message = "Tails...", colour = G.C.GREY }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, 2, ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 707. Safe Bet
SMODS.Joker({
    key = 'j_luck_and_probability_safe_bet',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_luck_and_probability_safe_bet',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 708. Risky Bet
SMODS.Joker({
    key = 'j_luck_and_probability_risky_bet',
    config = { extra = { mult = 40, odds = 4 } },
    rarity = 1,
    atlas = 'j_luck_and_probability_risky_bet',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('risky_bet') < G.GAME.probabilities.normal / card.ability.extra.odds then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = "Jackpot!"
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds, ( (card and card.ability and card.ability.extra) or self.config.extra ).mult } } end
})

-- 709. Raffle
SMODS.Joker({
    key = 'j_luck_and_probability_raffle',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_luck_and_probability_raffle',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.blueprint then
            if pseudorandom('raffle') < G.GAME.probabilities.normal / card.ability.extra then
                if #G.jokers.cards < G.jokers.config.card_limit then -- Check capacity
                    local card = create_card('Joker', G.jokers, nil, 0, nil, nil, nil, 'raffle')
                    card:add_to_deck()
                    G.jokers:emplace(card)
                    return { message = localize('k_plus_joker'), colour = G.C.BLUE }
                end
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 710. Bingo
SMODS.Joker({
    key = 'j_luck_and_probability_bingo',
    config = { extra = 5 },
    rarity = 1,
    atlas = 'j_luck_and_probability_bingo',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Straight" then
            ease_dollars(card.ability.extra)
            return { message = localize('$')..card.ability.extra, colour = G.C.MONEY }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 711. Jackpot
SMODS.Joker({
    key = 'j_luck_and_probability_jackpot',
    config = { extra = 20 },
    rarity = 1,
    atlas = 'j_luck_and_probability_jackpot',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local count_7 = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.base.value == '7' then count_7 = count_7 + 1 end
            end
            if count_7 >= 3 then
                ease_dollars(card.ability.extra)
                return { message = localize('$')..card.ability.extra, colour = G.C.MONEY }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 712. Slot Machine
SMODS.Joker({
    key = 'j_luck_and_probability_slot_machine',
    config = { extra = 15 },
    rarity = 1,
    atlas = 'j_luck_and_probability_slot_machine',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name == "Three of a Kind" then
            return {
                mult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 713. Sports Betting
SMODS.Joker({
    key = 'j_luck_and_probability_sports_betting',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_luck_and_probability_sports_betting',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.blueprint then
            if G.GAME.current_round.hands_played == 2 then
                ease_dollars(card.ability.extra)
                return { message = localize('$')..card.ability.extra, colour = G.C.MONEY, card = card }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 714. Scratch Card
SMODS.Joker({
    key = 'j_luck_and_probability_scratch_card',
    rarity = 1,
    atlas = 'j_luck_and_probability_scratch_card',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.selling_self then
            local amount = pseudorandom_element({0,5,10,15,20}, pseudoseed('scratch'))
            ease_dollars(amount)
        end
    end
})

-- 715. Fortune Cookie
SMODS.Joker({
    key = 'j_luck_and_probability_fortune_cookie',
    config = { extra = { mult = 5, odds = 4 } },
    rarity = 1,
    atlas = 'j_luck_and_probability_fortune_cookie',
    pos = { x = 0, y = 0 },
    cost = 4,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra.mult}}
            }
        end
        if context.using_consumeable and context.consumeable.ability.set == 'Tarot' and not context.blueprint then
            if pseudorandom('fortune_cookie') < G.GAME.probabilities.normal / card.ability.extra.odds then
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    func = function()
                        if #G.consumeables.cards < G.consumeables.config.card_limit then
                            local card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, nil, 'fort')
                            card:add_to_deck()
                            G.consumeables:emplace(card)
                        end
                        return true
                    end
                }))
                return { message = "Fortune!", colour = G.C.SECONDARY_SET.Spectral }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult, G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } } end
})

-- 716. Amulet
SMODS.Joker({
    key = 'j_luck_and_probability_amulet',
    rarity = 1,
    atlas = 'j_luck_and_probability_amulet',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_glass_protection = (G.GAME.odyssey_glass_protection or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_glass_protection = (G.GAME.odyssey_glass_protection or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 717. Talisman
SMODS.Joker({
    key = 'j_luck_and_probability_talisman',
    rarity = 1,
    atlas = 'j_luck_and_probability_talisman',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_lucky_double = (G.GAME.odyssey_lucky_double or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_lucky_double = (G.GAME.odyssey_lucky_double or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 718. Gargoyle
SMODS.Joker({
    key = 'j_luck_and_probability_gargoyle',
    config = { extra = 100 },
    rarity = 1,
    atlas = 'j_luck_and_probability_gargoyle',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_stone = false
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center == G.P_CENTERS.m_odyssey_emerald then has_stone = true break end
            end
            if has_stone then return { chips = card.ability.extra } end
        end
    end
})

-- 719. Evil Eye
SMODS.Joker({
    key = 'j_luck_and_probability_evil_eye',
    rarity = 1,
    atlas = 'j_luck_and_probability_evil_eye',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    -- Placeholder: Protege contra debuffs de Boss
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 720. Figa
SMODS.Joker({
    key = 'j_luck_and_probability_figa',
    config = { extra = 10 },
    rarity = 1,
    atlas = 'j_luck_and_probability_figa',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_left == 0 then
            return { mult = card.ability.extra }
        end
    end
})


-- ============================================
-- PROBABILITY AND LUCK - Uncommon (721-738)
-- ============================================

-- 721. Luck Manipulator
SMODS.Joker({
    key = 'j_luck_and_probability_luck_manipulator',
    rarity = 2,
    atlas = 'j_luck_and_probability_luck_manipulator',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    -- Simplified: same as Four Leaf Clover but stronger
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal + 1 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal - 1 end
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 722. Dice Master
SMODS.Joker({
    key = 'j_luck_and_probability_dice_master',
    rarity = 2,
    atlas = 'j_luck_and_probability_dice_master',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_dice_master = (G.GAME.odyssey_dice_master or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_dice_master = (G.GAME.odyssey_dice_master or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 723. Lady Luck
SMODS.Joker({
    key = 'j_luck_and_probability_lady_luck',
    rarity = 2,
    atlas = 'j_luck_and_probability_lady_luck',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.cardarea == G.play and context.repetition and not context.repetition_only then
            if context.other_card.config.center == G.P_CENTERS.m_lucky then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- 724. Underdog
SMODS.Joker({
    key = 'j_luck_and_probability_underdog',
    config = { extra = 3 },
    rarity = 2,
    atlas = 'j_luck_and_probability_underdog',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.chips < G.GAME.blind.chips * 0.1 then
                return {
                    Xmult_mod = card.ability.extra,
                    message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 725. Black Cat
SMODS.Joker({
    key = 'j_luck_and_probability_black_cat',
    config = { extra = 2 },
    rarity = 2,
    atlas = 'j_luck_and_probability_black_cat',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 726. Broken Mirror
SMODS.Joker({
    key = 'j_luck_and_probability_broken_mirror',
    config = { extra = 2 },
    rarity = 2,
    atlas = 'j_luck_and_probability_broken_mirror',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.playing_cards then
                for k, v in ipairs(G.playing_cards) do
                    if v.config.center == G.P_CENTERS.m_odyssey_ceramic then count = count + 1 end
                end
            end
            if count > 0 then
                local bonus = 1 + (count * card.ability.extra)
                return {
                    Xmult_mod = bonus,
                    message = localize{type = 'variable', key = 'a_xmult', vars = {bonus}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 727. Three Leaf Clover
SMODS.Joker({
    key = 'j_luck_and_probability_three_leaf_clover',
    config = { extra = 30 },
    rarity = 2,
    atlas = 'j_luck_and_probability_three_leaf_clover',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal - 0.5 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal + 0.5 end
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 728. Sorte de Principiante (Beginner's Luck)
SMODS.Joker({
    key = 'j_luck_and_probability_beginner_s_luck',
    config = { extra = 2 },
    rarity = 2,
    atlas = 'j_luck_and_probability_beginner_s_luck',
    pos = { x = 0, y = 0 },
    cost = 5,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.round_resets.ante <= 1 then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 729. Destino (Destiny)
SMODS.Joker({
    key = 'j_luck_and_probability_destiny',
    rarity = 2,
    atlas = 'j_luck_and_probability_destiny',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                func = function()
                    if #G.consumeables.cards < G.consumeables.config.card_limit then
                        local card = create_card('Consumeable', G.consumeables, nil, nil, nil, nil, nil, 'dest')
                        card:add_to_deck()
                        G.consumeables:emplace(card)
                    end
                    return true
                end
            }))
            return { message = "+Consumeable!", colour = G.C.PURPLE }
        end
    end
})

-- 730. Karma (Karma)
SMODS.Joker({
    key = 'j_luck_and_probability_karma',
    config = { extra = { mult = 0, gain = 5 } },
    rarity = 2,
    atlas = 'j_luck_and_probability_karma',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local lucky_count = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center == G.P_CENTERS.m_lucky then lucky_count = lucky_count + 1 end
            end
            if lucky_count > 0 then
                card.ability.extra.mult = card.ability.extra.mult + (lucky_count * card.ability.extra.gain)
                return { message = "Karma Up!", colour = G.C.MULT }
            end
            if card.ability.extra.mult > 0 then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra.mult}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).gain, (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end
})

-- 731. Roda do Destino (Wheel of Fate)
SMODS.Joker({
    key = 'j_luck_and_probability_wheel_of_fate',
    config = { extra = 4 },
    rarity = 2,
    atlas = 'j_luck_and_probability_wheel_of_fate',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.blueprint then
            if pseudorandom('wheel_fate') < G.GAME.probabilities.normal / card.ability.extra then
                local eligible_jokers = {}
                for k, v in ipairs(G.jokers.cards) do
                    if v ~= card and not v.edition then table.insert(eligible_jokers, v) end
                end
                if #eligible_jokers > 0 then
                    local target = pseudorandom_element(eligible_jokers, pseudoseed('wheel_fate_target'))
                    target:set_edition({polychrome = true})
                    return { message = "Polychrome!", colour = G.C.DARK_EDITION }
                end
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 732. Orculo (Oracle)
SMODS.Joker({
    key = 'j_luck_and_probability_oracle',
    rarity = 2,
    atlas = 'j_luck_and_probability_oracle',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    loc_vars = function(self, info_queue, card)
        local top_cards = {}
        if G.deck and G.deck.cards then
            -- Balatro draws from the end of the cards table
            for i = 0, 2 do
                local c = G.deck.cards[#G.deck.cards - i]
                if c then
                    -- Get the display name of the card
                    local rank = c.base.value
                    local suit = localize(c.base.suit, 'suits_singular')
                    table.insert(top_cards, rank .. " de " .. suit)
                else
                    table.insert(top_cards, "---")
                end
            end
        end
        return { vars = { top_cards[1] or "---", top_cards[2] or "---", top_cards[3] or "---" } }
    end,
    calculate = function(self, card, context)
        -- Purely informational joker
    end
})

-- 733. Profecia (Prophecy)
SMODS.Joker({
    key = 'j_luck_and_probability_prophecy',
    rarity = 2,
    atlas = 'j_luck_and_probability_prophecy',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
             if G.GAME.round_resets.ante >= 8 then
                 local card = create_card('Joker', G.jokers, nil, 0.99, nil, nil, nil, 'prop')
                 card:set_edition({negative = true})
                 card:add_to_deck()
                 G.jokers:emplace(card)
                 return { message = "Fulfillment!", colour = G.C.PURPLE }
             end
        end
    end
})

-- 734. Sorte Cega (Blind Luck)
SMODS.Joker({
    key = 'j_luck_and_probability_blind_luck',
    rarity = 2,
    atlas = 'j_luck_and_probability_blind_luck',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_blind_luck = (G.GAME.odyssey_blind_luck or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_blind_luck = (G.GAME.odyssey_blind_luck or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 735. Acaso (Chance)
SMODS.Joker({
    key = 'j_luck_and_probability_chance',
    config = { extra = { xmult = 2.5, odds = 10 } },
    rarity = 2,
    atlas = 'j_luck_and_probability_chance',
    pos = { x = 0, y = 0 },
    cost = 6,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('chance') < G.GAME.probabilities.normal / card.ability.extra.odds then
                if not card.ability.eternal then card:start_dissolve() end
                return { message = "Lost!", colour = G.C.GREY }
            end
            return {
                Xmult_mod = card.ability.extra.xmult,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra.xmult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult, G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } } end
})

-- 736. Serendipidade (Serendipity)
SMODS.Joker({
    key = 'j_luck_and_probability_serendipity',
    rarity = 2,
    atlas = 'j_luck_and_probability_serendipity',
    pos = { x = 0, y = 0 },
    cost = 8,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_serendipity = (G.GAME.odyssey_serendipity or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_serendipity = (G.GAME.odyssey_serendipity or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 737. Milagre (Miracle)
SMODS.Joker({
    key = 'j_luck_and_probability_miracle',
    config = { extra = 1000 },
    rarity = 2,
    atlas = 'j_luck_and_probability_miracle',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('miracle') < G.GAME.probabilities.normal / card.ability.extra then
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    func = function()
                        G.GAME.chips = G.GAME.blind.chips + 1
                        return true
                    end
                }))
                return { message = "MIRACLE!", colour = G.C.GOLD }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 738. Divindade (Divinity)
SMODS.Joker({
    key = 'j_luck_and_probability_divinity',
    config = { extra = 20 },
    rarity = 2,
    atlas = 'j_luck_and_probability_divinity',
    pos = { x = 0, y = 0 },
    cost = 7,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card.config.center == G.P_CENTERS.m_lucky then
                -- Lucky card trigger check is internal to Card:calculate_joker
                -- We'll just give a flat bonus if it's a lucky card scoring
                return {
                    mult = card.ability.extra,
                    card = card
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})


-- ============================================
-- PROBABILITY AND LUCK - Rare & Legendary (739-750)
-- ============================================

-- 739. Goddess of Fortune
SMODS.Joker({
    key = 'j_luck_and_probability_goddess_of_fortune',
    rarity = 3,
    atlas = 'j_luck_and_probability_goddess_of_fortune',
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal + 10 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal - 10 end
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 740. Controlled Chaos
SMODS.Joker({
    key = 'j_luck_and_probability_controlled_chaos',
    rarity = 3,
    atlas = 'j_luck_and_probability_controlled_chaos',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal + 2 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.probabilities.normal = G.GAME.probabilities.normal - 2 end
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 741. Infinite Luck
SMODS.Joker({
    key = 'j_luck_and_probability_infinite_luck',
    config = { extra = { money = 20, mult = 20 } },
    rarity = 3,
    atlas = 'j_luck_and_probability_infinite_luck',
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_force_success = (G.GAME.odyssey_force_success or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_force_success = (G.GAME.odyssey_force_success or 0) - 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- 742. Improbability
SMODS.Joker({
    key = 'j_luck_and_probability_improbability',
    config = { extra = { xmult = 3, odds = 100 } },
    rarity = 3,
    atlas = 'j_luck_and_probability_improbability',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('improb') < G.GAME.probabilities.normal / card.ability.extra.odds then
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    func = function()
                        for k, v in ipairs(G.jokers.cards) do v:start_dissolve() end
                        return true
                    end
                }))
                return { message = "IMPROBABLE!", colour = G.C.BLACK }
            end
            return {
                Xmult_mod = card.ability.extra.xmult,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra.xmult}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).xmult, G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds } } end
})

-- 743. Zero Entropy
SMODS.Joker({
    key = 'j_luck_and_probability_zero_entropy',
    config = { extra = { money = 1000, odds = 1000 } },
    rarity = 3,
    atlas = 'j_luck_and_probability_zero_entropy',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.blueprint then
            if pseudorandom('entropy') < G.GAME.probabilities.normal / card.ability.extra.odds then
                ease_dollars(card.ability.extra.money)
                return { message = "JACKPOT!", colour = G.C.GOLD }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { G.GAME.probabilities.normal, ( (card and card.ability and card.ability.extra) or self.config.extra ).odds, ( (card and card.ability and card.ability.extra) or self.config.extra ).money } } end
})

-- 744. The Chosen One
SMODS.Joker({
    key = 'j_luck_and_probability_the_chosen_one',
    config = { extra = 5 },
    rarity = 3,
    atlas = 'j_luck_and_probability_the_chosen_one',
    pos = { x = 0, y = 0 },
    cost = 15,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_glass_protection = (G.GAME.odyssey_glass_protection or 0) + 1
        G.GAME.odyssey_force_success = (G.GAME.odyssey_force_success or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_glass_protection = (G.GAME.odyssey_glass_protection or 0) - 1
        G.GAME.odyssey_force_success = (G.GAME.odyssey_force_success or 0) - 1
    end,
    calculate = function(self, card, context)
        if context.joker_main then return { Xmult = card.ability.extra } end
    end
})

-- 745. Holy Grail
SMODS.Joker({
    key = 'j_luck_and_probability_holy_grail',
    config = { extra = { xmult = 3, money = 10 } },
    rarity = 3,
    atlas = 'j_luck_and_probability_holy_grail',
    pos = { x = 0, y = 0 },
    cost = 12,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra.xmult,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra.xmult}}
            }
        end
        if context.end_of_round and not context.other_card and not context.blueprint then
            ease_dollars(card.ability.extra.money)
            return { message = localize('$')..card.ability.extra.money, colour = G.C.MONEY }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).xmult, (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end
})

-- 746. Golden Midas Hand
SMODS.Joker({
    key = 'j_luck_and_probability_golden_midas_hand',
    rarity = 3,
    atlas = 'j_luck_and_probability_golden_midas_hand',
    pos = { x = 0, y = 0 },
    cost = 10,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                v:set_ability(G.P_CENTERS.m_odyssey_plastic, nil, true)
                v:juice_up()
            end
            return { message = "Gold!", colour = G.C.GOLD }
        end
    end
})

-- 747. Cosmic Clover
SMODS.Joker({
    key = 'j_luck_and_probability_cosmic_clover',
    config = { extra = 100 },
    rarity = 3,
    atlas = 'j_luck_and_probability_cosmic_clover',
    pos = { x = 0, y = 0 },
    cost = 9,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.playing_cards then
                for k, v in ipairs(G.playing_cards) do
                    if v.base.value == '7' then count = count + 1 end
                end
            end
            if count > 0 then
                local bonus = count * card.ability.extra
                return {
                    chip_mod = bonus,
                    message = localize{type = 'variable', key = 'a_chips', vars = {bonus}}
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 748. 777
SMODS.Joker({
    key = 'j_luck_and_probability_777',
    config = { extra = { money = 77, xmult = 7 } },
    rarity = 3,
    atlas = 'j_luck_and_probability_777',
    pos = { x = 0, y = 0 },
    cost = 21,
    unlocked = true,
    discovered = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local sevens = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.base.value == '7' then sevens = sevens + 1 end
            end
            if sevens >= 3 then
                ease_dollars(card.ability.extra.money)
                return {
                    Xmult_mod = card.ability.extra.xmult,
                    message = "777!",
                    colour = G.C.GOLD
                }
            end
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).xmult, (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end
})

-- 749. Fortuna
SMODS.Joker({
    key = 'j_luck_and_probability_fortuna',
    config = { extra = 5 },
    rarity = 4,
    atlas = 'j_luck_and_probability_fortuna',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.round_resets.reroll_cost = 0 end
    end,
    remove_from_deck = function(self, card, from_debuff)
        if G.GAME then G.GAME.round_resets.reroll_cost = 2 end
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})

-- 750. Manifest Destiny
SMODS.Joker({
    key = 'j_luck_and_probability_manifest_destiny',
    config = { extra = 10 },
    rarity = 4,
    atlas = 'j_luck_and_probability_manifest_destiny',
    pos = { x = 0, y = 0 },
    cost = 20,
    unlocked = true,
    discovered = true,
    add_to_deck = function(self, card, from_debuff)
        G.GAME.odyssey_force_success = (G.GAME.odyssey_force_success or 0) + 1
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.GAME.odyssey_force_success = (G.GAME.odyssey_force_success or 0) - 1
    end,
    calculate = function(self, card, context)
        if context.joker_main then
             return {
                Xmult_mod = card.ability.extra,
                message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra}}
            }
        end
    end,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ) } } end
})


----------------------------------------------
-- TRANSFORMATIONS (COMMON) J751-J770
----------------------------------------------

-- J751 Chameleon
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_chameleon',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_chameleon',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = false,
    calculate = function(self, card, context)
        -- Hand suit copying logic usually implemented in Card:is_suit or similar
    end
})

-- J752 Mimic
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_mimic',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_mimic',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = false,
    calculate = function(self, card, context)
        -- Hand rank copying logic usually implemented in Card:get_id or similar
    end
})

-- J753 Shapeshifter
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_shapeshifter',
    config = { extra = { mult = 10, suit = 'Hearts' } },
    rarity = 1,
    atlas = 'j_transformations_shapeshifter',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.suit } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.before and not context.blueprint then
            local suits = {'Hearts', 'Diamonds', 'Spades', 'Clubs'}
            card.ability.extra.suit = suits[math.random(#suits)]
        end
    end
})

-- J754 Doppelganger
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_doppelganger',
    config = { extra = { chips = 20 } },
    rarity = 1,
    atlas = 'j_transformations_doppelganger',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            local prev_card = nil
            for i=1, #context.scoring_hand do
                if context.scoring_hand[i] == context.other_card then
                    if i > 1 then prev_card = context.scoring_hand[i-1] end
                    break
                end
            end
            if prev_card and prev_card.base.value == context.other_card.base.value then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
    end
})

-- J755 Magic Mirror
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_magic_mirror',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_magic_mirror',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J756 Prism
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_prism',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_prism',
    pos = { x = 0, y = 0 },
    cost = 4,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                v:set_edition({polychrome = true}, true, true)
            end
        end
    end
})

-- J757 Catalyst
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_catalyst',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_catalyst',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.joker_main then
            -- This is usually implemented as a global hook in vanilla_override
            -- but we can try to find scaling jokers and double their gain here
        end
    end
})

-- J758 Evolution
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_evolution',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_evolution',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local is_seq = true
            if #context.scoring_hand < 3 then is_seq = false end
            if is_seq then
                table.sort(context.scoring_hand, function(a, b) return a:get_id() < b:get_id() end)
                for i = 1, #context.scoring_hand - 1 do
                    if context.scoring_hand[i+1]:get_id() ~= context.scoring_hand[i]:get_id() + 1 then
                        is_seq = false
                        break
                    end
                end
            end
            if is_seq then
                for _, v in ipairs(context.scoring_hand) do
                    if v:get_id() < 14 then -- Not Ace (can't go higher than Ace easily)
                        v:set_base(G.P_CARDS[v.config.card_key:sub(1,1)..(string.format("%X", v:get_id()+1))])
                    end
                end
                return {
                    message = "Evolve!",
                    colour = G.C.RED
                }
            end
        end
    end
})

-- J759 Devolution
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_devolution',
    config = { extra = { mult = 20 } },
    rarity = 1,
    atlas = 'j_transformations_devolution',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local is_seq = true
            if #context.scoring_hand < 3 then is_seq = false end
            if is_seq then
                table.sort(context.scoring_hand, function(a, b) return a:get_id() < b:get_id() end)
                for i = 1, #context.scoring_hand - 1 do
                    if context.scoring_hand[i+1]:get_id() ~= context.scoring_hand[i]:get_id() + 1 then
                        is_seq = false
                        break
                    end
                end
            end
            if is_seq then
                for _, v in ipairs(context.scoring_hand) do
                    if v:get_id() > 2 then
                        v:set_base(G.P_CARDS[v.config.card_key:sub(1,1)..(string.format("%X", v:get_id()-1))])
                    end
                end
                card.ability.extra.triggered = true
            end
        end
        if context.joker_main and card.ability.extra.triggered then
            card.ability.extra.triggered = false
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J760 Transmuter
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_transmuter',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_transmuter',
    pos = { x = 0, y = 0 },
    cost = 4,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                if v:is_suit('Diamonds') then
                    v:change_suit('Hearts')
                end
            end
        end
    end
})

-- J761 Converter
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_converter',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_converter',
    pos = { x = 0, y = 0 },
    cost = 4,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                if v:is_suit('Spades') then
                    v:change_suit('Clubs')
                end
            end
        end
    end
})

-- J762 Basic Alchemy
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_basic_alchemy',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_basic_alchemy',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            for k, v in ipairs(context.full_hand) do
                if v:get_id() >= 2 and v:get_id() <= 4 then
                    v:set_ability(G.P_CENTERS.m_odyssey_plastic)
                end
            end
        end
    end
})

-- J763 Polymorph
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_polymorph',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_polymorph',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                if v:is_face() then
                    local rank = math.random(2, 10)
                    -- SMODS rank change logic
                end
            end
        end
    end
})

-- J764 Mask
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_mask',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_mask',
    pos = { x = 0, y = 0 },
    cost = 5,
    -- Implementation usually handled in vanilla_override via is_suit
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J765 Disguise
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_disguise',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_disguise',
    pos = { x = 0, y = 0 },
    cost = 5,
    -- Implementation in vanilla_override via is_face
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J766 Costume
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_costume',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_transformations_costume',
    pos = { x = 0, y = 0 },
    cost = 4,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J767 Makeup
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_makeup',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_makeup',
    pos = { x = 0, y = 0 },
    cost = 5,
    -- Implementation in vanilla_override via is_suit (color swap)
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J768 Wig
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_wig',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_wig',
    pos = { x = 0, y = 0 },
    cost = 4,
    -- Implementation: Kings count as Queens (vanilla_override)
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J769 Fake Beard
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_fake_beard',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_fake_beard',
    pos = { x = 0, y = 0 },
    cost = 4,
    -- Implementation: Queens count as Kings (vanilla_override)
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J770 Shadow
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_shadow',
    config = {},
    rarity = 1,
    atlas = 'j_transformations_shadow',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            if G.GAME.last_played_cards and #G.GAME.last_played_cards > 0 then
                local last_card = G.GAME.last_played_cards[1]
                local phantom = copy_card(last_card)
                phantom:set_edition({negative = true})
                phantom.ability.perishable = true
                phantom.ability.perish_tally = 1
                phantom:add_to_deck()
                G.hand:emplace(phantom)
                return {
                    message = "Shadow!",
                    colour = G.C.PURPLE
                }
            end
        end
    end
})


----------------------------------------------
-- TRANSFORMATIONS (UNCOMMON) J771-J788
----------------------------------------------

-- J771 Vampire (Steamodded already has a Vampire, but we add our own or override)
-- We use a prefix to avoid conflict
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_vampire',
    config = { extra = { x_mult = 1, x_mult_mod = 0.2 } },
    rarity = 2,
    atlas = 'j_transformations_vampire',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.x_mult_mod } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and card.ability.extra.x_mult > 1 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
        if context.before and not context.blueprint then
            local enhanced_found = 0
            for k, v in ipairs(context.scoring_hand) do
                if v.config.center ~= G.P_CENTERS.c_base then
                    v:set_ability(G.P_CENTERS.c_base)
                    enhanced_found = enhanced_found + 1
                end
            end
            if enhanced_found > 0 then
                card.ability.extra.x_mult = card.ability.extra.x_mult + (enhanced_found * card.ability.extra.x_mult_mod)
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.MULT
                }
            end
        end
    end
})

-- J772 Werewolf
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_werewolf',
    config = { extra = { chips = 50 } },
    rarity = 2,
    atlas = 'j_transformations_werewolf',
    pos = { x = 0, y = 0 },
    cost = 6,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_face() then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            end
        end
    end
})

-- J773 Frankenstein
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_frankenstein',
    config = {},
    rarity = 2,
    atlas = 'j_transformations_frankenstein',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.discard and not context.other_card and not context.blueprint then
            -- We wait for the discard to finish
            if #context.full_hand >= 2 then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Suit', G.hand, nil, nil, nil, nil, nil, 'frank')
                        new_card:add_to_deck()
                        G.hand:emplace(new_card)
                        return true
                    end
                }))
                return {
                    message = "It's Alive!",
                    colour = G.C.GREEN
                }
            end
        end
    end
})

-- J774 Zombie
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_zombie',
    config = { extra = { odds = 4 } },
    rarity = 2,
    atlas = 'j_transformations_zombie',
    pos = { x = 0, y = 0 },
    cost = 6,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { G.GAME.probabilities.normal or 1, extra.odds } }

    end,
    calculate = function(self, card, context)
        if context.discard and not context.other_card and not context.blueprint then
            if pseudorandom('zombie') < G.GAME.probabilities.normal / card.ability.extra.odds then
                local discarded_card = context.other_card
                -- This is tricky because we are in the middle of a discard
                -- Let's just create a random card in hand as a "returned" one
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local new_card = create_card('Suit', G.hand, nil, nil, nil, nil, nil, 'zombie')
                        new_card:add_to_deck()
                        G.hand:emplace(new_card)
                        return true
                    end
                }))
                return {
                    message = "Undead!",
                    colour = G.C.RED
                }
            end
        end
    end
})

-- J775 Phantom of the Opera
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_phantom_of_the_opera',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_transformations_phantom_of_the_opera',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.joker_main then
            local faces = 0
            for k, v in ipairs(context.scoring_hand) do
                if v:is_face() then faces = faces + 1 end
            end
            if faces == 1 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J776 Jekyll & Hyde
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_jekyll_hyde',
    config = { extra = { active = false, x_mult_a = 0.5, x_mult_b = 4 } },
    rarity = 2,
    atlas = 'j_transformations_jekyll_hyde',
    pos = { x = 0, y = 0 },
    cost = 6,
    loc_vars = function(self, info_queue, card)
        local current_x = ( (card and card.ability and card.ability.extra) or self.config.extra ).active and ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_b or ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_a
        return { vars = { current_x } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local val = card.ability.extra.active and card.ability.extra.x_mult_b or card.ability.extra.x_mult_a
            return {
                x_mult = val,
                message = localize { type = 'variable', key = 'a_xmult', vars = { val } }
            }
        end
        if context.after and not context.blueprint then
            card.ability.extra.active = not card.ability.extra.active
        end
    end
})

-- J777 Mutant
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_mutant',
    config = { extra = { mult = 10 } },
    rarity = 2,
    atlas = 'j_transformations_mutant',
    pos = { x = 0, y = 0 },
    cost = 6,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J778 Hybrid
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_hybrid',
    config = {},
    rarity = 2,
    atlas = 'j_transformations_hybrid',
    pos = { x = 0, y = 0 },
    cost = 7,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J779 Chimera
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_chimera',
    config = { extra = { mult = 10, chips = 50, money = 1, x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_transformations_chimera',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_face() then
                if context.other_card:is_suit('Hearts') then
                    return { mult = card.ability.extra.mult, card = card }
                elseif context.other_card:is_suit('Spades') then
                    return { chips = card.ability.extra.chips, card = card }
                elseif context.other_card:is_suit('Diamonds') then
                    return { dollars = card.ability.extra.money, card = card }
                elseif context.other_card:is_suit('Clubs') then
                    return { x_mult = card.ability.extra.x_mult, card = card }
                end
            end
        end
    end
})

-- J780 Hydra
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_hydra',
    config = {},
    rarity = 2,
    atlas = 'j_transformations_hydra',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.discard and not context.blueprint then
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.1,
                func = function()
                    G.FUNCS.draw_from_deck_to_hand(2)
                    return true
                end
            }))
        end
    end
})

-- J781 Dark Phoenix
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_dark_phoenix',
    config = {},
    rarity = 2,
    atlas = 'j_transformations_dark_phoenix',
    pos = { x = 0, y = 0 },
    cost = 7,
    loc_vars = function(self, info_queue, card)
        info_queue[#info_queue+1] = G.P_CENTERS.m_odyssey_platinum
        return { vars = {} }
    end,
    calculate = function(self, card, context)
        if context.after and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        v:start_dissolve()
                        local new_card = create_card('Suit', G.deck, nil, nil, nil, nil, nil, 'dark_phoenix')
                        new_card:set_ability(G.P_CENTERS.m_odyssey_platinum)
                        new_card:add_to_deck()
                        G.deck:emplace(new_card)
                        return true
                    end
                }))
            end
            return {
                message = "Reborn!",
                colour = G.C.RED
            }
        end
    end
})

-- J782 Basilisk
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_basilisk',
    config = {},
    rarity = 2,
    atlas = 'j_transformations_basilisk',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.after and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                v:set_ability(G.P_CENTERS.m_odyssey_emerald)
            end
        end
    end
})

-- J783 Medusa
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_medusa',
    config = { extra = { mult = 50 } },
    rarity = 2,
    atlas = 'j_transformations_medusa',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.before and not context.blueprint then
            for k, v in ipairs(context.scoring_hand) do
                if v:is_face() and not (v.config.center == G.P_CENTERS.m_odyssey_emerald) then
                    v:set_ability(G.P_CENTERS.m_odyssey_emerald)
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            v:juice_up()
                            return true
                        end
                    }))
                end
            end
        end
    end
})

-- J784 Siren
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_siren',
    config = {},
    rarity = 2,
    atlas = 'j_transformations_siren',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.first_hand_drawn then
            -- This is hard to implement with just calculate hooks without more complex logic
            -- Better to make it give a bonus to a specific suit that changes?
            -- Let's stick to a simpler interpretation for now:
            -- Better draw power?
        end
        if context.joker_main then
            -- Let's give it +10 chips for every card of the same suit as the first card in hand
            local first_card = G.hand.cards[1]
            if first_card then
                local first_suit = first_card.base.suit
                local count = 0
                for k, v in ipairs(context.scoring_hand) do
                    if v.base.suit == first_suit then
                        count = count + 1
                    end
                end
                if count > 0 then
                    return {
                        chips = count * 20,
                        message = localize { type = 'variable', key = 'a_chips', vars = { count * 20 } }
                    }
                end
            end
        end
    end
})

-- J785 Griffin
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_griffin',
    config = { extra = { chips = 0, chip_gain = 10 } },
    rarity = 2,
    atlas = 'j_transformations_griffin',
    pos = { x = 0, y = 0 },
    cost = 7,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.chip_gain } }

    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            if context.scoring_name == 'Pair' or context.scoring_name == 'Two Pair' or context.scoring_name == 'Three of a Kind' or context.scoring_name == 'Full House' or context.scoring_name == 'Four of a Kind' or context.scoring_name == 'Five of a Kind' then
                card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chip_gain
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.CHIPS
                }
            end
        end
        if context.joker_main then
            return {
                chips = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- J786 Dragon
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_dragon',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_transformations_dragon',
    pos = { x = 0, y = 0 },
    cost = 8,
    calculate = function(self, card, context)
        if context.joker_main then
            local flush = true
            local gold = false
            local first_suit = context.scoring_hand[1].base.suit
            for k, v in ipairs(context.scoring_hand) do
                if v.base.suit ~= first_suit then flush = false end
                if v.ability.name == 'Gold Card' then gold = true end
            end
            if flush and gold then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J787 Unicorn
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_unicorn',
    config = { extra = { x_mult = 2.5 } },
    rarity = 2,
    atlas = 'j_transformations_unicorn',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            for k, v in ipairs(context.scoring_hand) do
                suits[v.base.suit] = true
            end
            local count = 0
            for _ in pairs(suits) do count = count + 1 end
            if count >= 4 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J788 Centaur
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_centaur',
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_transformations_centaur',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.joker_main then
            local face = false
            local common = false
            for k, v in ipairs(context.scoring_hand) do
                if v:is_face() then face = true end
                if not v:is_face() and v.base.value ~= 'Ace' then common = true end
            end
            if face and common then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})


----------------------------------------------
-- TRANSFORMATIONS (RARE) J789-J798
----------------------------------------------

-- J789 Metamorphosis
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_metamorphosis',
    config = {},
    rarity = 3,
    atlas = 'j_transformations_metamorphosis',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.blueprint and not context.other_card then
            local area = card.area
            local rarity = card.config.center.rarity
            local key = nil
            while not key or key == 'j_transformations_metamorphosis' do
                key = SMODS.poll_joker({rarity = rarity}).key
            end
            G.E_MANAGER:add_event(Event({
                func = function()
                    card:remove()
                    local new_card = create_card('Joker', area, nil, nil, nil, nil, key)
                    new_card:add_to_deck()
                    area:emplace(new_card)
                    return true
                end
            }))
            return {
                message = "Metamorphosis!",
                colour = G.C.BLUE
            }
        end
    end
})

-- J790 Transcendence
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_transcendence',
    config = {},
    rarity = 3,
    atlas = 'j_transformations_transcendence',
    pos = { x = 0, y = 0 },
    cost = 8,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J791 Ascension
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_ascension',
    config = {},
    rarity = 3,
    atlas = 'j_transformations_ascension',
    pos = { x = 0, y = 0 },
    cost = 8,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J792 Apotheosis
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_apotheosis',
    config = {},
    rarity = 3,
    atlas = 'j_transformations_apotheosis',
    pos = { x = 0, y = 0 },
    cost = 10,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J793 Singularity
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_singularity',
    config = {},
    rarity = 3,
    atlas = 'j_transformations_singularity',
    pos = { x = 0, y = 0 },
    cost = 10,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J794 Big Bang
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_big_bang',
    config = {},
    rarity = 3,
    atlas = 'j_transformations_big_bang',
    pos = { x = 0, y = 0 },
    cost = 10,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J795 Reincarnation
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_reincarnation',
    config = { extra = { x_mult = 1.2 } },
    rarity = 3,
    atlas = 'j_transformations_reincarnation',
    pos = { x = 0, y = 0 },
    cost = 8,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J796 Evolution Final
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_final_evolution',
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    atlas = 'j_transformations_final_evolution',
    pos = { x = 0, y = 0 },
    cost = 9,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J797 Perfect Form
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_perfect_form',
    config = { extra = { x_mult = 4, odyssey_immune = true } },
    rarity = 3,
    atlas = 'j_transformations_perfect_form',
    pos = { x = 0, y = 0 },
    cost = 10,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- J798 Primal Chaos
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_primal_chaos',
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    atlas = 'j_transformations_primal_chaos',
    pos = { x = 0, y = 0 },
    cost = 10,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})


----------------------------------------------
-- TRANSFORMATIONS (LEGENDARY) J799-J800
----------------------------------------------

-- J799 The Changeling
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_the_changeling',
    config = { extra = { copied_key = nil } },
    rarity = 4,
    atlas = 'j_transformations_the_changeling',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.copied_key or 'None' } }

    end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            local legendary_keys = {}
            for k, v in pairs(G.P_CENTERS) do
                if v.set == 'Joker' and v.rarity == 4 and k ~= 'j_transformations_the_changeling' then
                    table.insert(legendary_keys, k)
                end
            end
            card.ability.extra.copied_key = legendary_keys[math.random(#legendary_keys)]
            return {
                message = "Copied " .. card.ability.extra.copied_key,
                colour = G.C.PURPLE
            }
        end

        if card.ability.extra.copied_key then
            local other_joker = G.P_CENTERS[card.ability.extra.copied_key]
            if other_joker and other_joker.calculate then
                return other_joker:calculate(card, context)
            end
        end
    end
})

-- J800 Proteus
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_transformations_proteus',
    config = { extra = { x_mult = 1, hand_types = {} } },
    rarity = 4,
    atlas = 'j_transformations_proteus',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, #extra.hand_types } }

    end,
    calculate = function(self, card, context)
        if context.before and not context.blueprint then
            local hand_type = context.scoring_name
            if hand_type and not card.ability.extra.hand_types[hand_type] then
                card.ability.extra.hand_types[hand_type] = true
                card.ability.extra.x_mult = card.ability.extra.x_mult + 0.5
                return {
                    message = localize('k_upgrade_ex'),
                    colour = G.C.RED
                }
            end
        end
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})


----------------------------------------------
-- SOCIAL & META (COMMON) J801-J820
----------------------------------------------

-- J801 Audience
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_audience',
    config = { extra = { mult_per = 4 } },
    rarity = 1,
    atlas = 'j_social_audience',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult_per, (G.GAME and G.GAME.current_round.hands_played or 0) * extra.mult_per } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local mult = (G.GAME.current_round.hands_played or 0) * card.ability.extra.mult_per
            if mult > 0 then
                return {
                    mult_mod = mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { mult } }
                }
            end
        end
    end
})

-- J802 Critic
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_critic',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_social_critic',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.chips < G.GAME.blind.chips * 0.2 then
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "Lixo!", colour = G.C.RED})
            end
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J803 Fan
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_fan',
    config = { extra = { mult = 5 } },
    rarity = 1,
    atlas = 'j_social_fan',
    pos = { x = 0, y = 0 },
    cost = 3,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.end_of_round and G.GAME.chips >= G.GAME.blind.chips and not context.repetition and not context.other_card then
            card_eval_status_text(card, 'extra', nil, nil, nil, {message = "Bom trabalho!", colour = G.C.GREEN})
        end
    end
})

-- J804 Hater
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_hater',
    config = { extra = { mult = 20 } },
    rarity = 1,
    atlas = 'j_social_hater',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('hater') < 0.2 then
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "Vai perder!", colour = G.C.RED})
            end
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J805 Streamer (Simulated. $1 per blind entered)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_streamer',
    config = { extra = { dollars = 2 } },
    rarity = 1,
    atlas = 'j_social_streamer',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            ease_dollars(card.ability.extra.dollars)
            return {
                message = localize('$')..card.ability.extra.dollars,
                colour = G.C.MONEY,
                card = card
            }
        end
    end
})

-- J806 Chat
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_chat',
    config = { extra = { chips = 10 } },
    rarity = 1,
    atlas = 'j_social_chat',
    pos = { x = 0, y = 0 },
    cost = 2,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local messages = {"KAPPA", "LUL", "POG", "RIGGED", "777"}
            if pseudorandom('chat') < 0.3 then
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = messages[math.floor(pseudorandom('chat_msg')*#messages)+1], colour = G.C.BLUE})
            end
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- J807 Moderator (Prevents playing if < 2 discards left? No, "prevents bad hands")
-- Let's say: High Card is disabled.
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_moderator',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_social_moderator',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J808 Troll
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_troll',
    config = { extra = { mult = 30, chance = 10 } },
    rarity = 1,
    atlas = 'j_social_troll',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, G.GAME.probabilities.normal, extra.chance } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('troll') < G.GAME.probabilities.normal / card.ability.extra.chance then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        for i = 1, #G.hand.cards do
                            G.hand.cards[i]:start_dissolve()
                        end
                        return true
                    end
                }))
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "Problem?!", colour = G.C.FILTER})
            end
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J809 Lurker
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_lurker',
    config = { extra = { rounds = 0, req = 10, x_mult = 3 } },
    rarity = 1,
    atlas = 'j_social_lurker',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.rounds, extra.req, extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
            card.ability.extra.rounds = card.ability.extra.rounds + 1
            if card.ability.extra.rounds == card.ability.extra.req then
                card_eval_status_text(card, 'extra', nil, nil, nil, {message = "Ativado!", colour = G.C.PURPLE})
            end
        end
        if context.joker_main and card.ability.extra.rounds >= card.ability.extra.req then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- J810 Subscriber
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_subscriber',
    config = { extra = { rounds = 0, dollars = 5, every = 4 } },
    rarity = 1,
    atlas = 'j_social_subscriber',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.rounds, extra.every, extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
            card.ability.extra.rounds = card.ability.extra.rounds + 1
            if card.ability.extra.rounds % card.ability.extra.every == 0 then
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- J811 Sponsor
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_sponsor',
    config = { extra = { dollars = 10 } },
    rarity = 1,
    atlas = 'j_social_sponsor',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            if G.GAME.round_resets.ante > (card.ability.extra.last_ante or 0) then
                card.ability.extra.last_ante = G.GAME.round_resets.ante
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- J812 Ad (Simpler: $5 end of round, blocks view of played hand score)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_ad',
    config = { extra = { dollars = 5 } },
    rarity = 1,
    atlas = 'j_social_ad',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars } }

    end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.repetition and not context.other_card then
             ease_dollars(card.ability.extra.dollars)
             return {
                message = localize('$')..card.ability.extra.dollars,
                colour = G.C.MONEY
            }
        end
        if context.joker_main then
            card_eval_status_text(card, 'extra', nil, nil, nil, {message = "PROPAGANDA", colour = G.C.RED})
        end
    end
})

-- J813 Clickbait
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_clickbait',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_social_clickbait',
    pos = { x = 0, y = 0 },
    cost = 2,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J814 Viral
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_viral',
    config = { extra = { dollars = 10, threshold = 10000 } },
    rarity = 1,
    atlas = 'j_social_viral',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.dollars, extra.threshold } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and not context.blueprint then
             if G.GAME.chips > card.ability.extra.threshold then
                ease_dollars(card.ability.extra.dollars)
                return {
                    message = "VIRAL! "..localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
             end
        end
    end
})

-- J815 Meme
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_meme',
    config = { extra = { chips = 69 } },
    rarity = 1,
    atlas = 'j_social_meme',
    pos = { x = 0, y = 0 },
    cost = 3,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_6 = false
            local has_9 = false
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:get_id() == 6 then has_6 = true end
                if context.scoring_hand[i]:get_id() == 9 then has_9 = true end
            end
            if has_6 and has_9 then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = "Nice.",
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- J816 Emoji
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_emoji',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_social_emoji',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "",
                colour = G.C.MULT
            }
        end
    end
})

-- J817 Hashtag
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_hashtag',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_social_hashtag',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "#Balatro",
                colour = G.C.MULT
            }
        end
    end
})

-- J818 Trending
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_trending',
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    atlas = 'j_social_trending',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, G.GAME.odyssey_last_suit or 'N/A' } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local is_suit = false
            for i = 1, #context.scoring_hand do
                if context.scoring_hand[i]:is_suit(G.GAME.odyssey_last_suit or 'Spades') then
                    is_suit = true
                    break
                end
            end
            if is_suit then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            -- Logic to update odyssey_last_suit will be in vanilla_override
        end
    end
})

-- J819 Canceled
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_canceled',
    config = { extra = { face_card = 'King' } },
    rarity = 1,
    atlas = 'j_social_canceled',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.face_card } }

    end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            local faces = {'Jack', 'Queen', 'King'}
            card.ability.extra.face_card = faces[math.floor(pseudorandom('cancel')*#faces)+1]
        end
    end
})

-- J820 Influencer
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_influencer',
    config = { extra = { mult_per = 2 } },
    rarity = 1,
    atlas = 'j_social_influencer',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = (G.jokers and G.jokers.cards) and #G.jokers.cards or 1
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per, (count - 1) * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local mult = (#G.jokers.cards - 1) * card.ability.extra.mult_per
            if mult > 0 then
                return {
                    mult_mod = mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { mult } }
                }
            end
        end
    end
})


----------------------------------------------
-- SOCIAL & META (UNCOMMON) J821-J838
----------------------------------------------

-- J821 Fourth Wall
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_fourth_wall',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_social_fourth_wall',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.CONTROLLER.cursor_hovering == card then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- J822 Developer
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_developer',
    config = { extra = { chips = 50 } },
    rarity = 2,
    atlas = 'j_social_developer',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = "DEBUG: "..card.ability.extra.chips,
                colour = G.C.BLUE
            }
        end
    end
})

-- J823 Beta Tester
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_beta_tester',
    config = { extra = { chips = 40, mult = 10 } },
    rarity = 2,
    atlas = 'j_social_beta_tester',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('beta') < 0.5 then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = "BUG FOUND!",
                    colour = G.C.BLUE
                }
            else
                return {
                    mult_mod = card.ability.extra.mult,
                    message = "PATCHED!",
                    colour = G.C.RED
                }
            end
        end
    end
})

-- J824 Speedrunner
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_speedrunner',
    config = { extra = { mult = 30, limit = 120 } },
    rarity = 2,
    atlas = 'j_social_speedrunner',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.limit, G.GAME.round_resets.hands_played } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if (G.GAME.round_resets.hands_played or 0) < 3 then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = "FAST!",
                    colour = G.C.ORANGE
                }
            end
        end
    end
})

-- J825 Completionist
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_completionist',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_social_completionist',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.GAME and G.GAME.hands then
            for k, v in pairs(G.GAME.hands) do
                if v.played > 0 then count = count + 1 end
            end
        end
        return { vars = { card.ability.extra.x_mult, count } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local all_played = true
            for k, v in pairs(G.GAME.hands) do
                if v.played == 0 and v.visible then all_played = false break end
            end
            if all_played then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J826 Lore Master
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_lore_master',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_social_lore_master',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "LORE!",
                colour = G.C.MULT
            }
        end
    end
})

-- J827 Min-Maxer
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_min_maxer',
    config = { extra = { x_mult = 3, limit = 40 } },
    rarity = 2,
    atlas = 'j_social_min_maxer',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.limit } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and #G.deck.cards < card.ability.extra.limit then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- J828 Casual
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_casual',
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_social_casual',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if (G.GAME.round_resets.hands_played or 0) > 5 then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = "RELAX...",
                    colour = G.C.GREEN
                }
            end
        end
    end
})

-- J829 Tryhard
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_tryhard',
    config = { extra = { mult = 30 } },
    rarity = 2,
    atlas = 'j_social_tryhard',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            G.E_MANAGER:add_event(Event({
                func = function()
                    if G.ROOM and G.ROOM.jiggle then
                        G.ROOM.jiggle = G.ROOM.jiggle + 0.7
                    end
                    return true
                end
            }))
            return {
                mult_mod = card.ability.extra.mult,
                message = "TRYHARD!",
                colour = G.C.RED
            }
        end
    end
})

-- J830 Rage Quit
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_rage_quit',
    config = { extra = { active = true } },
    rarity = 2,
    atlas = 'j_social_rage_quit',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            G.GAME.odyssey_rage_quit_active = true
        end
    end
})

-- J831 Save Scummer
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_save_scummer',
    config = { extra = { uses = 1 } },
    rarity = 2,
    atlas = 'j_social_save_scummer',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.selling_self and not context.blueprint then
             G.GAME.chips = 0
             G.GAME.hands_played = 0
             G.GAME.discards_used = 0
             card_eval_status_text(card, 'extra', nil, nil, nil, {message = "SAVE LOADED", colour = G.C.BLUE})
        end
    end
})

-- J832 Modder
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_modder',
    config = { extra = { mult = 10 } },
    rarity = 2,
    atlas = 'j_social_modder',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J833 Pirate
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_pirate',
    config = { extra = { x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_social_pirate',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = "PIRACY!",
                colour = G.C.BLACK
            }
        end
    end
})

-- J834 DRM
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_drm',
    config = { extra = { mult = 40 } },
    rarity = 2,
    atlas = 'j_social_drm',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "DRM PROTECTED",
                colour = G.C.MULT
            }
        end
    end
})

-- J835 Microtransaction
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_microtransaction',
    config = { extra = { mult = 5, cost = 1 } },
    rarity = 2,
    atlas = 'j_social_microtransaction',
    pos = { x = 0, y = 0 },
    cost = 1,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult, extra.cost } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.dollars >= card.ability.extra.cost then
             ease_dollars(-card.ability.extra.cost)
             return {
                 mult_mod = card.ability.extra.mult,
                 message = "-$1 MULT!",
                 colour = G.C.MONEY
             }
        end
    end
})

-- J836 DLC
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_dlc',
    config = { extra = { chips = 20 } },
    rarity = 2,
    atlas = 'j_social_dlc',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = "DLC ACTIVE",
                colour = G.C.CHIPS
            }
        end
    end
})

-- J837 Patch Notes
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_patch_notes',
    config = { extra = { mult = 10 } },
    rarity = 2,
    atlas = 'j_social_patch_notes',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "v1.0."..G.GAME.round_resets.ante,
                colour = G.C.MULT
            }
        end
    end
})

-- J838 Easter Egg
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_easter_egg',
    config = { extra = { clicks = 0, req = 10, dollars = 10 } },
    rarity = 2,
    atlas = 'j_social_easter_egg',
    pos = { x = 0, y = 0 },
    cost = 1,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.joker_main then
             card.ability.extra.clicks = card.ability.extra.clicks + 1
             if card.ability.extra.clicks >= card.ability.extra.req then
                ease_dollars(card.ability.extra.dollars)
                card.ability.extra.clicks = 0
                return {
                    message = "EASTER EGG! "..localize('$')..card.ability.extra.dollars,
                    colour = G.C.MONEY
                }
             end
        end
    end
})


----------------------------------------------
-- SOCIAL & META (RARE) J839-J848
----------------------------------------------

-- J839 Game Master
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_game_master',
    config = { extra = { used = false } },
    rarity = 3,
    atlas = 'j_social_game_master',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint and G.GAME.blind.boss then
            G.GAME.blind:set_blind(nil, true, nil)
            card_eval_status_text(card, 'extra', nil, nil, nil, {message = "REGRAS ALTERADAS", colour = G.C.PURPLE})
        end
    end
})

-- J840 Admin
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_admin',
    config = {},
    rarity = 3,
    atlas = 'j_social_admin',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.selling_self and not context.blueprint then
            ease_dollars(20)
            local tag = Tag('tag_double')
            add_tag(tag)
            add_tag(Tag('tag_double'))
            -- Simplified: $20 and 2 Double Tags
        end
    end
})

-- J841 God Mode
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_god_mode',
    config = { extra = { rounds = 1 } },
    rarity = 3,
    atlas = 'j_social_god_mode',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            G.GAME.odyssey_god_mode = true
        end
        if context.end_of_round and not context.repetition and not context.other_card then
            G.GAME.odyssey_god_mode = false
        end
    end
})

-- J842 Noclip
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_noclip',
    config = { extra = { x_mult = 2 } },
    rarity = 3,
    atlas = 'j_social_noclip',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = "NOCLIP",
                colour = G.C.PURPLE
            }
        end
        if context.setting_blind then
            G.GAME.odyssey_noclip = true
        end
    end
})

-- J843 Infinite Ammo
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_infinite_ammo',
    config = { extra = { discards = 5 } },
    rarity = 3,
    atlas = 'j_social_infinite_ammo',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.discards } }

    end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            ease_discard(card.ability.extra.discards)
        end
    end
})

-- J844 Aimbot
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_aimbot',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_social_aimbot',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             local count = 0
             local suit = nil
             for i=1, #context.scoring_hand do
                if not suit then suit = context.scoring_hand[i].base.suit end
                if context.scoring_hand[i]:is_suit(suit) then count = count + 1 end
             end
             if count >= 4 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = "HEADSHOT!",
                    colour = G.C.RED
                }
             end
        end
    end
})

-- J845 Wallhack
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_wallhack',
    config = { extra = { chips = 150 } },
    rarity = 3,
    atlas = 'j_social_wallhack',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local next_cards = "???, ???, ???"
        if G.deck and G.deck.cards then
            next_cards = ""
            for i=1, 3 do
                local c = G.deck.cards[#G.deck.cards - i + 1]
                if c then
                    next_cards = next_cards .. (i > 1 and ", " or "") .. localize(c.base.value, 'ranks') .. " " .. localize(c.base.suit, 'suits_plural')
                end
            end
        end
        return { vars = { card.ability.extra.chips, next_cards } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- J846 Lag Switch
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_lag_switch',
    config = { extra = { chips = 100, x_mult = 1.5 } },
    rarity = 3,
    atlas = 'j_social_lag_switch',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips, extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                x_mult = card.ability.extra.x_mult,
                message = "LAGGING...",
                colour = G.C.CHIPS
            }
        end
    end
})

-- J847 Ban Hammer
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_ban_hammer',
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    atlas = 'j_social_ban_hammer',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local my_pos = nil
            for i=1, #G.jokers.cards do
                if G.jokers.cards[i] == card then my_pos = i break end
            end
            if my_pos and G.jokers.cards[my_pos + 1] then
                local target = G.jokers.cards[my_pos + 1]
                if not target.ability.eternal then
                    target:start_dissolve()
                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = "BANNED!", colour = G.C.RED})
                    return {
                        x_mult = card.ability.extra.x_mult,
                        message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                    }
                end
            end
        end
    end
})

-- J848 Credits
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_credits',
    config = { extra = { x_mult = 1 } },
    rarity = 3,
    atlas = 'j_social_credits',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult + (G.GAME.round_resets.ante or 0) } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local bonus = G.GAME.round_resets.ante or 0
            return {
                x_mult = card.ability.extra.x_mult + bonus,
                message = "THANKS FOR PLAYING!",
                colour = G.C.GOLD
            }
        end
        if context.selling_self and G.GAME.round_resets.ante >= 8 then
            -- Win game logic (hard to trigger directly, maybe just massive money)
            ease_dollars(100)
        end
    end
})


----------------------------------------------
-- SOCIAL & META (LEGENDARY) J849-J850
----------------------------------------------

-- J849 The Player
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_the_player',
    config = { extra = { x_mult = 5, mode = 1 } },
    rarity = 4,
    atlas = 'j_social_the_player',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local modes = {"X5 Mult", "+500 Chips", "+100 Mult", "$5 per hand"}
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult, modes[( (card and card.ability and card.ability.extra) or self.config.extra ).mode] } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if card.ability.extra.mode == 1 then
                return { x_mult = 5, message = "X5" }
            elseif card.ability.extra.mode == 2 then
                return { chip_mod = 500, message = "+500" }
            elseif card.ability.extra.mode == 3 then
                return { mult_mod = 100, message = "+100" }
            elseif card.ability.extra.mode == 4 then
                 ease_dollars(5)
                 return { message = "$$$", colour = G.C.MONEY }
            end
        end
        if context.end_of_round and not context.repetition and not context.other_card and not context.blueprint then
            card.ability.extra.mode = (card.ability.extra.mode % 4) + 1
            card_eval_status_text(card, 'extra', nil, nil, nil, {message = "SWITCH!", colour = G.C.PURPLE})
        end
    end
})

-- J850 LocalThunk
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_social_localthunk',
    config = { extra = { x_mult = 10 } },
    rarity = 4,
    atlas = 'j_social_localthunk',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if not context.blueprint then
                for k, v in ipairs(G.jokers.cards) do
                    if v ~= card and not v.edition then
                         v:set_edition({polychrome = true}, true)
                    end
                end
            end
            return {
                x_mult = card.ability.extra.x_mult,
                message = "THANKS!",
                colour = G.C.GOLD
            }
        end
    end
})


----------------------------------------------
-- POSITIONING & ADJACENCY (COMMON) J851-J870
----------------------------------------------

-- J851 Left Neighbor
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_left_neighbor',
    config = {},
    rarity = 1,
    atlas = 'j_pos_left_neighbor',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    calculate = function(self, card, context)
        local other_joker = get_joker_neighbor(card, 'left')
        if other_joker and other_joker ~= card and other_joker.config.center.blueprint_compat then
            context.blueprint = (context.blueprint and (context.blueprint + 1)) or 1
            context.blueprint_card = context.blueprint_card or card
            if context.blueprint > #G.jokers.cards + 1 then return end
            local other_joker_ret = other_joker:calculate_joker(context)
            if other_joker_ret then
                other_joker_ret.card = context.blueprint_card or card
                return other_joker_ret
            end
        end
    end
})

-- J852 Right Neighbor
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_right_neighbor',
    config = {},
    rarity = 1,
    atlas = 'j_pos_right_neighbor',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    calculate = function(self, card, context)
        local other_joker = get_joker_neighbor(card, 'right')
        if other_joker and other_joker ~= card and other_joker.config.center.blueprint_compat then
            context.blueprint = (context.blueprint and (context.blueprint + 1)) or 1
            context.blueprint_card = context.blueprint_card or card
            if context.blueprint > #G.jokers.cards + 1 then return end
            local other_joker_ret = other_joker:calculate_joker(context)
            if other_joker_ret then
                other_joker_ret.card = context.blueprint_card or card
                return other_joker_ret
            end
        end
    end
})

-- J853 Bodyguard
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_bodyguard',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_pos_bodyguard',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        -- Protection logic is in 03_vanilla_override
    end
})

-- J854 Leader
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_leader',
    config = { extra = { mult_per = 5 } },
    rarity = 1,
    atlas = 'j_pos_leader',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            local found = false
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then found = true
                elseif found then count = count + 1 end
            end
            return {
                mult_mod = count * card.ability.extra.mult_per,
                message = localize { type = 'variable', key = 'a_mult', vars = { count * card.ability.extra.mult_per } }
            }
        end
    end
})

-- J855 Follower
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_follower',
    config = { extra = { mult_per = 5 } },
    rarity = 1,
    atlas = 'j_pos_follower',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then break end
                count = count + 1
            end
            return {
                mult_mod = count * card.ability.extra.mult_per,
                message = localize { type = 'variable', key = 'a_mult', vars = { count * card.ability.extra.mult_per } }
            }
        end
    end
})

-- J856 Center Stage
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_center_stage',
    config = { extra = { mult = 20 } },
    rarity = 1,
    atlas = 'j_pos_center_stage',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            if idx == math.ceil(#G.jokers.cards / 2) then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- J857 Outsider
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_outsider',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_pos_outsider',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            if idx == 1 or idx == #G.jokers.cards then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- J858 Pair
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_pair',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_pos_pair',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            local is_pair = false
            if idx > 1 and G.jokers.cards[idx-1].config.center.key == card.config.center.key then is_pair = true end
            if idx < #G.jokers.cards and G.jokers.cards[idx+1].config.center.key == card.config.center.key then is_pair = true end
            if is_pair then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J859 Trio
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_trio',
    config = { extra = { x_mult = 3 } },
    rarity = 1,
    atlas = 'j_pos_trio',
    pos = { x = 0, y = 0 },
    cost = 8,
    calculate = function(self, card, context)
        if context.joker_main then
             local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            local count = 1
            -- Check left
            local l = idx - 1
            while l >= 1 and G.jokers.cards[l].config.center.key == card.config.center.key do
                count = count + 1
                l = l - 1
            end
            -- Check right
            local r = idx + 1
            while r <= #G.jokers.cards and G.jokers.cards[r].config.center.key == card.config.center.key do
                count = count + 1
                r = r + 1
            end
            if count >= 3 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J860 Chain
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_chain',
    config = { extra = { mult_per = 5 } },
    rarity = 1,
    atlas = 'j_pos_chain',
    pos = { x = 0, y = 0 },
    cost = 5,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            local neighbors = 0
            if idx > 1 and G.jokers.cards[idx-1].config.center.key == card.config.center.key then neighbors = neighbors + 1 end
            if idx < #G.jokers.cards and G.jokers.cards[idx+1].config.center.key == card.config.center.key then neighbors = neighbors + 1 end
            return {
                mult_mod = neighbors * card.ability.extra.mult_per,
                message = localize { type = 'variable', key = 'a_mult', vars = { neighbors * card.ability.extra.mult_per } }
            }
        end
    end
})

-- J861 Magnet
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_magnet',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_pos_magnet',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            for i=1, #G.hand.cards do
                if G.hand.cards[i].config.center.key == 'm_odyssey_platinum' then count = count + 1 end
            end
            if count > 0 then
                return {
                    mult_mod = card.ability.extra.mult * count,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult * count } }
                }
            end
        end
    end
})

-- J862 Repulsor
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_repulsor',
    config = { extra = { chips = 100 } },
    rarity = 1,
    atlas = 'j_pos_repulsor',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local my_pos = nil
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i] == card then my_pos = i break end
            end
            if my_pos == 1 or my_pos == #G.jokers.cards then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    end
})

-- J863 Mirror
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_mirror',
    config = {},
    rarity = 1,
    atlas = 'j_pos_mirror',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    calculate = function(self, card, context)
        local my_pos = nil
        for i=1, #G.jokers.cards do if G.jokers.cards[i] == card then my_pos = i break end end
        if my_pos then
            local target_pos = #G.jokers.cards - my_pos + 1
            if target_pos ~= my_pos and G.jokers.cards[target_pos] then
                local other_joker = G.jokers.cards[target_pos]
                if other_joker.config.center.blueprint_compat then
                    context.blueprint = (context.blueprint and (context.blueprint + 1)) or 1
                    context.blueprint_card = context.blueprint_card or card
                    if context.blueprint > #G.jokers.cards + 1 then return end
                    local other_joker_ret = other_joker:calculate_joker(context)
                    if other_joker_ret then
                        other_joker_ret.card = context.blueprint_card or card
                        return other_joker_ret
                    end
                end
            end
        end
    end
})

-- J864 Prism
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_prism',
    config = {},
    rarity = 1,
    atlas = 'j_pos_prism',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = false,
    -- This one should probably be handled in vanilla_override or a global context
    -- Let's make it simpler for now: Copies left joker for every joker slot? No.
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J865 Lens
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_lens',
    config = { extra = { mult = 0 } },
    rarity = 1,
    atlas = 'j_pos_lens',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J866 Amplifier
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_amplifier',
    config = { extra = { factor = 1.5 } },
    rarity = 1,
    atlas = 'j_pos_amplifier',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.factor } }

    end,
    calculate = function(self, card, context)
        local other_joker = get_joker_neighbor(card, 'right')
        if other_joker and other_joker ~= card and other_joker.config.center.blueprint_compat then
            context.blueprint = (context.blueprint and (context.blueprint + 1)) or 1
            context.blueprint_card = context.blueprint_card or card
            if context.blueprint > #G.jokers.cards + 1 then return end
            local other_joker_ret = other_joker:calculate_joker(context)
            if other_joker_ret then
                if other_joker_ret.mult_mod then other_joker_ret.mult_mod = other_joker_ret.mult_mod * (card.ability.extra.factor - 1) end
                if other_joker_ret.chip_mod then other_joker_ret.chip_mod = other_joker_ret.chip_mod * (card.ability.extra.factor - 1) end
                if other_joker_ret.x_mult then 
                    other_joker_ret.x_mult = card.ability.extra.factor - (card.ability.extra.factor - 1) / other_joker_ret.x_mult
                end
                other_joker_ret.card = card
                return other_joker_ret
            end
        end
    end
})

-- J867 Silencer
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_silencer',
    config = { extra = { x_mult = 3 } },
    rarity = 1,
    atlas = 'j_pos_silencer',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- J868 Battery
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_battery',
    config = {},
    rarity = 1,
    atlas = 'j_pos_battery',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    calculate = function(self, card, context)
        local other_joker = get_joker_neighbor(card, 'right')
        if other_joker and other_joker ~= card and other_joker.config.center.blueprint_compat then
            context.repetition = (context.repetition or 0) + 1
            if context.repetition > 1 then return end
            local other_joker_ret = other_joker:calculate_joker(context)
            if other_joker_ret then
                 other_joker_ret.message = "RECHARGE!"
                 return other_joker_ret
            end
        end
    end
})

-- J869 Ground Wire
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_ground_wire',
    config = { extra = { chips = 100 } },
    rarity = 1,
    atlas = 'j_pos_ground_wire',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.chips } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- J870 Connector
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_connector',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_pos_connector',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "BRIDGE",
                colour = G.C.MULT
            }
        end
    end
})


----------------------------------------------
-- POSITIONING & ADJACENCY (UNCOMMON) J871-J888
----------------------------------------------

-- J871 Battle Formation
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_battle_formation',
    config = { extra = { mult = 15, chips = 50 } },
    rarity = 2,
    atlas = 'j_pos_battle_formation',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            if idx == 1 or idx == #G.jokers.cards then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            else
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    end
})

-- J872 Frontline
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_frontline',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_pos_frontline',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            if idx <= 2 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J873 Backline
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_backline',
    config = { extra = { chips = 100 } },
    rarity = 2,
    atlas = 'j_pos_backline',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.joker_main then
             local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            if idx >= #G.jokers.cards - 1 then
                return {
                    chip_mod = card.ability.extra.chips,
                    message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
                }
            end
        end
    end
})

-- J874 Flank
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_flank',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_pos_flank',
    pos = { x = 0, y = 0 },
    cost = 8,
    calculate = function(self, card, context)
        if context.joker_main then
            if #G.jokers.cards >= 2 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J875 Siege
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_siege',
    config = { extra = { mult = 50 } },
    rarity = 2,
    atlas = 'j_pos_siege',
    pos = { x = 0, y = 0 },
    cost = 8,
    calculate = function(self, card, context)
        if context.joker_main then
            if #G.jokers.cards >= G.jokers.config.card_limit then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- J876 Isolation
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_isolation',
    config = { extra = { x_mult = 2.5 } },
    rarity = 2,
    atlas = 'j_pos_isolation',
    pos = { x = 0, y = 0 },
    cost = 9,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            local isolated = true
            -- Simplified check: usually jokers are always adjacent in the UI
            -- but maybe we can check if they are "separated" by something
            if isolated then
                 return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J877 Clumping
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_clumping',
    config = { extra = { mult = 30 } },
    rarity = 2,
    atlas = 'j_pos_clumping',
    pos = { x = 0, y = 0 },
    cost = 7,
    calculate = function(self, card, context)
        if context.joker_main then
             if #G.jokers.cards >= 3 then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- J878 Musical Chairs
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_musical_chairs',
    config = { extra = { mult = 15 } },
    rarity = 2,
    atlas = 'j_pos_musical_chairs',
    pos = { x = 0, y = 0 },
    cost = 6,
    calculate = function(self, card, context)
        if context.end_of_round and not context.blueprint and not context.other_card then
            -- Randomize positions
            G.E_MANAGER:add_event(Event({
                func = function()
                    G.jokers:shuffle()
                    return true
                end
            }))
        end
        if context.joker_main then
             return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J879 Carousel
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_carousel',
    config = { extra = { mult = 10 } },
    rarity = 2,
    atlas = 'j_pos_carousel',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.first_hand_column and not context.blueprint then
             -- Shift right
             G.E_MANAGER:add_event(Event({
                func = function()
                    local last = G.jokers.cards[#G.jokers.cards]
                    table.remove(G.jokers.cards, #G.jokers.cards)
                    table.insert(G.jokers.cards, 1, last)
                    return true
                end
             }))
        end
    end
})

-- J880 Rook
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_rook',
    config = { extra = { mult = 25 } },
    rarity = 2,
    atlas = 'j_pos_rook',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local king_present = false
            if G.jokers then
                for _, v in ipairs(G.jokers.cards) do
                    if v.config.center.key == 'j_odyssey_j_pos_king' then
                        king_present = true
                        break
                    end
                end
            end

            if king_present then
                return {
                    x_mult = 2,
                    message = "PROTECTED!",
                    colour = G.C.BLUE
                }
            else
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- J881 Bishop
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_bishop',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_pos_bishop',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local my_pos = nil
            for i=1, #G.jokers.cards do if G.jokers.cards[i] == card then my_pos = i break end end
            if my_pos and my_pos % 2 == 1 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- J882 Knight
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_knight',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_pos_knight',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J883 King
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_king',
    config = { extra = { x_mult = 2.5 } },
    rarity = 2,
    atlas = 'j_pos_king',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
             local my_pos = nil
             for i=1, #G.jokers.cards do if G.jokers.cards[i] == card then my_pos = i break end end
             local neighbors = 0
             if my_pos > 1 then neighbors = neighbors + 1 end
             if my_pos < #G.jokers.cards then neighbors = neighbors + 1 end
             if neighbors == 2 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
             end
        end
    end
})

-- J884 Queen
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_queen',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_pos_queen',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- J885 Pawn
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_pawn',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_pos_pawn',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local idx = 0
            for i = 1, #G.jokers.cards do if G.jokers.cards[i] == card then idx = i; break end end
            if idx == #G.jokers.cards then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = "QUEENED!",
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

-- J886 Castling
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_castling',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_pos_castling',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- J887 Check
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_check',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_pos_check',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.blind.boss then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = "CHECK!",
                    colour = G.C.RED
                }
            end
        end
    end
})

-- J888 Checkmate
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_checkmate',
    config = { extra = { x_mult = 10 } },
    rarity = 2,
    atlas = 'j_pos_checkmate',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.chips >= G.GAME.blind.chips * 0.9 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = "CHECKMATE!",
                colour = G.C.GOLD
            }
        end
    end
})


----------------------------------------------
-- POSITIONING & ADJACENCY (RARE) J889-J898
----------------------------------------------

-- J889 Pentagram
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_pentagram',
    config = { extra = { x_mult = 6.66 } },
    rarity = 3,
    atlas = 'j_pos_pentagram',
    pos = { x = 0, y = 0 },
    cost = 13,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main and #G.jokers.cards == 5 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = "THE BEAST",
                colour = G.C.RED
            }
        end
    end
})

-- J890 Alignment
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_alignment',
    config = { extra = { x_mult = 4 } },
    rarity = 3,
    atlas = 'j_pos_alignment',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local same = true
            local first_rarity = G.jokers.cards[1].config.rarity
            for i = 2, #G.jokers.cards do
                if G.jokers.cards[i].config.rarity ~= first_rarity then same = false; break end
            end
            if same and #G.jokers.cards > 1 then
                 return {
                    x_mult = card.ability.extra.x_mult,
                    message = "ALIGNED",
                    colour = G.C.BLUE
                }
            end
        end
    end
})

-- J891 Disorder
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_disorder',
    config = { extra = { x_mult = 4 } },
    rarity = 3,
    atlas = 'j_pos_disorder',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local seen = {}
            local unique = true
            for i = 1, #G.jokers.cards do
                local r = G.jokers.cards[i].config.rarity
                if seen[r] then unique = false; break end
                seen[r] = true
            end
            if unique and #G.jokers.cards > 1 then
                 return {
                    x_mult = card.ability.extra.x_mult,
                    message = "DISORDER",
                    colour = G.C.ORANGE
                }
            end
        end
    end
})

-- J892 Symmetry
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_symmetry',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_pos_symmetry',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local is_symmetric = true
            for i = 1, math.floor(#G.jokers.cards / 2) do
                if G.jokers.cards[i].config.rarity ~= G.jokers.cards[#G.jokers.cards - i + 1].config.rarity then
                    is_symmetric = false
                    break
                end
            end
            if is_symmetric and #G.jokers.cards > 1 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = "SYMMETRY",
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

-- J893 Positional Chaos
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_positional_chaos',
    config = { extra = { mult = 40 } },
    rarity = 3,
    atlas = 'j_pos_positional_chaos',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "CHAOS!",
                colour = G.C.FILTER
            }
        end
    end
})

-- J894 Black Hole
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_black_hole',
    config = { extra = { x_mult = 4 } },
    rarity = 3,
    atlas = 'j_pos_black_hole',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local my_pos = nil
            for i=1, #G.jokers.cards do if G.jokers.cards[i] == card then my_pos = i break end end
            if my_pos == math.ceil(#G.jokers.cards / 2) and #G.jokers.cards % 2 ~= 0 then -- True center
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = "SINGULARITY!",
                    colour = G.C.BLACK
                }
            end
        end
    end
})

-- J895 Supernova
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_supernova',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_pos_supernova',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local my_pos = nil
            for i=1, #G.jokers.cards do if G.jokers.cards[i] == card then my_pos = i break end end
            if my_pos == 1 or my_pos == #G.jokers.cards then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = "EXPLOSION!",
                    colour = G.C.ORANGE
                }
            end
        end
    end
})

-- J896 Galaxy
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_galaxy',
    config = { extra = { x_mult_mod = 1.2 } },
    rarity = 3,
    atlas = 'j_pos_galaxy',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = (G.jokers and G.jokers.cards) and #G.jokers.cards or 0
        local total_xmult = ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_mod ^ count
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult_mod, total_xmult } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local total_xmult = card.ability.extra.x_mult_mod ^ #G.jokers.cards
            return {
                x_mult = total_xmult,
                message = "ORBITAL",
                colour = G.C.BLUE
            }
        end
    end
})

-- J897 Universe
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_universe',
    config = { extra = { slots = 4 } },
    rarity = 3,
    atlas = 'j_pos_universe',
    pos = { x = 0, y = 0 },
    cost = 12,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.slots } }

    end,
    add_to_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.slots
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.slots
    end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J898 Multiverse
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_multiverse',
    config = { extra = { x_mult = 2 } },
    rarity = 3,
    atlas = 'j_pos_multiverse',
    pos = { x = 0, y = 0 },
    cost = 12,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.GAME and G.GAME.probabilities then
            for k, v in pairs(G.GAME.probabilities) do count = count + 1 end
        end
        return { vars = { 1 + (count * 0.1) } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
             local count = 0
             for k, v in pairs(G.GAME.probabilities) do count = count + 1 end
             return {
                x_mult = 1 + (count * 0.1),
                message = "MULTIVERSE",
                colour = G.C.PURPLE
             }
        end
    end
})


----------------------------------------------
-- POSITIONING & ADJACENCY (LEGENDARY) J899-J900
----------------------------------------------

-- J899 The Architect
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_the_architect',
    config = { extra = { slots = 5 } },
    rarity = 4,
    atlas = 'j_pos_the_architect',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.slots } }

    end,
    add_to_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.slots
    end,
    remove_from_deck = function(self, card, from_debuff)
        G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.slots
    end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- J900 The Conductor
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_pos_the_conductor',
    config = { extra = { x_mult = 5, step = 0.2 } },
    rarity = 4,
    atlas = 'j_pos_the_conductor',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { extra.x_mult, extra.step } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local my_pos = nil
            for i=1, #G.jokers.cards do if G.jokers.cards[i] == card then my_pos = i break end end
            local bonus = (my_pos - 1) * card.ability.extra.step
            return {
                x_mult = card.ability.extra.x_mult + bonus,
                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult + bonus } },
                colour = G.C.RED
            }
        end
        -- Also buff others when they calculate?
        -- Actually, it's easier to just have the Conductor provide the cumulative bonus itself based on its own position.
        -- But the description says "All Jokers trigger in sequence with cumulative multiplier".
        -- Let's make it a global hook in other_joker context.
        if context.other_joker and context.other_joker ~= card then
             local other_pos = nil
             for i=1, #G.jokers.cards do if G.jokers.cards[i] == context.other_joker then other_pos = i break end end
             if other_pos then
                return {
                    x_mult = 1 + (other_pos * card.ability.extra.step),
                    message = "VIVO!",
                    colour = G.C.GOLD
                }
             end
        end
    end
})


-- J901-920: Conditions & Logic (Common)

-- Hair Trigger (J901)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_hair_trigger',
    config = { extra = { mult = 2 } },
    rarity = 1,
    atlas = 'j_cond_hair_trigger',
    pos = { x = 0, y = 0 },
    cost = 2,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.cardarea == G.play and not context.repetition then
            return {
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },
                mult_mod = card.ability.extra.mult,
                card = card
            }
        end
    end
})

-- Heavy Trigger (J902)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_heavy_trigger',
    config = { extra = { mult = 15 } },
    rarity = 1,
    atlas = 'j_cond_heavy_trigger',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and context.full_hand and #context.full_hand == 5 then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Conditional (J903)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_conditional',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_cond_conditional',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_left == 0 then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- If (J904)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_if',
    config = { extra = { mult = 20 } },
    rarity = 1,
    atlas = 'j_cond_if',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.dollars == 0 then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Else (J905)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_else',
    config = { extra = { mult = 5 } },
    rarity = 1,
    atlas = 'j_cond_else',
    pos = { x = 0, y = 0 },
    cost = 3,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.dollars ~= 0 then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- While (J906)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_while',
    config = { extra = { chips = 10 } },
    rarity = 1,
    atlas = 'j_cond_while',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_left > 0 then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- For Loop (J907)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_for_loop',
    config = { extra = { mult = 2 } },
    rarity = 1,
    atlas = 'j_cond_for_loop',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = #G.hand.cards
            return {
                mult_mod = card.ability.extra.mult * count,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult * count } }
            }
        end
    end
})

-- Switch (J908)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_switch',
    config = { extra = { mult = 10, chips = 50, money = 2 } },
    rarity = 1,
    atlas = 'j_cond_switch',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Hearts') then
                return {
                    mult = card.ability.extra.mult,
                    card = card
                }
            elseif context.other_card:is_suit('Spades') then
                return {
                    chips = card.ability.extra.chips,
                    card = card
                }
            elseif context.other_card:is_suit('Diamonds') then
                ease_dollars(card.ability.extra.money)
                return {
                    message = localize('$')..card.ability.extra.money,
                    colour = G.C.MONEY,
                    card = card
                }
            elseif context.other_card:is_suit('Clubs') then
                return {
                    extra = { focus = card, message = localize('k_again_ex'), func = function() return true end },
                    card = card
                }
            end
        end
    end
})

-- Break (J909)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_break',
    rarity = 1,
    atlas = 'j_cond_break',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.chips + (G.GAME.current_round.current_hand and G.GAME.current_round.current_hand.chips or 0) >= G.GAME.blind.chips then
            -- Note: We can't easily "stop" scoring in many ways without complex hooks, 
            -- but we can signal it. For now, it's a flavor/utility card that might need custom hooks.
            return {
                message = "BREAK!",
                colour = G.C.FILTER
            }
        end
    end
})

-- Continue (J910)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_continue',
    rarity = 1,
    atlas = 'j_cond_continue',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            -- This is tricky. Repetitions normally happen card by card.
            -- This joker would need to track "next card" which is hard in calculate.
            return {
                message = "CONTINUE!",
                repetitions = 1,
                card = card
            }
        end
    end
})

-- Return (J911)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_return',
    rarity = 1,
    atlas = 'j_cond_return',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.1,
                func = function()
                    draw_card(G.play, G.hand, 100, 'up', true, context.other_card)
                    return true
                end
            }))
            return {
                message = "RETURN!",
                colour = G.C.BLUE,
                card = card
            }
        end
    end
})

-- Print (J912)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_print',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_cond_print',
    pos = { x = 0, y = 0 },
    cost = 2,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "Hello World!",
                colour = G.C.WHITE
            }
        end
    end
})

-- Input (J913)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_input',
    rarity = 1,
    atlas = 'j_cond_input',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            -- In Balatro, we don't have "click to activate" easily in calculate.
            -- Using a probability or simple mult for now.
            return {
                mult_mod = 10,
                message = "INPUT RECEIVED"
            }
        end
    end
})

-- Output (J914)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_output',
    config = { extra = { money = 5 } },
    rarity = 1,
    atlas = 'j_cond_output',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end,
    calc_dollar_bonus = function(self, card)
        return card.ability.extra.money
    end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})

-- Variable (J915)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_variable',
    config = { extra = { mult = 0 } },
    rarity = 1,
    atlas = 'j_cond_variable',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.end_of_round and not context.other_card and not context.repetition and not context.blueprint then
            card.ability.extra.mult = card.ability.extra.mult + 1
            return {
                message = "++Var",
                colour = G.C.MULT
            }
        end
    end
})

-- Constant (J916)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_constant',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_cond_constant',
    pos = { x = 0, y = 0 },
    cost = 3,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Function (J917)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_function',
    rarity = 1,
    atlas = 'j_cond_function',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.jokers then
            local my_pos = nil
            for i=1, #G.jokers.cards do
                if G.jokers.cards[i] == card then my_pos = i; break end
            end
            if my_pos and my_pos > 1 and G.jokers.cards[my_pos-1] == context.other_joker then
                return {
                    message = localize('k_again_ex'),
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- Class (J918)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_class',
    config = { extra = { mult = 4 } },
    rarity = 1,
    atlas = 'j_cond_class',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.other_joker and context.other_joker.config.rarity == 1 and context.other_joker ~= card then
            if context.joker_main then
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- Object (J919)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_object',
    rarity = 1,
    atlas = 'j_cond_object',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.selling_self then
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.1,
                func = function()
                    local _card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'obj')
                    _card:add_to_deck()
                    G.consumeables:emplace(_card)
                    return true
                end
            }))
        end
    end
})

-- Array (J920)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_array',
    config = { extra = { mult = 5 } },
    rarity = 1,
    atlas = 'j_cond_array',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = #G.jokers.cards
            return {
                mult_mod = card.ability.extra.mult * count,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult * count } }
            }
        end
    end
})


-- J921-938: Conditions & Logic (Uncommon)

-- Boolean (J921)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_boolean',
    config = { extra = { x_mult_true = 2, x_mult_false = 0.5 } },
    rarity = 2,
    atlas = 'j_cond_boolean',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult_true, (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult_false } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local cond = (pseudorandom('boolean') > 0.5)
            local mod = cond and card.ability.extra.x_mult_true or card.ability.extra.x_mult_false
            return {
                x_mult = mod,
                message = cond and "TRUE!" or "FALSE!",
                colour = cond and G.C.GREEN or G.C.RED
            }
        end
    end
})

-- Integer (J922)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_integer',
    rarity = 2,
    atlas = 'j_cond_integer',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            -- This would need to run after all other mults.
            -- In Balatro's calculate loop, we don't have a clean "post-process" hook for just one joker.
            -- But we can simulate it by being high index or just floor/ceil.
            return {
                message = "INT",
                colour = G.C.FILTER
            }
        end
    end
})

-- Float (J923)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_float',
    rarity = 2,
    atlas = 'j_cond_float',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    calculate = function(self, card, context)
        -- Balatro already allows floats, so this is flavor/enabler.
        if context.joker_main then
            return {
                mult_mod = 0.5,
                message = "+0.5"
            }
        end
    end
})

-- String (J924)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_string',
    config = { extra = { mult = 10 } },
    rarity = 2,
    atlas = 'j_cond_string',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local msgs = {"YOU CAN DO IT", "STAY FOCUSED", "BIG BLIND AHEAD", "LUA IS BEST"}
            local msg = msgs[math.random(#msgs)]
            return {
                mult_mod = card.ability.extra.mult,
                message = msg,
                colour = G.C.MULT
            }
        end
    end
})

-- Char (J925)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_char',
    rarity = 2,
    atlas = 'j_cond_char',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and context.scoring_name then
            local char = string.sub(context.scoring_name, 1, 1)
            -- Different bonus per first char
            local bonus = 5
            if char == 'S' or char == 'F' then bonus = 15 end -- Straight, Flush, Full House
            return {
                mult_mod = bonus,
                message = char .. "!"
            }
        end
    end
})

-- Null (J926)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_null',
    rarity = 2,
    atlas = 'j_cond_null',
    pos = { x = 0, y = 0 },
    cost = 1,
    blueprint_compat = true,
    calculate = function(self, card, context)
        -- Literally does nothing.
    end
})

-- Undefined (J927)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_undefined',
    rarity = 2,
    atlas = 'j_cond_undefined',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local r = math.random()
            if r < 0.25 then return { mult = 10 }
            elseif r < 0.5 then return { chips = 50 }
            elseif r < 0.75 then return { x_mult = 1.5 }
            else return { message = "UNDEFINED", colour = G.C.FILTER } end
        end
    end
})

-- NaN (J928)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_nan',
    config = { extra = { mult = 11 } },
    rarity = 2,
    atlas = 'j_cond_nan',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = "N/A/N",
                colour = G.C.BLACK
            }
        end
    end
})

-- Infinity (J929)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_infinity',
    rarity = 2,
    atlas = 'j_cond_infinity',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = 5,
                message = "INF",
                colour = G.C.MULT
            }
        end
    end
})

-- Exception (J930)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_exception',
    config = { extra = { money = 10 } },
    rarity = 2,
    atlas = 'j_cond_exception',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end,
    calculate = function(self, card, context)
        -- Triggered if something "fails" (like a 1 in X chance)
        if context.joker_main and G.GAME.probabilities.normal > 100 then -- fake cond
            ease_dollars(card.ability.extra.money)
            return {
                message = "EXC!",
                colour = G.C.MONEY
            }
        end
    end
})

-- Try Catch (J931)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_try_catch',
    config = { extra = { money = 5 } },
    rarity = 2,
    atlas = 'j_cond_try_catch',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            -- Tries to activate a random joker
            local other = G.jokers.cards[math.random(#G.jokers.cards)]
            if other and other ~= card then
                return other:calculate_joker(context)
            else
                ease_dollars(card.ability.extra.money)
                return {
                    message = "CATCH!",
                    colour = G.C.MONEY
                }
            end
        end
    end
})

-- Async (J932)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_async',
    rarity = 2,
    atlas = 'j_cond_async',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.after then
            return {
                mult = 20,
                message = "ASYNC"
            }
        end
    end
})

-- Await (J933)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_await',
    rarity = 2,
    atlas = 'j_cond_await',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.blind.boss then
            return {
                x_mult = 3,
                message = "AWAIT DONE"
            }
        end
    end
})

-- Promise (J934)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_promise',
    config = { extra = { rounds = 3, x_mult = 3 } },
    rarity = 2,
    atlas = 'j_cond_promise',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).rounds } } end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.repetition and not context.blueprint then
            card.ability.extra.rounds = card.ability.extra.rounds - 1
            if card.ability.extra.rounds <= 0 then
                card:juice_up()
                return {
                    message = "FULFILLED!",
                    colour = G.C.GOLD
                }
            end
        end
        if context.joker_main and card.ability.extra.rounds <= 0 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = "PROMISED"
            }
        end
    end
})

-- Callback (J935)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_callback',
    rarity = 2,
    atlas = 'j_cond_callback',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local target = G.jokers.cards[math.random(#G.jokers.cards)]
            if target and target ~= card then
                return target:calculate_joker(context)
            end
        end
    end
})

-- Recursion (J936)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_recursion',
    rarity = 2,
    atlas = 'j_cond_recursion',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.jokers and context.other_joker == card then
            -- Note: recursive repetition needs a limit to avoid lock
            if (context.recursion_count or 0) < 2 then
                context.recursion_count = (context.recursion_count or 0) + 1
                return {
                    message = "REC",
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- Stack (J937)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_stack',
    config = { extra = { mult = 0 } },
    rarity = 2,
    atlas = 'j_cond_stack',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        if context.selling_card and not context.blueprint then
            card.ability.extra.mult = card.ability.extra.mult + 2
            return {
                message = "STACK+",
                colour = G.C.MULT
            }
        end
    end
})

-- Heap (J938)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_heap',
    config = { extra = { money = 1 } },
    rarity = 2,
    atlas = 'j_cond_heap',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).money } } end,
    calc_dollar_bonus = function(self, card)
        return (G.jokers and G.jokers.cards and #G.jokers.cards or 0) * card.ability.extra.money
    end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- J939-948: Conditions & Logic (Rare)

-- Algorithm (J939)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_algorithm',
    config = { extra = { mult = 15 } },
    rarity = 3,
    atlas = 'j_cond_algorithm',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.first_hand_drawn then
            G.hand:sort()
            return {
                message = "SORTED",
                colour = G.C.BLUE
            }
        end
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- AI (J940)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_ai',
    config = { extra = { x_mult = 1 } },
    rarity = 3,
    atlas = 'j_cond_ai',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
        if context.before and not context.blueprint then
            card.ability.extra.x_mult = card.ability.extra.x_mult + 0.1
            return {
                message = "LEARNING...",
                colour = G.C.FILTER
            }
        end
    end
})

-- Neural Net (J941)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_neural_net',
    rarity = 3,
    atlas = 'j_cond_neural_net',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local target = G.jokers.cards[math.random(#G.jokers.cards)]
            if target and target ~= card then
                return target:calculate_joker(context)
            end
        end
    end
})

-- Deep Learning (J942)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_deep_learning',
    config = { extra = { x_mult = 1, gain = 0.5 } },
    rarity = 3,
    atlas = 'j_cond_deep_learning',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = true,
    perishable_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).gain } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
        if context.end_of_round and not context.other_card and G.GAME.blind.boss and not context.repetition and not context.blueprint then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.gain
            return {
                message = "DEEPENED!",
                colour = G.C.MULT
            }
        end
    end
})

-- Machine Learning (J943)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_machine_learning',
    config = { extra = { last_hand = nil, count = 0 } },
    rarity = 3,
    atlas = 'j_cond_machine_learning',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.before then
            if context.scoring_name == card.ability.extra.last_hand then
                card.ability.extra.played = card.ability.extra.played + 1
            else
                card.ability.extra.last_hand = context.scoring_name
                card.ability.extra.played = 1
            end
            
            if card.ability.extra.played >= 3 then
                card.ability.extra.played = 0
                update_hand_stats(context.scoring_name, 1)
                return {
                    message = "LEVEL UP!",
                    colour = G.C.ATTENTION
                }
            end
        end
    end
})

-- Big Data (J944)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_big_data',
    rarity = 3,
    atlas = 'j_cond_big_data',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)

        local extra = ( (card and card.ability and card.ability.extra) or self.config.extra )

        return { vars = { (G.playing_cards and #G.playing_cards or 52) } }

    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = #G.playing_cards
            return {
                mult_mod = count,
                message = localize{ type = 'variable', key = 'a_mult', vars = { count } }
            }
        end
    end
})

-- Blockchain (J945)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_blockchain',
    config = { extra = { gain = 2 } },
    rarity = 3,
    atlas = 'j_cond_blockchain',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).gain } } end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.other_card and not context.repetition then
            card.ability.sell_cost = card.ability.sell_cost + card.ability.extra.gain
            return {
                message = "MINED!",
                colour = G.C.GOLD
            }
        end
    end
})

-- NFT (J946)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_nft',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_cond_nft',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    add_to_deck = function(self, card)
        card.ability.eternal = true
        card.ability.sell_cost = 0
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Metaverse (J947)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_metaverse',
    rarity = 3,
    atlas = 'j_cond_metaverse',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.first_hand_drawn then
            local target = G.jokers.cards[math.random(#G.jokers.cards)]
            if target and target ~= card then
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        local _card = copy_card(target)
                        _card:add_to_deck()
                        G.jokers:emplace(_card)
                        _card.ability.eternal = true -- temporary hack
                        -- We need a way to remove it later, maybe tag it
                        _card.meta_temporary = true
                        return true
                    end
                }))
                return {
                    message = "VIRTUAL CLONE",
                    colour = G.C.PURPLE
                }
            end
        end
        if context.end_of_round and not context.other_card then
             for i = #G.jokers.cards, 1, -1 do
                 if G.jokers.cards[i].meta_temporary then
                     G.jokers.cards[i]:remove()
                 end
             end
        end
    end
})

-- Web 3.0 (J948)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_web3',
    rarity = 3,
    atlas = 'j_cond_web3',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = false,
    add_to_deck = function(self, card)
        G.jokers.config.card_limit = G.jokers.config.card_limit + 1
        G.consumeables.config.card_limit = G.consumeables.config.card_limit - 1
    end,
    remove_from_deck = function(self, card)
        G.jokers.config.card_limit = G.jokers.config.card_limit - 1
        G.consumeables.config.card_limit = G.consumeables.config.card_limit + 1
    end,
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    calculate = function(self, card, context)
        -- Auto-generated functional stub
    end
})


-- J949-950: Conditions & Logic (Legendary)

-- Turing Complete (J949)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_turing_complete',
    rarity = 4,
    atlas = 'j_cond_turing_complete',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            -- True simulation: Copy a random Joker from the entire pool
            if not card.ability.simulated_key or context.before then
                local keys = {}
                for k, v in pairs(G.P_CENTERS) do
                    if v.set == 'Joker' and k ~= card.config.center.key then
                        table.insert(keys, k)
                    end
                end
                card.ability.simulated_key = keys[math.random(#keys)]
            end
            
            local target = G.P_CENTERS[card.ability.simulated_key]
            if target and target.calculate then
                local res = target:calculate(card, context)
                if res then 
                    res.message = "SIMULATING: " .. target.name
                    return res
                end
            end
            
            return {
                x_mult = 5,
                message = "SIMULATED",
                colour = G.C.GOLD
            }
        end
    end
})

-- Tech Singularity (J950)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_cond_tech_singularity',
    rarity = 4,
    atlas = 'j_cond_tech_singularity',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.first_hand_drawn then
            -- Automatic victory simulation
            -- In real game, this might be too much, but for 1000 jokers, let's make it epic
            G.GAME.chips = G.GAME.blind.chips + 1
            if G.GAME.current_round.current_hand then
                G.GAME.current_round.current_hand.chips = 0
            end
            
            return {
                message = "SINGULARITY!",
                colour = G.C.BLACK
            }
        end
    end
})


-- J951-970: Final & Specials (Common)

-- The End (J951)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_the_end',
    config = { extra = { mult = 20, x_mult = 4 } },
    rarity = 1,
    atlas = 'j_final_the_end',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.current_round.hands_left == 0 and G.GAME.round_resets.ante >= 8 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            else
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- The Beginning (J952)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_the_beginning',
    config = { extra = { mult = 20, chips = 100 } },
    rarity = 1,
    atlas = 'j_final_the_beginning',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).chips } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_played < 3 then
            return {
                mult_mod = card.ability.extra.mult,
                chip_mod = card.ability.extra.chips,
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
    end
})

-- The Middle (J953)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_the_middle',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_final_the_middle',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.hands_left == 3 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Prologue (J954)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_prologue',
    config = { extra = { mult = 10, last_ante = -1 } },
    rarity = 1,
    atlas = 'j_final_prologue',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint and card.ability.extra.last_ante < G.GAME.round_resets.ante then
            card.ability.extra.last_ante = G.GAME.round_resets.ante
            local tag = Tag(get_next_tag_key('joker_prologue'))
            add_tag(tag)
            return {
                message = "TAG!",
                colour = G.C.FILTER
            }
        end
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Epilogue (J955)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_epilogue',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_final_epilogue',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.end_of_round and not context.blueprint and not context.repetition and not context.other_card then
            local overkill = G.GAME.chips - G.GAME.blind.chips
            if overkill > 0 then
                local dollars = math.min(10, math.floor(overkill / 100))
                if dollars > 0 then
                    ease_dollars(dollars)
                    return {
                        message = localize{type='variable', key='a_money', vars={dollars}},
                        colour = G.C.MONEY
                    }
                end
            end
        end
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Chapter 1 (J956)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_chapter1',
    config = { extra = { mult_per_hand = 5 } },
    rarity = 1,
    atlas = 'j_final_chapter1',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) 
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_hand, (G.GAME.current_round.hands_played or 0) * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_hand } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local mult = (G.GAME.current_round.hands_played or 0) * card.ability.extra.mult_per_hand
            if mult > 0 then
                return {
                    mult_mod = mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } }
                }
            end
        end
    end
})

-- Chapter 2 (J957)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_chapter2',
    config = { extra = { mult_per_discard = 5 } },
    rarity = 1,
    atlas = 'j_final_chapter2',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) 
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_discard, (G.GAME.current_round.discards_used or 0) * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_discard } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local mult = (G.GAME.current_round.discards_used or 0) * card.ability.extra.mult_per_discard
            if mult > 0 then
                return {
                    mult_mod = mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { mult } }
                }
            end
        end
    end
})

-- Chapter 3 (J958)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_chapter3',
    config = { extra = { mult_per_card = 5 } },
    rarity = 1,
    atlas = 'j_final_chapter3',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult_per_card } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            return {
                mult = card.ability.extra.mult_per_card,
                card = card
            }
        end
    end
})

-- Climax (J959)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_climax',
    config = { extra = { x_mult = 3 } },
    rarity = 1,
    atlas = 'j_final_climax',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            if (G.GAME.last_hand_sampling.flush or G.GAME.last_hand_sampling.straight) then
                local has_face = false
                for k, v in ipairs(context.scoring_hand) do
                    if v:is_face() then has_face = true; break end
                end
                if has_face then
                    return {
                        x_mult = card.ability.extra.x_mult,
                        message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                    }
                end
            end
        end
    end
})

-- Plot Twist (J960)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_plot_twist',
    config = { extra = { mult = 20 } },
    rarity = 1,
    atlas = 'j_final_plot_twist',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            if pseudorandom('plot_twist') < G.GAME.probabilities.normal / 4 and not context.blueprint then
                card.ability.extra.mult = card.ability.extra.mult * 2
                return {
                    mult_mod = card.ability.extra.mult,
                    message = "TWIST! X2",
                    colour = G.C.MULT
                }
            end
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Hero (J961)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_hero',
    config = { extra = { x_mult = 3 } },
    rarity = 1,
    atlas = 'j_final_hero',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and #G.jokers.cards <= 1 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Villain (J962)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_villain',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_final_villain',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    add_to_deck = function(self, card)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - 1
        ease_hands_left(-1)
    end,
    remove_from_deck = function(self, card)
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + 1
        ease_hands_left(1)
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Sidekick (J963)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_sidekick',
    config = { extra = { mult = 10 } },
    rarity = 1,
    atlas = 'j_final_sidekick',
    pos = { x = 0, y = 0 },
    cost = 4,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) 
        local count = (G.jokers and G.jokers.cards) and #G.jokers.cards or 1
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult, (count - 1) * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = #G.jokers.cards - 1
            if count > 0 then
                return {
                    mult_mod = count * card.ability.extra.mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { count * card.ability.extra.mult } }
                }
            end
        end
    end
})

-- Mentor (J964)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_mentor',
    config = { extra = { mult = 5 } },
    rarity = 1,
    atlas = 'j_final_mentor',
    pos = { x = 0, y = 0 },
    cost = 5,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) 
        local levels = 0
        for k, v in pairs(G.GAME.hands) do
            if v.played > 0 then levels = levels + v.level end
        end
        return { vars = { card.ability.extra.mult, levels * card.ability.extra.mult } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local levels = 0
            for k, v in pairs(G.GAME.hands) do
                if v.played > 0 then levels = levels + v.level end
            end
            if levels > 0 then
                return {
                    mult_mod = levels * card.ability.extra.mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { levels * card.ability.extra.mult } }
                }
            end
        end
    end
})

-- Rival (J965)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_rival',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_final_rival',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.chips < G.GAME.blind.chips then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Love (J966)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_love',
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    atlas = 'j_final_love',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Hearts') then
                return {
                    x_mult = card.ability.extra.x_mult,
                    card = card
                }
            end
        end
    end
})

-- Hate (J967)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_hate',
    config = { extra = { x_mult = 1.5 } },
    rarity = 1,
    atlas = 'j_final_hate',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.individual and context.cardarea == G.play then
            if context.other_card:is_suit('Spades') then
                return {
                    x_mult = card.ability.extra.x_mult,
                    card = card
                }
            end
        end
    end
})

-- Peace (J968)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_peace',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_final_peace',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_used == 0 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- War (J969)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_war',
    config = { extra = { mult = 0, mult_per_dest = 2 } },
    rarity = 1,
    atlas = 'j_final_war',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult_per_dest, (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
        -- Need global hook for destruction, but we can simulate with selling cards or specific effects
    end
})

-- Death (J970)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_death',
    config = { extra = { x_mult = 2 } },
    rarity = 1,
    atlas = 'j_final_death',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            if #G.hand.cards > 0 and not context.blueprint then
                local destroyed_card = G.hand.cards[math.random(#G.hand.cards)]
                destroyed_card:start_dissolve()
            end
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})


-- J971-988: Final & Specials (Uncommon)

-- Rebirth (J971)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_rebirth',
    rarity = 2,
    atlas = 'j_final_rebirth',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.end_of_round and G.GAME.chips < G.GAME.blind.chips and not context.blueprint and not context.repetition and not context.other_card then
            if G.GAME.current_round.hands_left == 0 then
                G.GAME.chips = G.GAME.blind.chips
                if not card.ability.eternal then card:start_dissolve() end
                return {
                    message = "REBIRTH!",
                    colour = G.C.GOLD
                }
            end
        end
    end
})

-- Karma (J972)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_karma',
    config = { extra = { x_mult = 1.5, per_boss = 0.2, penalty = 0.5 } },
    rarity = 2,
    atlas = 'j_final_karma',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).x_mult, ( (card and card.ability and card.ability.extra) or self.config.extra ).per_boss, ( (card and card.ability and card.ability.extra) or self.config.extra ).penalty } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
        if context.end_of_round and G.GAME.blind.boss and not context.blueprint and not context.repetition and not context.other_card then
            card.ability.extra.x_mult = card.ability.extra.x_mult + card.ability.extra.per_boss
        end
        if context.selling_card and context.card.ability.set == 'Joker' and not context.blueprint then
            card.ability.extra.x_mult = math.max(1, card.ability.extra.x_mult - card.ability.extra.penalty)
        end
    end
})

-- Dharma (J973)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_dharma',
    config = { extra = { mult = 20, tri_mult = 60 } },
    rarity = 2,
    atlas = 'j_final_dharma',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).tri_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local most_played = nil
            local max_plays = -1
            for k, v in pairs(G.GAME.hands) do
                if v.played > max_plays then
                    max_plays = v.played
                    most_played = k
                end
            end
            
            if context.scoring_name == most_played then
                return {
                    mult_mod = card.ability.extra.tri_mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.tri_mult } }
                }
            else
                return {
                    mult_mod = card.ability.extra.mult,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
                }
            end
        end
    end
})

-- Nirvana (J974)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_nirvana',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_final_nirvana',
    pos = { x = 0, y = 0 },
    cost = 10,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and #G.hand.cards == 0 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Samsara (J975)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_samsara',
    rarity = 2,
    atlas = 'j_final_samsara',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = false,
    calculate = function(self, card, context)
        -- Hooking into card destruction is hard without global overrides, but we can check context.destroying_card if available
        -- For now, let's make it add a copy on discard to simulate cycle
        if context.discard and not context.blueprint then
            if pseudorandom('samsara') < G.GAME.probabilities.normal / 5 then
                local _card = copy_card(context.other_card)
                _card:set_edition({negative = true})
                _card:add_to_deck()
                G.deck:emplace(_card)
                return {
                    message = "SAMSARA",
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

-- Zen (J976)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_zen',
    config = { extra = { mult = 30, timer = 10, last_hand_time = G.TIMERS.REAL } },
    rarity = 2,
    atlas = 'j_final_zen',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).timer } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local now = G.TIMERS.REAL
            if now - card.ability.extra.last_hand_time >= card.ability.extra.timer then
                card.ability.extra.last_hand_time = now
                return {
                    mult_mod = card.ability.extra.mult,
                    message = "ZEN",
                    colour = G.C.MULT
                }
            end
            card.ability.extra.last_hand_time = now
        end
    end
})

-- Tao (J977)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_tao',
    config = { extra = { x_mult = 2 } },
    rarity = 2,
    atlas = 'j_final_tao',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local reds = 0
            local blacks = 0
            for k, v in ipairs(G.playing_cards) do
                if v:is_suit('Hearts') or v:is_suit('Diamonds') then reds = reds + 1
                else blacks = blacks + 1 end
            end
            if reds == blacks then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- Yin (J978)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_yin',
    config = { extra = { mult = 20, x_mult = 2 } },
    rarity = 2,
    atlas = 'j_final_yin',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_yang = false
            for k, v in ipairs(G.jokers.cards) do
                if v.config.center.key == 'j_odyssey_j_final_yang' then has_yang = true; break end
            end
            
            local spades_clubs = 0
            for k, v in ipairs(context.scoring_hand) do
                if v:is_suit('Spades') or v:is_suit('Clubs') then spades_clubs = spades_clubs + 1 end
            end
            
            if spades_clubs > 0 then
                local ret = { mult_mod = spades_clubs * card.ability.extra.mult }
                if has_yang then
                    ret.x_mult = card.ability.extra.x_mult
                end
                return ret
            end
        end
    end
})

-- Yang (J979)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_yang',
    config = { extra = { mult = 20, x_mult = 2 } },
    rarity = 2,
    atlas = 'j_final_yang',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local has_yin = false
            for k, v in ipairs(G.jokers.cards) do
                if v.config.center.key == 'j_odyssey_j_final_yin' then has_yin = true; break end
            end
            
            local hearts_diamonds = 0
            for k, v in ipairs(context.scoring_hand) do
                if v:is_suit('Hearts') or v:is_suit('Diamonds') then hearts_diamonds = hearts_diamonds + 1 end
            end
            
            if hearts_diamonds > 0 then
                local ret = { mult_mod = hearts_diamonds * card.ability.extra.mult }
                if has_yin then
                    ret.x_mult = card.ability.extra.x_mult
                end
                return ret
            end
        end
    end
})

-- Chi (J980)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_chi',
    config = { extra = { chips = 50, per_hand = 10 } },
    rarity = 2,
    atlas = 'j_final_chi',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).chips, (( (card and card.ability and card.ability.extra) or self.config.extra )).per_hand } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                chip_mod = card.ability.extra.chips,
                message = localize{ type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }
            }
        end
        if context.end_of_round and not context.blueprint and not context.repetition and not context.other_card then
            local bonus = G.GAME.current_round.hands_left * card.ability.extra.per_hand
            if bonus > 0 then
                card.ability.extra.chips = card.ability.extra.chips + bonus
                return {
                    message = "CHI +",
                    colour = G.C.CHIPS
                }
            end
        end
    end
})

-- Chakra (J981)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_chakra',
    config = { extra = { mult_per_slot = 10 } },
    rarity = 2,
    atlas = 'j_final_chakra',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) 
        local slots = (G.consumeables and G.consumeables.config) and G.consumeables.config.card_limit or 0
        return { vars = { ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_slot, slots * ( (card and card.ability and card.ability.extra) or self.config.extra ).mult_per_slot } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local slots = G.consumeables.config.card_limit
            if slots > 0 then
                return {
                    mult_mod = slots * card.ability.extra.mult_per_slot,
                    message = localize{ type = 'variable', key = 'a_mult', vars = { slots * card.ability.extra.mult_per_slot } }
                }
            end
        end
    end
})

-- Mantra (J982)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_mantra',
    config = { extra = { x_mult = 1.5 } },
    rarity = 2,
    atlas = 'j_final_mantra',
    pos = { x = 0, y = 0 },
    cost = 6,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            for k, v in ipairs(context.scoring_hand) do
                suits[v.base.suit] = true
            end
            local count = 0
            for k, v in pairs(suits) do count = count + 1 end
            
            if count == 1 then
                return {
                    x_mult = card.ability.extra.x_mult,
                    message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
                }
            end
        end
    end
})

-- Mandala (J983)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_mandala',
    rarity = 2,
    atlas = 'j_final_mandala',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.joker_main then
            local suits = {}
            for k, v in ipairs(context.scoring_hand) do
                suits[v.base.suit] = true
            end
            local count = 0
            for k, v in pairs(suits) do count = count + 1 end
            
            if count >= 4 and #G.consumeables.cards < G.consumeables.config.card_limit then
                local _card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, nil, 'mandala')
                _card:add_to_deck()
                G.consumeables:emplace(_card)
                return {
                    message = "MANDALA!",
                    colour = G.C.PURPLE
                }
            end
        end
    end
})

-- Ltus (J984)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_lotus',
    config = { extra = { x_mult = 3 } },
    rarity = 2,
    atlas = 'j_final_lotus',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.current_round.discards_used == 0 then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Om (J985)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_om',
    rarity = 2,
    atlas = 'j_final_om',
    pos = { x = 0, y = 0 },
    cost = 8,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.repetition and context.cardarea == G.play then
            if context.other_card == context.scoring_hand[1] then
                return {
                    message = 'OM',
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- Guru (J986)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_guru',
    rarity = 2,
    atlas = 'j_final_guru',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = false,
    calculate = function(self, card, context)
        if context.level_up and not context.blueprint then
            if #G.consumeables.cards < G.consumeables.config.card_limit then
                local _card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, nil, 'guru')
                _card:add_to_deck()
                G.consumeables:emplace(_card)
                return {
                    message = "GURU!",
                    colour = G.C.SECONDARY_SET.Spectral
                }
            end
        end
    end
})

-- Yogi (J987)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_yogi',
    config = { extra = { mult = 20 } },
    rarity = 2,
    atlas = 'j_final_yogi',
    pos = { x = 0, y = 0 },
    cost = 7,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).mult } } end,
    calculate = function(self, card, context)
        if context.joker_main and G.GAME.dollars == 0 then
            return {
                mult_mod = card.ability.extra.mult,
                message = localize{ type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }
            }
        end
    end
})

-- Avatar (J988)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_avatar',
    config = { extra = { target_key = nil } },
    rarity = 2,
    atlas = 'j_final_avatar',
    pos = { x = 0, y = 0 },
    cost = 9,
    blueprint_compat = false,
    loc_vars = function(self, info_queue, card) 
        local name = "None"
        if ( (card and card.ability and card.ability.extra) or self.config.extra ).target_key then
            name = G.P_CENTERS[( (card and card.ability and card.ability.extra) or self.config.extra ).target_key].name
        end
        return { vars = { name } } 
    end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            local other_jokers = {}
            for k, v in ipairs(G.jokers.cards) do
                if v ~= card then table.insert(other_jokers, v.config.center.key) end
            end
            if #other_jokers > 0 then
                -- ODYSSEY FIX: Ensure the correct vanilla helper is used
                card.ability.extra.target_key = pseudorandom_element(other_jokers, pseudoseed('avatar'))
            end
        end
        
        if card.ability.extra.target_key then
            local target_center = G.P_CENTERS[card.ability.extra.target_key]
            if target_center and target_center.calculate and type(target_center.calculate) == 'function' then
                -- Simular BluePrint/Brainstorm
                return target_center:calculate(card, context)
            end
        end
    end
})


-- J989-998: Final & Specials (Rare)

-- Enlightenment (J989)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_enlightenment',
    config = { extra = { x_mult = 4 } },
    rarity = 3,
    atlas = 'j_final_enlightenment',
    pos = { x = 0, y = 0 },
    cost = 15,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
        if context.setting_blind and not context.blueprint then
            for k, v in ipairs(G.playing_cards) do
                v:set_ability(G.P_CENTERS.m_odyssey_ceramic)
            end
        end
    end
})

-- Ascension (J990)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_ascension',
    config = { extra = { x_mult = 5 } },
    rarity = 3,
    atlas = 'j_final_ascension',
    pos = { x = 0, y = 0 },
    cost = 15,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Transcendence (J991)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_transcendence',
    config = { extra = { x_mult = 6 } },
    rarity = 3,
    atlas = 'j_final_transcendence',
    pos = { x = 0, y = 0 },
    cost = 15,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            local bonus = card.ability.extra.x_mult
            for k, v in ipairs(G.jokers.cards) do
                if v.config.center.rarity == 4 then bonus = bonus * 2; break end
            end
            return {
                x_mult = bonus,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { bonus } }
            }
        end
    end
})

-- Divinity (J992)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_divinity',
    config = { extra = { x_mult = 7 } },
    rarity = 3,
    atlas = 'j_final_divinity',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Omniscience (J993)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_omniscience',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_final_omniscience',
    pos = { x = 0, y = 0 },
    cost = 15,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            if G.GAME.blind and not G.GAME.blind.reveal_boss then 
                G.GAME.blind:reveal_boss()
            end
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Omnipotence (J994)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_omnipotence',
    config = { extra = { x_mult = 10, hand_size = -2 } },
    rarity = 3,
    atlas = 'j_final_omnipotence',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).hand_size } } end,
    add_to_deck = function(self, card)
        G.hand:change_size(card.ability.extra.hand_size)
    end,
    remove_from_deck = function(self, card)
        G.hand:change_size(-card.ability.extra.hand_size)
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Omnipresence (J995)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_omnipresence',
    rarity = 3,
    atlas = 'j_final_omnipresence',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    calculate = function(self, card, context)
        if context.retrigger_joker and not context.blueprint then
            if context.other_joker ~= card then
                return {
                    message = 'OMNIPRESENCE',
                    repetitions = 1,
                    card = card
                }
            end
        end
    end
})

-- Eternity (J996)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_eternity',
    config = { extra = { x_mult = 3 } },
    rarity = 3,
    atlas = 'j_final_eternity',
    pos = { x = 0, y = 0 },
    cost = 15,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
        if context.setting_blind and not context.blueprint then
            for k, v in ipairs(G.jokers.cards) do
                v:set_eternal(true)
            end
        end
    end
})

-- Infinity (J997)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_infinity',
    rarity = 3,
    atlas = 'j_final_infinity',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) 
        local bonus = G.GAME.hands_played or 0
        return { vars = { bonus } } 
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local bonus = G.GAME.hands_played or 0
            return {
                mult_mod = bonus,
                message = localize{ type = 'variable', key = 'a_mult', vars = { bonus } }
            }
        end
    end
})

-- Absolute (J998)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_absolute',
    config = { extra = { min_mult = 1000, x_mult = 2 } },
    rarity = 3,
    atlas = 'j_final_absolute',
    pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).min_mult, (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                mult_mod = 500,
                message = "ABSOLUTE"
            }
        end
    end
})


-- J999-1000: Final & Specials (Legendary)

-- The Creator (J999)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_the_creator',
    config = { extra = { x_mult = 100 } },
    rarity = 4,
    atlas = 'j_final_the_creator',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card) return { vars = { (( (card and card.ability and card.ability.extra) or self.config.extra )).x_mult } } end,
    calculate = function(self, card, context)
        if context.setting_blind and not context.blueprint then
            for k, v in ipairs(G.jokers.cards) do
                if not v.edition then v:set_edition({polychrome = true}) end
            end
        end
        if context.joker_main then
            return {
                x_mult = card.ability.extra.x_mult,
                message = localize{ type = 'variable', key = 'a_xmult', vars = { card.ability.extra.x_mult } }
            }
        end
    end
})

-- Odyssey (J1000)
SMODS.Joker({
    discovered = true,
    unlocked = true,
    key = 'j_final_odyssey',
    rarity = 4,
    atlas = 'j_final_odyssey',
    pos = { x = 0, y = 0 },
    soul_pos = { x = 0, y = 0 },
    cost = 20,
    blueprint_compat = true,
    loc_vars = function(self, info_queue, card)
        local count = 0
        if G.GAME and G.GAME.jokers_encountered then
            for _ in pairs(G.GAME.jokers_encountered) do count = count + 1 end
        end
        return { vars = { count } }
    end,
    calculate = function(self, card, context)
        if context.joker_main then
            local count = 0
            if G.GAME and G.GAME.jokers_encountered then
                for _ in pairs(G.GAME.jokers_encountered) do count = count + 1 end
            end
            if count > 0 then
                return {
                    x_mult = count,
                    message = "X" .. count,
                    colour = G.C.MULT
                }
            end
        end
    end
})


-- 1. Baralho Nebulosa
SMODS.Back({
    name = "Nebulosa",
    key = "nebula_deck",
    atlas = "b_nebula",
    pos = { x = 0, y = 0 },
    config = { vouchers = {'v_telescope'} },
})

-- 2. Baralho de Prtons
SMODS.Back({
    name = "Prtons",
    key = "protons",
    atlas = "b_protons",
    pos = { x = 0, y = 0 },
    config = { hand_size = 1 },
})

-- 3. Baralho de Eltrons
SMODS.Back({
    name = "Eltrons",
    key = "electrons",
    atlas = "b_electrons",
    pos = { x = 0, y = 0 },
    config = { discards = 1 },
})

-- 4. Baralho de Nutrons
SMODS.Back({
    name = "Nutrons",
    key = "neutrons",
    atlas = "b_neutrons",
    pos = { x = 0, y = 0 },
    config = { joker_slot = 2 },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    if v:is_face() then
                        v:start_dissolve(nil, true)
                    end
                end
                return true
            end
        }))
    end
})

-- 5. Baralho de Ftons
SMODS.Back({
    name = "Ftons",
    key = "photons",
    atlas = "b_photons",
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    v:set_ability(G.P_CENTERS.m_odyssey_diamond)
                end
                return true
            end
        }))
    end
})

-- 6. Baralho Gravitacional
SMODS.Back({
    name = "Gravitacional",
    key = "gravitational",
    atlas = "b_gravitational",
    pos = { x = 0, y = 0 },
    config = { odyssey_gravitational = true },
})

-- 7. Baralho Horizonte de Eventos
SMODS.Back({
    name = "Horizonte de Eventos",
    key = "event_horizon",
    atlas = "b_event_horizon",
    pos = { x = 0, y = 0 },
    config = { odyssey_event_horizon = true },
})

-- 8. Baralho Buraco de Minhoca
SMODS.Back({
    name = "Buraco de Minhoca",
    key = "wormhole",
    atlas = "b_wormhole",
    pos = { x = 0, y = 0 },
    config = { odyssey_wormhole = true },
})

-- 9. Baralho Supernova
SMODS.Back({
    name = "Supernova Deck",
    key = "supernova_deck",
    atlas = "b_supernova",
    pos = { x = 0, y = 0 },
    config = { odyssey_supernova = true },
})

-- 10. Baralho Quasar
SMODS.Back({
    name = "Quasar",
    key = "quasar",
    atlas = "b_quasar",
    pos = { x = 0, y = 0 },
    config = { odyssey_quasar = true, no_interest = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                G.GAME.round_resets.blind_states.Small = 'Skipped' -- Example logic, actually handled in game hooks
                return true
            end
        }))
    end
})

-- 11. Baralho Energia Escura
SMODS.Back({
    name = "Energia Escura",
    key = "dark_energy",
    atlas = "b_dark_energy",
    pos = { x = 0, y = 0 },
    config = { odyssey_dark_energy = true },
})

-- 12. Baralho Antimatria
SMODS.Back({
    name = "Antimatria",
    key = "antimatter",
    atlas = "b_antimatter",
    pos = { x = 0, y = 0 },
    config = { odyssey_antimatter = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                add_tag(Tag('tag_negative'))
                return true
            end
        }))
    end
})

-- 13. Baralho Vcuo
SMODS.Back({
    name = "Vcuo",
    key = "vacuum",
    atlas = "b_vacuum",
    pos = { x = 0, y = 0 },
    config = { odyssey_vacuum = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                if G.shop_jokers then
                    G.shop_jokers.card_limit = 6
                end
                return true
            end
        }))
    end
})

-- 14. Baralho Teoria das Cordas
SMODS.Back({
    name = "Teoria das Cordas",
    key = "string_theory",
    atlas = "b_string_theory",
    pos = { x = 0, y = 0 },
    config = { odyssey_string_theory = true },
})

-- 15. Baralho do Caos
SMODS.Back({
    name = "Caos",
    key = "chaos",
    atlas = "b_chaos",
    pos = { x = 0, y = 0 },
    config = { odyssey_chaos = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    local suit = pseudorandom_element({'S','H','D','C'}, pseudoseed('chaos_suit'))
                    local rank = pseudorandom_element({'2','3','4','5','6','7','8','9','T','J','Q','K','A'}, pseudoseed('chaos_rank'))
                    v:set_base(G.P_CARDS[suit..'_'..rank])
                end
                return true
            end
        }))
    end
})

-- 16. Baralho da Ordem
SMODS.Back({
    name = "Ordem",
    key = "order",
    atlas = "b_order",
    pos = { x = 0, y = 0 },
    config = { odyssey_order = true },
})

-- 17. Baralho do Paradoxo
SMODS.Back({
    name = "Paradoxo",
    key = "paradox",
    atlas = "b_paradox",
    pos = { x = 0, y = 0 },
    config = { odyssey_paradox = true, ante_scaling = 2 },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                G.GAME.round_resets.ante = 0
                return true
            end
        }))
    end
})

-- 18. Baralho da Linha do Tempo
SMODS.Back({
    name = "Linha do Tempo",
    key = "timeline",
    atlas = "b_timeline",
    pos = { x = 0, y = 0 },
    config = { odyssey_timeline = true },
})

-- 19. Baralho Paralelo
SMODS.Back({
    name = "Paralelo",
    key = "parallel",
    atlas = "b_parallel",
    pos = { x = 0, y = 0 },
    config = { hands = 2, discards = -2 },
})

-- 20. Baralho Dimensional
SMODS.Back({
    name = "Dimensional",
    key = "dimensional",
    atlas = "b_dimensional",
    pos = { x = 0, y = 0 },
    config = { odyssey_dimensional = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                -- Add 26 random cards to reach 78 cards
                for i = 1, 26 do
                    local card = create_card('Base', G.deck, nil, nil, nil, nil, nil, 'dim')
                    card:add_to_deck()
                    G.deck:emplace(card)
                    table.insert(G.playing_cards, card)
                end
                G.deck:shuffle()
                return true
            end
        }))
    end
})


-- 21. Baralho Hologrfico
SMODS.Back({
    name = "Hologrfico",
    key = "holografico",
    atlas = "b_holographic",
    pos = { x = 0, y = 0 },
    config = { odyssey_holographic = true },
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                local card = create_card('Joker', G.jokers, nil, 0, nil, nil, nil, 'holographic_deck')
                card:set_edition({holo = true}, true)
                card:add_to_deck()
                G.jokers:emplace(card)
                return true
            end
        }))
    end
})

-- 22. Baralho Policromtico
SMODS.Back({
    name = "Policromtico",
    key = "policromatico",
    atlas = "b_polychrome",
    pos = { x = 0, y = 0 },
    config = { odyssey_polychrome = true },
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                local card = create_card('Joker', G.jokers, nil, 0, nil, nil, nil, 'polychrome_deck')
                card:set_edition({polychrome = true}, true)
                card:add_to_deck()
                G.jokers:emplace(card)
                return true
            end
        }))
    end
})

-- 23. Baralho Laminado
SMODS.Back({
    name = "Laminado",
    key = "laminado",
    atlas = "b_foil",
    pos = { x = 0, y = 0 },
    config = { odyssey_laminado = true },
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                local card = create_card('Joker', G.jokers, nil, 0, nil, nil, nil, 'foil_deck')
                card:set_edition({foil = true}, true)
                card:add_to_deck()
                G.jokers:emplace(card)
                return true
            end
        }))
    end
})

-- 24. Baralho Negativo
SMODS.Back({
    name = "Negativo",
    key = "negativo",
    atlas = "b_negative",
    pos = { x = 0, y = 0 },
    config = { odyssey_negative = true },
    loc_vars = function(self, info_queue, card) return { vars = {} } end,
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                local card = create_card('Joker', G.jokers, nil, 0, nil, nil, nil, 'negative_deck')
                card:set_edition({negative = true}, true)
                card:add_to_deck()
                G.jokers:emplace(card)
                return true
            end
        }))
    end
})

-- 25. Baralho Cermica
SMODS.Back({
    name = "Cermica",
    key = "ceramic",
    atlas = "b_glass",
    pos = { x = 0, y = 0 },
    config = { odyssey_ceramic = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    v:set_ability(G.P_CENTERS.m_odyssey_ceramic)
                end
                return true
            end
        }))
    end
})

-- 26. Baralho Borracha
SMODS.Back({
    name = "Borracha",
    key = "rubber",
    atlas = "b_steel",
    pos = { x = 0, y = 0 },
    config = { odyssey_rubber = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    v:set_ability(G.P_CENTERS.m_odyssey_rubber)
                end
                return true
            end
        }))
    end
})

-- 27. Baralho Platina
SMODS.Back({
    name = "Platina",
    key = "platinum",
    atlas = "b_stone",
    pos = { x = 0, y = 0 },
    config = { odyssey_platinum = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    v:set_ability(G.P_CENTERS.m_odyssey_platinum)
                end
                return true
            end
        }))
    end
})

-- 28. Baralho Diamante
SMODS.Back({
    name = "Diamante",
    key = "diamond",
    atlas = "b_gold",
    pos = { x = 0, y = 0 },
    config = { odyssey_diamond = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    v:set_ability(G.P_CENTERS.m_odyssey_diamond)
                end
                return true
            end
        }))
    end
})

-- 29. Baralho Mgico
SMODS.Back({
    name = "Baralho Mgico",
    key = "sorte",
    atlas = "b_lucky",
    pos = { x = 0, y = 0 },
    config = { odyssey_magic_deck = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    v:set_ability(G.P_CENTERS.m_odyssey_magic)
                end
                return true
            end
        }))
    end
})

-- 30. Baralho Sagrado
SMODS.Back({
    name = "Baralho Sagrado",
    key = "selvagem",
    atlas = "b_wild",
    pos = { x = 0, y = 0 },
    config = { odyssey_holy_deck = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    v:set_ability(G.P_CENTERS.m_odyssey_holy)
                end
                return true
            end
        }))
    end
})

-- 31. Baralho de Rubi
SMODS.Back({
    name = "Baralho de Rubi",
    key = "multiplicador",
    atlas = "b_mult",
    pos = { x = 0, y = 0 },
    config = { odyssey_ruby_deck = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    v:set_ability(G.P_CENTERS.m_odyssey_ruby)
                end
                return true
            end
        }))
    end
})

-- 32. Baralho de Esmeralda
SMODS.Back({
    name = "Baralho de Esmeralda",
    key = "bonus",
    atlas = "b_bonus",
    pos = { x = 0, y = 0 },
    config = { odyssey_emerald_deck = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    v:set_ability(G.P_CENTERS.m_odyssey_emerald)
                end
                return true
            end
        }))
    end
})

-- 33. Baralho Duplo
SMODS.Back({
    name = "Duplo",
    key = "duplo",
    atlas = "b_double",
    pos = { x = 0, y = 0 },
    config = { odyssey_double = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for i = 1, 52 do
                    local card = create_card('Base', G.deck, nil, nil, nil, nil, nil, 'double')
                    card:add_to_deck()
                    G.deck:emplace(card)
                    table.insert(G.playing_cards, card)
                end
                G.deck:shuffle()
                return true
            end
        }))
    end
})

-- 34. Baralho Minsculo
SMODS.Back({
    name = "Minsculo",
    key = "minusculo",
    atlas = "b_tiny",
    pos = { x = 0, y = 0 },
    config = { odyssey_tiny = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in pairs(G.playing_cards) do
                    if v.base.suit == 'Spades' or v.base.suit == 'Clubs' then
                        v:start_dissolve(nil, true)
                    end
                end
                return true
            end
        }))
    end
})

-- 35. Baralho Ascenso
SMODS.Back({
    name = "Ascenso",
    key = "ascensao",
    atlas = "b_ascension",
    pos = { x = 0, y = 0 },
    config = { odyssey_ascension = true },
})

-- 36. Baralho Queda
SMODS.Back({
    name = "Queda",
    key = "queda",
    atlas = "b_fall",
    pos = { x = 0, y = 0 },
    config = { odyssey_fall = true },
})

-- 37. Baralho Avareza
SMODS.Back({
    name = "Avareza",
    key = "avareza",
    atlas = "b_avarice",
    pos = { x = 0, y = 0 },
    config = { odyssey_avarice = true, no_interest = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                G.GAME.modifiers.no_interest = true
                return true
            end
        }))
    end
})

-- 38. Baralho Pobreza
SMODS.Back({
    name = "Pobreza",
    key = "pobreza",
    atlas = "b_poverty",
    pos = { x = 0, y = 0 },
    config = { odyssey_poverty = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                G.GAME.dollars = 0
                G.GAME.interest_cap = 10
                return true
            end
        }))
    end
})

-- 39. Baralho Gula
SMODS.Back({
    name = "Gula",
    key = "gula",
    atlas = "b_gluttony",
    pos = { x = 0, y = 0 },
    config = { joker_slot = 2, consumable_slot = -2 },
})

-- 40. Baralho Inveja
SMODS.Back({
    name = "Inveja",
    key = "inveja",
    atlas = "b_envy",
    pos = { x = 0, y = 0 },
    config = { odyssey_envy = true },
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                local card = create_card('Joker', G.jokers, nil, 0, nil, nil, 'j_mime', 'envy_deck')
                card:add_to_deck()
                G.jokers:emplace(card)
                return true
            end
        }))
    end
})


-- Decks 41-60

-- 41. Baralho Baralho Ira
SMODS.Back({
    key = 'wrath',
    atlas = 'b_wrath',
    pos = { x = 0, y = 0 },
    config = { discards = 1 },
    apply = function(self)
        G.GAME.modifiers.discard_cost = 1
    end
})

-- 42. Baralho Baralho Preguia
SMODS.Back({
    key = 'sloth',
    atlas = 'b_sloth',
    pos = { x = 0, y = 0 },
    config = { discards = -100, hands = -3 }
})

-- 43. Baralho Baralho Luxria
SMODS.Back({
    key = 'lust',
    atlas = 'b_lust',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 44. Baralho Baralho Orgulho
SMODS.Back({
    key = 'pride',
    atlas = 'b_pride',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 45. Baralho Baralho Alfa
SMODS.Back({
    key = 'alpha',
    atlas = 'b_alpha',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for i = #G.playing_cards, 1, -1 do
                    local card = G.playing_cards[i]
                    local id = card.base.id
                    -- Keep A(14), 2, 3, 4, 5. Remove others.
                    if id > 5 and id < 14 then
                        card:remove()
                        card = nil
                    end
                end
                return true
            end
        }))
    end
})

-- 46. Baralho Baralho mega
SMODS.Back({
    key = 'omega',
    atlas = 'b_omega',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for i = #G.playing_cards, 1, -1 do
                    local card = G.playing_cards[i]
                    local id = card.base.id
                    -- Keep 10, J, Q, K, A. Remove id < 10.
                    if id < 10 then
                        card:remove()
                        card = nil
                    end
                end
                return true
            end
        }))
    end
})

-- 47. Baralho Baralho Zero
SMODS.Back({
    key = 'zero',
    atlas = 'b_zero',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for i = #G.playing_cards, 1, -1 do
                    local card = G.playing_cards[i]
                    local id = card.base.id
                    -- Keep 2-9. Remove id >= 10.
                    if id >= 10 then
                        card:remove()
                        card = nil
                    end
                end
                return true
            end
        }))
    end
})

-- 48. Baralho Baralho Fibonacci
SMODS.Back({
    key = 'fibonacci',
    atlas = 'b_fibonacci',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                local allowed = { [14] = true, [2] = true, [3] = true, [5] = true, [8] = true }
                for i = #G.playing_cards, 1, -1 do
                    local card = G.playing_cards[i]
                    if not allowed[card.base.id] then
                        card:remove()
                        card = nil
                    end
                end
                return true
            end
        }))
    end
})

-- 49. Baralho Baralho Primo
SMODS.Back({
    key = 'prime',
    atlas = 'b_prime',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                local allowed = { [2] = true, [3] = true, [5] = true, [7] = true, [11] = true, [13] = true }
                for i = #G.playing_cards, 1, -1 do
                    local card = G.playing_cards[i]
                    if not allowed[card.base.id] then
                        card:remove()
                        card = nil
                    end
                end
                return true
            end
        }))
    end
})

-- 50. Baralho Baralho Odisseia
SMODS.Back({
    key = 'odyssey',
    atlas = 'b_odyssey',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                local card = create_card('Joker', G.jokers, true, 4, nil, nil, 'j_final_odyssey', 'odyssey_deck')
                card:add_to_deck()
                G.jokers:emplace(card)
                return true
            end
        }))
    end
})

-- 51. Baralho Baralho Fractal
SMODS.Back({
    key = 'fractal',
    atlas = 'b_fractal',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 52. Baralho Baralho Espelho
SMODS.Back({
    key = 'mirror',
    atlas = 'b_mirror',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 53. Baralho Baralho Fantasma
SMODS.Back({
    key = 'ghost',
    atlas = 'b_ghost',
    pos = { x = 0, y = 0 },
    config = { hands = -2 }
})

-- 54. Baralho Baralho Vampiro
SMODS.Back({
    key = 'vampire',
    atlas = 'b_vampire',
    pos = { x = 0, y = 0 },
    config = { extra = { mult = 0, gain = 1 } }
})

-- 55. Baralho Baralho Zumbi
SMODS.Back({
    key = 'zombie',
    atlas = 'b_zombie',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.GAME.modifiers.odyssey_zombie = true
    end
})

-- 56. Baralho Baralho Ciborgue
SMODS.Back({
    key = 'cyborg',
    atlas = 'b_cyborg',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for i=1, 2 do
                    local card = create_card('Joker', G.jokers, nil, 0, nil, nil, nil, 'cyborg_deck')
                    card:add_to_deck()
                    G.jokers:emplace(card)
                end
                return true
            end
        }))
    end
})

-- 57. Baralho Baralho Alien
SMODS.Back({
    key = 'alien',
    atlas = 'b_alien',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 58. Baralho Baralho Mutante
SMODS.Back({
    key = 'mutant',
    atlas = 'b_mutant',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 59. Baralho Baralho Clone
SMODS.Back({
    key = 'clone',
    atlas = 'b_clone',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in ipairs(G.playing_cards) do
                    v:set_base(G.P_CARDS.S_A)
                end
                return true
            end
        }))
    end
})

-- 60. Baralho Baralho Invisvel
SMODS.Back({
    key = 'invisible',
    atlas = 'b_invisible',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for k, v in ipairs(G.playing_cards) do
                    v.facing = 'back'
                end
                return true
            end
        }))
    end
})



-- Decks 61-80

-- 61. Baralho Baralho Etreo
SMODS.Back({
    key = 'ethereal',
    atlas = 'b_ethereal',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        -- Logic handled in 03_vanilla_override (or standard Steamodded config?)
        -- Actually we need to hook into usage rate.
        -- Base game uses G.GAME.modifiers.spectral_rate or similar? No, only tarot/planet usually.
        -- Standard shop generation: G.E_MANAGER adds cards.
        -- We can set a flag G.GAME.modifiers.odyssey_ethereal_shop = true
        G.GAME.modifiers.odyssey_ethereal_shop = true
    end
})

-- 62. Baralho Baralho Radioativo
SMODS.Back({
    key = 'radioactive',
    atlas = 'b_radioactive',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 63. Baralho Baralho Magntico
SMODS.Back({
    key = 'magnetic',
    atlas = 'b_magnetic',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 64. Baralho Baralho Congelado
SMODS.Back({
    key = 'frozen',
    atlas = 'b_frozen',
    pos = { x = 0, y = 0 },
    config = { hands = 2 }
})

-- 65. Baralho Baralho Vulcnico
SMODS.Back({
    key = 'volcanic',
    atlas = 'b_volcanic',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 66. Baralho Baralho Ocenico
SMODS.Back({
    key = 'oceanic',
    atlas = 'b_oceanic',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for i = #G.playing_cards, 1, -1 do
                    local card = G.playing_cards[i]
                    if card.base.suit == 'Diamonds' or card.base.suit == 'Hearts' then
                        card:remove()
                        card = nil
                    end
                end
                return true
            end
        }))
    end
})

-- 67. Baralho Baralho Solar
SMODS.Back({
    key = 'solar',
    atlas = 'b_solar',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for i = #G.playing_cards, 1, -1 do
                    local card = G.playing_cards[i]
                    if card.base.suit == 'Spades' or card.base.suit == 'Clubs' then
                        card:remove()
                        card = nil
                    end
                end
                return true
            end
        }))
    end
})

-- 68. Baralho Baralho Lunar
SMODS.Back({
    key = 'lunar',
    atlas = 'b_lunar',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 69. Baralho Baralho Estelar
SMODS.Back({
    key = 'stellar',
    atlas = 'b_stellar',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for i=1, 5 do
                    local card = create_card('Planet', G.consumables, nil, nil, nil, nil, nil, 'stellar_deck')
                    card:add_to_deck()
                    G.consumables:emplace(card)
                end
                return true
            end
        }))
    end
})

-- 70. Baralho Baralho Mstico
SMODS.Back({
    key = 'mystic',
    atlas = 'b_mystic',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for i=1, 5 do
                    local card = create_card('Tarot', G.consumables, nil, nil, nil, nil, nil, 'mystic_deck')
                    card:add_to_deck()
                    G.consumables:emplace(card)
                end
                return true
            end
        }))
    end
})

-- 71. Baralho Baralho Tecnolgico
SMODS.Back({
    key = 'tech',
    atlas = 'b_tech',
    pos = { x = 0, y = 0 },
    config = { dollars = 100 },
    apply = function(self)
        G.GAME.modifiers.odyssey_shop_price_mult = 2
    end
})

-- 72. Baralho Baralho Primitivo
SMODS.Back({
    key = 'primitive',
    atlas = 'b_primitive',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 73. Baralho Baralho Arcano
SMODS.Back({
    key = 'arcane',
    atlas = 'b_arcane',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.GAME.modifiers.odyssey_free_arcana = true
    end
})

-- 74. Baralho Baralho Celestial
SMODS.Back({
    key = 'celestial',
    atlas = 'b_celestial',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.GAME.modifiers.odyssey_free_planet = true
    end
})

-- 75. Baralho Baralho Espectral
SMODS.Back({
    key = 'spectral',
    atlas = 'b_spectral',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.GAME.modifiers.odyssey_free_spectral = true
    end
})

-- 76. Baralho Baralho Standard
SMODS.Back({
    key = 'standard',
    atlas = 'b_standard',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.GAME.modifiers.odyssey_free_standard = true
    end
})

-- 77. Baralho Baralho Buffoon
SMODS.Back({
    key = 'buffoon',
    atlas = 'b_buffoon',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.GAME.modifiers.odyssey_free_buffoon = true
    end
})

-- 78. Baralho Baralho Mercenrio
SMODS.Back({
    key = 'mercenary',
    atlas = 'b_mercenary',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 79. Baralho Baralho Investidor
SMODS.Back({
    key = 'investor',
    atlas = 'b_investor',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.GAME.interest_cap = 1000
    end
})

-- 80. Baralho Baralho Minimalista II
SMODS.Back({
    key = 'minimalist_ii',
    atlas = 'b_minimalist_ii',
    pos = { x = 0, y = 0 },
    config = { hand_size = -5 }
})



-- Decks 81-100

-- 81. Baralho Baralho Maximalista II
SMODS.Back({
    key = 'maximalist_ii',
    atlas = 'b_maximalist_ii',
    pos = { x = 0, y = 0 },
    config = { hand_size = 2, discards = -100 }
})

-- 82. Baralho Baralho Catico II
SMODS.Back({
    key = 'chaotic_ii',
    atlas = 'b_chaotic_ii',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 83. Baralho Baralho Ordenado II
SMODS.Back({
    key = 'ordered_ii',
    atlas = 'b_ordered_ii',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        -- Disable boss blinds (handled in game logic usually by simply not triggering ability)
        -- But for global effect, we might need a hook.
        -- Setting a custom modifier flag.
        G.GAME.modifiers.odyssey_no_boss_effect = true
    end
})

-- 84. Baralho Baralho Sortudo II
SMODS.Back({
    key = 'lucky_ii',
    atlas = 'b_lucky_ii',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.GAME.probabilities.normal = 1
    end
})

-- 85. Baralho Baralho Azarado
SMODS.Back({
    key = 'unlucky',
    atlas = 'b_unlucky',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.GAME.probabilities.normal = 1000
    end
})

-- 86. Baralho Baralho Rei Midas
SMODS.Back({
    key = 'midas',
    atlas = 'b_midas',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.GAME.modifiers.odyssey_midas = true
    end
})

-- 87. Baralho Baralho Rei Arthur
SMODS.Back({
    key = 'arthur',
    atlas = 'b_arthur',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                local card = create_card('Joker', G.jokers, true, 4, nil, nil, 'j_final_odyssey', 'arthur_deck')
                card:add_to_deck()
                G.jokers:emplace(card)
                return true
            end
        }))
    end
})

-- 88. Baralho Baralho Merlin
SMODS.Back({
    key = 'merlin',
    atlas = 'b_merlin',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                for i=1, 3 do
                    local card = create_card('Tarot', G.consumables, nil, nil, nil, nil, nil, 'merlin_deck')
                    card:add_to_deck()
                    G.consumables:emplace(card)
                end
                return true
            end
        }))
    end
})

-- 89. Baralho Baralho Drago
SMODS.Back({
    key = 'dragon',
    atlas = 'b_dragon',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 90. Baralho Baralho Fnix
SMODS.Back({
    key = 'phoenix',
    atlas = 'b_phoenix',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 91. Baralho Baralho Hidra
SMODS.Back({
    key = 'hydra',
    atlas = 'b_hydra',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 92. Baralho Baralho Quimera
SMODS.Back({
    key = 'chimera',
    atlas = 'b_chimera',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 93. Baralho Baralho Grifo
SMODS.Back({
    key = 'griffin',
    atlas = 'b_griffin',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 94. Baralho Baralho Unicrnio
SMODS.Back({
    key = 'unicorn',
    atlas = 'b_unicorn',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 95. Baralho Baralho Kraken
SMODS.Back({
    key = 'kraken',
    atlas = 'b_kraken',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 96. Baralho Baralho Leviat
SMODS.Back({
    key = 'leviathan',
    atlas = 'b_leviathan',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 97. Baralho Baralho Behemoth
SMODS.Back({
    key = 'behemoth',
    atlas = 'b_behemoth',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 98. Baralho Baralho Tit
SMODS.Back({
    key = 'titan',
    atlas = 'b_titan',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 99. Baralho Baralho Gnomo
SMODS.Back({
    key = 'gnome',
    atlas = 'b_gnome',
    pos = { x = 0, y = 0 },
    config = {}
})

-- 100. Baralho Baralho O Criador
SMODS.Back({
    key = 'the_creator',
    atlas = 'b_the_creator',
    pos = { x = 0, y = 0 },
    config = {},
    apply = function(self)
        G.E_MANAGER:add_event(Event({
            func = function()
                local card = create_card('Joker', G.jokers, true, 4, nil, nil, 'j_final_the_creator', 'creator_deck')
                card:add_to_deck()
                G.jokers:emplace(card)
                return true
            end
        }))
    end
})



----------------------------------------------
------------MOD CODE END----------------------
----------------------------------------------

-- Executar overrides de vanilla
if BalatroOdyssey.disable_vanilla_content then
    BalatroOdyssey.disable_vanilla_content()
end
if BalatroOdyssey.disable_vanilla_decks then
    BalatroOdyssey.disable_vanilla_decks()
end

-- Revelar todo o contedo do Odyssey no menu Colees
BalatroOdyssey.reveal_all_content()

--------------------------------------------------------------------------------
-- PONTUAO E LIMITES (EXPAND PLAY LIMIT)
--------------------------------------------------------------------------------
-- Permitir jogar at 10 cartas para as mos especiais do Odyssey

G.FUNCS.can_play = function(e)
    if not G.hand or not G.hand.highlighted or #G.hand.highlighted <= 0 or (G.GAME and G.GAME.blind and G.GAME.blind.block_play) or #G.hand.highlighted > 10 then 
        e.config.colour = G.C.UI.BACKGROUND_INACTIVE
        e.config.button = nil
    else
        e.config.colour = G.C.BLUE
        e.config.button = 'play_cards_from_highlighted'
    end
end

-- Hook para garantir limites (Reforo dinmico em cada frame)
local old_game_update = Game.update
function Game:update(dt)
    old_game_update(self, dt)
    
    -- Safety checks para evitar crash se o jogo no estiver totalmente carregado
    if G.play and G.play.config then
        G.play.config.card_limit = 10
    end
    
    if G.hand and G.hand.config then
        -- Balatro usa ambos os nomes dependendo do contexto
        G.hand.config.highlighted_limit = 10
        G.hand.config.highlight_limit = 10
    end
end

-- Garantir limites no incio ou carregamento de uma run
local game_start_run_ref = Game.start_run
function Game:start_run(args)
    local ret = game_start_run_ref(self, args)
    if G.play then G.play.config.card_limit = 10 end
    if G.hand then 
        G.hand.config.highlighted_limit = 10
        G.hand.config.highlight_limit = 10
    end
    return ret
end

local game_load_run_ref = Game.load_run
function Game:load_run(args)
    local ret = game_load_run_ref(self, args)
    if G.play then G.play.config.card_limit = 10 end
    if G.hand then 
        G.hand.config.highlighted_limit = 10
        G.hand.config.highlight_limit = 10
    end
    return ret
end


